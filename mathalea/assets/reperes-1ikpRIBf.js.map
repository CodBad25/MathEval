{"version":3,"file":"reperes-1ikpRIBf.js","sources":["../../src/lib/2d/reperes.ts"],"sourcesContent":["import {\n  colorToLatexOrHTML,\n  fixeBordures,\n  ObjetMathalea2D,\n} from '../../modules/2dGeneralites'\nimport { context } from '../../modules/context'\nimport { arrondi, rangeMinMax } from '../outils/nombres'\nimport { nombreAvecEspace, stringNombre } from '../outils/texNombre'\nimport { Plot, plot, point, tracePoint } from './points'\nimport { segment } from './segmentsVecteurs'\nimport {\n  latex2d,\n  latexParCoordonnees,\n  texteParPoint,\n  texteParPosition,\n} from './textes'\n\n/**  Trace un axe gradué\n * @param {Object} parametres À saisir entre accolades\n * @param {number?} [parametres.Unite = 10] Nombre de cm par unité\n * @param {number?} [parametres.Min = 10] Valeur minimum labelisée sur l'axe (les graduations commencent un peu avant)\n * @param {number?} [parametres.Max = 10] Valeur maximum labelisée sur l'axe (les graduations finissent un peu après)\n * @param {number?} [parametres.x = 0] Abscisse du point de départ du tracé\n * @param {number?} [parametres.y = 0] Ordonnée du point de départ du tracé\n * @param {number?} [parametres.axeEpaisseur = 2] Épaisseur de l'axe gradué\n * @param {string?} [parametres.axeCouleur = 'black'] Couleur de l'axe gradué : du type 'blue' ou du type '#f15929'\n * @param {string?} [parametres.axeStyle = \"->\"] Style final de l'axe gradué\n * @param {number?} [parametres.axeHauteur = 4] Définit la \"largeur\" de l'axe, celle des graduations et du style final\n * @param {string?} [parametres.axePosition = 'H'] Position de l'axe : 'H' pour horizontal, 'V' pour vertical\n * @param {number?} [parametres.thickEpaisseur = 2] Épaisseur des graduations\n * @param {string?} [parametres.thickCouleur = axeCouleur] Couleur des graduations : du type 'blue' ou du type '#f15929'\n * @param {number?} [parametres.thickDistance = 1] Distance entre deux graduations principales\n * @param {number?} [parametres.thickOffset = 0] Décalage de toutes les graduations sur l'axe (pour, par exemple, faire coïncider le début de l'axe avec une graduation)\n * @param {boolean?} [parametres.thickSec = false] Affichage (ou pas) des graduations secondaires\n * @param {number?} [parametres.thickSecDist = 0.1] Distance entre deux graduations secondaires\n * @param {boolean?} [parametres.thickTer = false] Affichage (ou pas) des graduations secondaires\n * @param {number?} [parametres.thickTerDist = 0.1] Distance entre deux graduations tertiaires, false sinon\n * @param {[number, string][]} [parametres.pointListe = []] Liste de points à mettre sur l'axe comme, par exemple, [[3.4,'A'],[3.8,'B']]. Les noms se placent au-dessus de l'axe.\n * @param {number?} [parametres.labelPointTaille = 10] Taille (hauteur) de la police des points (de la liste des points pointListe) utilisée de 5 = \\small à 20=\\huge...\n * @param {number?} [parametres.labelPointLargeur = 20] Largeur de la boîte où sont affichés les points (de la liste des points pointListe) utilisée de 5 = \\small à 20=\\huge...\n * @param {string?} [parametres.pointCouleur = 'blue'] Couleur des points de la liste pointListe : du type 'blue' ou du type '#f15929'\n * @param {number?} [parametres.pointTaille = 4] Taille en pixels des points de la liste  pointListe\n * @param {string?} [parametres.pointStyle = '+'] Style des points de la liste pointListe\n * @param {number?} [parametres.pointOpacite = 0.8] Opacité des points de la liste pointListe\n * @param {number?} [parametres.pointEpaisseur = 2] Épaisseur des points de la liste pointListe\n * @param {boolean?} [parametres.labelsPrincipaux = true] Présence (ou non) des labels numériques principaux\n * @param {boolean?} [parametres.labelsSecondaires = false] Présence (ou non) des labels numériques secondaires\n * @param {number?} [parametres.step1 = 1] Pas des labels numériques principaux\n * @param {number?} [parametres.step2 = 1] Pas des labels numériques secondaires\n * @param {number?} [parametres.labelDistance = (axeHauteur + 10) / context.pixelsParCm] Distance entre les labels et l'axe\n * @param {number?} [parametres.labelCustomDistance = (axeHauteur + 10) / context.pixelsParCm] Distance entre les labels et l'axe\n * @param {array?} [parametres.labelListe = []] Liste de labels à mettre sous l'axe comme, par exemple, [[2.8,'x'],[3.1,'y']]. Les noms se placent en-dessous de l'axe.\n * @param {string?} [parametres.labelColor = 'black'] Couleur des labels de la liste labelListe : du type 'blue' ou du type '#f15929'\n * @param {number?} [parametres.labelScale = 1] Echelle des labels\n * @param {string?} [parametres.Legende = ''] Légende de l'axe\n * @param {number?} [parametres.LegendePosition] Position de la légende\n * @property {number?} Unite Nombre de cm par unité\n * @property {number?} Min Valeur minimum labelisée sur l'axe (les graduations commencent un peu avant)\n * @property {number?} Max Valeur maximum labelisée sur l'axe (les graduations finissent un peu après)\n * @author Jean-Claude Lhote\n * @return {array} Liste d'objets MathAlea2D\n */\n// JSDOC Validee par EE Aout 2022\nexport class DroiteGraduee extends ObjetMathalea2D {\n  Unite: number\n  Min: number\n  Max: number\n  constructor({\n    Unite = 10,\n    Min = 0,\n    Max = 2,\n    x = 0,\n    y = 0,\n    axeEpaisseur = 2,\n    axeCouleur = 'black',\n    axeStyle = '->',\n    axeHauteur = 4,\n    axePosition = 'H',\n    thickEpaisseur = 2,\n    thickCouleur = axeCouleur,\n    thickDistance = 1,\n    thickOffset = 0,\n    thickSecDist = 0.1,\n    thickSec = false,\n    thickTerDist = 0.01,\n    thickTer = false,\n    pointListe = [],\n    labelPointTaille = 10,\n    labelPointLargeur = 20,\n    pointCouleur = 'blue',\n    pointTaille = 4,\n    pointStyle = '+',\n    pointOpacite = 0.8,\n    pointEpaisseur = 2,\n    labelsPrincipaux = true,\n    labelsSecondaires = false,\n    labelColor = 'black',\n    step1 = 1,\n    step2 = 1,\n    labelCustomDistance = (axeHauteur + 10) / context.pixelsParCm,\n    labelDistance = (axeHauteur + 10) / context.pixelsParCm,\n    labelListe = [],\n    // labelColor = 'black',\n    // labelScale = 1,\n    Legende = '',\n    LegendePosition = (Max - Min) * Unite + 1.5,\n  }: {\n    Unite?: number\n    Min?: number\n    Max?: number\n    x?: number\n    y?: number\n    axeEpaisseur?: number\n    axeCouleur?: string\n    axeStyle?: string\n    axeHauteur?: number\n    axePosition?: string\n    thickEpaisseur?: number\n    thickCouleur?: string\n    thickDistance?: number\n    thickOffset?: number\n    thickSecDist?: number\n    thickSec?: boolean\n    thickTerDist?: number\n    thickTer?: boolean\n    pointListe?: [number, string][]\n    labelPointTaille?: number\n    labelPointLargeur?: number\n    pointCouleur?: string\n    pointTaille?: number\n    pointStyle?: string\n    pointOpacite?: number\n    pointEpaisseur?: number\n    labelsPrincipaux?: boolean\n    labelsSecondaires?: boolean\n    step1?: number\n    step2?: number\n    labelCustomDistance?: number\n    labelDistance?: number\n    labelListe?: [number, string][]\n    labelColor?: string\n    Legende?: string\n    LegendePosition?: number\n  }) {\n    super()\n    // correctif Jean-Claude Lhote 15/08/2023\n    // Les propriétés exportables\n    this.Unite = Unite\n    this.Min = Min\n    this.Max = Max\n    this.objets = []\n    let S\n    let T\n    let P\n    let i\n    let longueurTotale = (Max - Min) * Unite + 0.5 // la longueur totale de l'axe flèche comprise\n    let absord = [1, 0] // Constantes pour gérer la verticalité ou l'horizontalité de l'axe\n    if (axePosition !== 'H') absord = [0, 1]\n    // dessin de l'axe\n    if (axeStyle === '->') {\n      longueurTotale += 0.2\n      S = segment(\n        point(x - 0.2 * absord[0], y - 0.2 * absord[1]),\n        point(x + longueurTotale * absord[0], y + longueurTotale * absord[1]),\n        axeCouleur,\n      )\n      S.styleExtremites = '->'\n      S.tailleExtremites = axeHauteur\n      S.epaisseur = axeEpaisseur\n    } else {\n      S = segment(\n        point(x, y),\n        point(x + longueurTotale * absord[0], y + longueurTotale * absord[1]),\n        axeCouleur,\n      )\n      S.styleExtremites = axeStyle || '|->'\n      S.epaisseur = axeEpaisseur\n      S.tailleExtremites = axeHauteur\n    }\n    this.objets.push(S)\n    let factor\n    const r = 10 / context.pixelsParCm\n    if (thickTer) factor = 1 / thickTerDist\n    else if (thickSec) factor = 1 / thickSecDist\n    else factor = 1 / thickDistance\n\n    const Min2 = Math.ceil((Min + thickOffset) * factor) // début des graduations (ne coïncide pas nécéssairement avec le début de la droite)\n    const Max2 = Math.floor((Max - thickOffset) * factor) // fin des graduations\n    const pas1 = Math.round(thickDistance * factor)\n    const pas2 = Math.round(thickSecDist * factor)\n    for (let j = Min2; j <= Max2; j++) {\n      i = (j - Min * factor) / factor\n      if (j % pas1 === 0) {\n        // Graduation principale\n        S = segment(\n          point(\n            x + i * Unite * absord[0] - (axeHauteur / 8) * r * absord[1],\n            y - (axeHauteur / 8) * r * absord[0] + i * Unite * absord[1],\n          ),\n          point(\n            x + i * Unite * absord[0] + (axeHauteur / 8) * r * absord[1],\n            y + (axeHauteur / 8) * r * absord[0] + i * Unite * absord[1],\n          ),\n          thickCouleur,\n        )\n        S.epaisseur = thickEpaisseur\n        this.objets.push(S)\n      } else if (j % pas2 === 0 && thickSec) {\n        // Graduation secondaire\n        S = segment(\n          point(\n            x + i * Unite * absord[0] - (axeHauteur / 12) * r * absord[1],\n            y - (axeHauteur / 12) * r * absord[0] + i * Unite * absord[1],\n          ),\n          point(\n            x + i * Unite * absord[0] + (axeHauteur / 12) * r * absord[1],\n            y + (axeHauteur / 12) * r * absord[0] + i * Unite * absord[1],\n          ),\n          thickCouleur,\n        )\n        S.epaisseur = thickEpaisseur / 2\n        S.opacite = 0.8\n        this.objets.push(S)\n      } else if (thickTer) {\n        // Graduation tertiaire\n        S = segment(\n          point(\n            x + i * Unite * absord[0] - (axeHauteur / 16) * r * absord[1],\n            y - (axeHauteur / 16) * r * absord[0] + i * Unite * absord[1],\n          ),\n          point(\n            x + i * Unite * absord[0] + (axeHauteur / 16) * r * absord[1],\n            y + (axeHauteur / 16) * r * absord[0] + i * Unite * absord[1],\n          ),\n          thickCouleur,\n        )\n        S.epaisseur = thickEpaisseur / 4\n        S.opacite = 0.6\n        this.objets.push(S)\n      }\n    }\n    // Les labels principaux\n    if (labelsPrincipaux) {\n      for (let j = Min2; j <= Max2; j++) {\n        if (j % (step1 * pas1) === 0) {\n          i = (j - Min * factor) / factor\n          T = latexParCoordonnees(\n            `${nombreAvecEspace(arrondi(Min + i, 3))}`,\n            x + i * Unite * absord[0] - labelDistance * absord[1],\n            y + i * Unite * absord[1] - labelDistance * absord[0],\n            'black',\n            0,\n            0,\n            '',\n            8,\n          )\n          this.objets.push(T)\n        }\n      }\n    }\n    if (labelsSecondaires) {\n      for (let j = Min2; j <= Max2; j++) {\n        if (j % (step2 * pas2) === 0 && j % (step1 * pas1) !== 0) {\n          i = (j - Min * factor) / factor\n          T = latexParCoordonnees(\n            `${nombreAvecEspace(arrondi(Min + i, 3))}`,\n            x + i * Unite * absord[0] - labelDistance * absord[1],\n            y + i * Unite * absord[1] - labelDistance * absord[0],\n            'black',\n            0,\n            0,\n            '',\n            8,\n          )\n          this.objets.push(T)\n        }\n      }\n    }\n    // Les labels facultatifs\n    let t\n    if (labelListe.length !== 0) {\n      for (const p of labelListe) {\n        t = latex2d(\n          p[1],\n          x -\n            labelCustomDistance * absord[1] +\n            (p[0] - Min) * absord[0] * Unite,\n          y -\n            labelCustomDistance * absord[0] +\n            (p[0] - Min) * absord[1] * Unite,\n          { letterSize: 'normalsize', color: labelColor },\n        )\n        this.objets.push(t)\n      }\n    }\n    if (Legende !== '') {\n      this.objets.push(\n        texteParPosition(\n          Legende,\n          x + LegendePosition * absord[0],\n          y + LegendePosition * absord[1],\n        ),\n      )\n    }\n    if (pointListe.length !== 0) {\n      let lab\n      for (const p of pointListe) {\n        P = point(\n          x + (p[0] - Min) * absord[0] * Unite,\n          y + (p[0] - Min) * absord[1] * Unite,\n          p[1],\n        )\n        T = tracePoint(P, pointCouleur)\n        T.taille = pointTaille\n        T.tailleTikz = Math.max(T.taille / 30, 0.3)\n        T.opacite = pointOpacite\n        T.style = pointStyle\n        T.epaisseur = pointEpaisseur\n        lab = latex2d(\n          p[1],\n          x - 0.8 * absord[1] + (p[0] - Min) * absord[0] * Unite,\n          y + 0.8 * absord[0] + (p[0] - Min) * absord[1] * Unite,\n          { color: pointCouleur },\n        )\n\n        this.objets.push(T, lab)\n      }\n    }\n    const bordures = fixeBordures(this.objets, {\n      rxmin: 0,\n      rxmax: 0,\n      rymin: 0,\n      rymax: 0,\n    })\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n}\n\n/**  Trace un axe gradué\n * @param {Object} parametres À saisir entre accolades\n * @param {number} [parametres.Unite = 10] Nombre de cm par unité\n * @param {number} [parametres.Min = 10] Valeur minimum labelisée sur l'axe (les graduations commencent un peu avant)\n * @param {number} [parametres.Max = 10] Valeur maximum labelisée sur l'axe (les graduations finissent un peu après)\n * @param {number} [parametres.x = 0] Abscisse du point de départ du tracé\n * @param {number} [parametres.y = 0] Ordonnée du point de départ du tracé\n * @param {number} [parametres.axeEpaisseur = 2] Épaisseur de l'axe gradué\n * @param {string} [parametres.axeCouleur = 'black'] Couleur de l'axe gradué : du type 'blue' ou du type '#f15929'\n * @param {string} [parametres.axeStyle = '->'] Style final de l'axe gradué\n * @param {number} [parametres.axeHauteur = 4] Définit la \"largeur\" de l'axe, celle des graduations et du style final\n * @param {string} [parametres.axePosition = 'H'] Position de l'axe : 'H' pour horizontal, 'V' pour vertical\n * @param {number} [parametres.thickEpaisseur = 2] Épaisseur des graduations\n * @param {string} [parametres.thickCouleur = axeCouleur] Couleur des graduations : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.thickDistance = 1] Distance entre deux graduations principales\n * @param {number} [parametres.thickOffset = 0] Décalage de toutes les graduations sur l'axe (pour, par exemple, faire coïncider le début de l'axe avec une graduation)\n * @param {boolean?} [parametres.thickSec = false] Affichage (ou pas) des graduations secondaires\n * @param {number} [parametres.thickSecDist = 0.1] Distance entre deux graduations secondaires\n * @param {boolean?} [parametres.thickTer = false] Affichage (ou pas) des graduations secondaires\n * @param {number} [parametres.thickTerDist = 0.1] Distance entre deux graduations tertiaires, false sinon\n * @param {array?} [parametres.pointListe = []] Liste de points à mettre sur l'axe comme, par exemple, [[3.4,'A'],[3.8,'B']]. Les noms se placent au-dessus de l'axe.\n * @param {number} [parametres.labelPointTaille = 10] Taille (hauteur) de la police des points (de la liste des points pointListe) utilisée de 5 = \\small à 20=\\huge...\n * @param {number} [parametres.labelPointLargeur = 20] Largeur de la boîte où sont affichés les points (de la liste des points pointListe) utilisée de 5 = \\small à 20=\\huge...\n * @param {string} [parametres.pointCouleur = 'blue'] Couleur des points de la liste pointListe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.pointTaille = 4] Taille en pixels des points de la liste  pointListe\n * @param {string} [parametres.pointStyle = '+'] Style des points de la liste pointListe\n * @param {number} [parametres.pointOpacite = 0.8] Opacité des points de la liste pointListe\n * @param {number} [parametres.pointEpaisseur = 2] Épaisseur des points de la liste pointListe\n * @param {boolean?} [parametres.labelsPrincipaux = true] Présence (ou non) des labels numériques principaux\n * @param {boolean?} [parametres.labelsSecondaires = false] Présence (ou non) des labels numériques secondaires\n * @param {array?} [parametres.labelListe = []] Liste de labels à mettre sous l'axe comme, par exemple, [[2.8,'x'],[3.1,'y']]. Les noms se placent en-dessous de l'axe. * @param {number} [parametres.step1 = 1] Pas des labels numériques principaux\n * @param {number} [parametres.step2 = 1] Pas des labels numériques secondaires\n * @param {number} [parametres.labelDistance = (axeHauteur + 10) / context.pixelsParCm] Distance entre les labels et l'axe\n * @param {number} [parametres.labelCustomDistance = (axeHauteur + 10) / context.pixelsParCm] Distance entre les labels de labelListe et l'axe\n * @param {string?} [parametres.labelColor = 'black'] Couleur des labels de la liste labelListe : du type 'blue' ou du type '#f15929'\n * @param {number?} [parametres.labelScale = 1] Echelle des labels\n * @param {string} [parametres.Legende = ''] Légende de l'axe\n * @param {number} [parametres.LegendePosition] Position de la légende\n * @example droiteGraduee({\n        x: 0,\n        y: 3,\n        Min: -2.7,\n        Max: 12 + 0.2,\n        thickSec: true,\n        Unite: 3,\n        thickCouleur: 'red',\n        axeCouleur: 'blue',\n        axeHauteur: 4,\n        labelsPrincipaux: false,\n        labelListe: [[0, 'O'], [1, 'I']],\n        pointListe: [[-1, 'A'], [5, 'B'], [7.2, 'C']],\n        pointTaille: 6,\n        pointCouleur: 'gray',\n        pointStyle: '|',\n        pointEpaisseur: 3\n      })\n // Trace une droite graduée avec différentes options\n * @author Jean-Claude Lhote\n * @return {DroiteGraduee}\n */\n// JSDOC Validee par EE Aout 2022\nexport function droiteGraduee({\n  Unite = 10,\n  Min = 0,\n  Max = 2,\n  x = 0,\n  y = 0,\n  axeEpaisseur = 2,\n  axeCouleur = 'black',\n  axeStyle = '->',\n  axeHauteur = 4,\n  axePosition = 'H',\n  thickEpaisseur = 2,\n  thickCouleur = axeCouleur,\n  thickDistance = 1,\n  thickOffset = 0,\n  thickSecDist = 0.1,\n  thickSec = false,\n  thickTerDist = 0.01,\n  thickTer = false,\n  pointListe = [],\n  labelPointTaille = 10,\n  labelPointLargeur = 20,\n  pointCouleur = 'blue',\n  pointTaille = 4,\n  pointStyle = '+',\n  pointOpacite = 0.8,\n  pointEpaisseur = 2,\n  labelsPrincipaux = true,\n  labelsSecondaires = false,\n  labelColor = 'black',\n  step1 = 1,\n  step2 = 1,\n  labelCustomDistance = (axeHauteur + 10) / context.pixelsParCm,\n  labelDistance = (axeHauteur + 10) / context.pixelsParCm,\n  labelListe = [],\n  // labelColor = 'black',\n  // labelScale = 1,\n  Legende = '',\n  LegendePosition = (Max - Min) * Unite + 1.5,\n}: {\n  Unite?: number\n  Min?: number\n  Max?: number\n  x?: number\n  y?: number\n  axeEpaisseur?: number\n  axeCouleur?: string\n  axeStyle?: string\n  axeHauteur?: number\n  axePosition?: string\n  thickEpaisseur?: number\n  thickCouleur?: string\n  thickDistance?: number\n  thickOffset?: number\n  thickSecDist?: number\n  thickSec?: boolean\n  thickTerDist?: number\n  thickTer?: boolean\n  pointListe?: [number, string][]\n  labelPointTaille?: number\n  labelPointLargeur?: number\n  pointCouleur?: string\n  pointTaille?: number\n  pointStyle?: string\n  pointOpacite?: number\n  pointEpaisseur?: number\n  labelsPrincipaux?: boolean\n  labelsSecondaires?: boolean\n  step1?: number\n  step2?: number\n  labelCustomDistance?: number\n  labelDistance?: number\n  labelListe?: [number, string][]\n  labelColor?: string\n  Legende?: string\n  LegendePosition?: number\n}) {\n  return new DroiteGraduee({\n    Unite,\n    Min,\n    Max,\n    x,\n    y,\n    axeEpaisseur,\n    axeCouleur,\n    axeStyle,\n    axeHauteur,\n    axePosition,\n    thickEpaisseur,\n    thickCouleur,\n    thickDistance,\n    thickOffset,\n    thickSecDist,\n    thickSec,\n    thickTerDist,\n    thickTer,\n    pointListe,\n    labelPointTaille,\n    labelPointLargeur,\n    pointCouleur,\n    pointTaille,\n    pointStyle,\n    pointOpacite,\n    pointEpaisseur,\n    labelsPrincipaux,\n    labelsSecondaires,\n    step1,\n    step2,\n    labelDistance,\n    labelCustomDistance,\n    labelListe,\n    labelColor,\n    Legende,\n    LegendePosition,\n  })\n}\n\n/**\n * Trace un repère orthonormé\n * @param {number} [xmin=-30] Valeur minimale sur l'axe des abscisses\n * @param {number} [ymin=-30] Valeur minimale sur l'axe des ordonnées\n * @param {number} [xmax=30] Valeur maximale sur l'axe des abscisses\n * @param {number} [ymax=30] Valeur maximale sur l'axe des ordonnées\n * @param {number} [thick=0.2] Demi-longueur des tirets de chaque graduation\n * @param {number} [xstep=1] Pas sur l'axe des abscisses\n * @param {number} [ystep=1] Pas sur l'axe des ordonnées\n * @param {number} [epaisseur=2] Epaisseur des deux axes\n * @param {string} [color='black'] Couleur du codage : du type 'blue' ou du type '#f15929'.\n * @param {number} [tailleExtremites=4] Taille des flèches à l'extrémité des axes.\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Juin 2022\nexport class Axes extends ObjetMathalea2D {\n  constructor(\n    xmin = -30,\n    ymin = -30,\n    xmax = 30,\n    ymax = 30,\n    thick = 0.2,\n    xstep = 1,\n    ystep = 1,\n    epaisseur = 2,\n    color = 'black',\n    tailleExtremites = 4,\n  ) {\n    super()\n    this.objets = []\n    let yabscisse\n    ymin > 0 ? (yabscisse = ymin) : (yabscisse = 0)\n    let xordonnee\n    xmin > 0 ? (xordonnee = xmin) : (xordonnee = 0)\n    const abscisse = segment(xmin, yabscisse, xmax, yabscisse, color)\n    abscisse.styleExtremites = '->'\n    abscisse.tailleExtremites = tailleExtremites\n    abscisse.epaisseur = epaisseur\n    const ordonnee = segment(xordonnee, ymin, xordonnee, ymax, color)\n    ordonnee.styleExtremites = '->'\n    ordonnee.epaisseur = epaisseur\n    ordonnee.tailleExtremites = tailleExtremites\n    this.objets.push(abscisse, ordonnee)\n    for (let x = xmin; x < xmax; x = x + xstep) {\n      const s = segment(x, yabscisse - thick, x, yabscisse + thick, color)\n      s.epaisseur = epaisseur\n      this.objets.push(s)\n    }\n    for (let y = ymin; y < ymax; y = y + ystep) {\n      const s = segment(xordonnee - thick, y, xordonnee + thick, y, color)\n      s.epaisseur = epaisseur\n      this.objets.push(s)\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n  // this.commentaire = `Axes(xmin = ${xmin}, ymin = ${ymin}, xmax = ${xmax}, ymax = ${ymax}, thick = ${thick})`\n}\n\n/**\n * Trace un repère orthonormé\n * @param {number} [xmin=-30] Valeur minimale sur l'axe des abscisses\n * @param {number} [ymin=-30] Valeur minimale sur l'axe des ordonnées\n * @param {number} [xmax=30] Valeur maximale sur l'axe des abscisses\n * @param {number} [ymax=30] Valeur maximale sur l'axe des ordonnées\n * @param {number} [thick=0.2] Demi-longueur des tirets de chaque graduation\n * @param {number} [xstep=1] Pas sur l'axe des abscisses\n * @param {number} [ystep=1] Pas sur l'axe des ordonnées\n * @param {number} [epaisseur=2] Epaisseur des deux axes\n * @param {string} [color='black'] Couleur du codage : du type 'blue' ou du type '#f15929'.\n * @example axes()\n * // Trace un repère orthonormé dont les axes des abscisses et des ordonnées ont pour minimum -30, maximum -30, épaisseur 2, avec un pas de 1 et de couleur noire. Le tiret de chaque graduation mesure 0,4.\n * @example axes(-10,-5,20,3,0.25,2,0.5,1,'red')\n * // Trace un repère orthonormé rouge dont les axes des abscisses et des ordonnées ont pour épaisseur 1 et dont le tiret de chaque graduation mesure 0,5.\n * // L'axe des abscisses va de -10 à 20 avec un pas de 2. L'axe des ordonnées va de -5 à 3 avec un pas de 0,5.\n * @return {Axes}\n * @author Rémi Angot\n */\n// JSDOC Validee par EE Juin 2022\nexport function axes(\n  xmin = -30,\n  ymin = -30,\n  xmax = 30,\n  ymax = 30,\n  thick = 0.2,\n  xstep = 1,\n  ystep = 1,\n  epaisseur = 2,\n  color = 'black',\n) {\n  return new Axes(xmin, ymin, xmax, ymax, thick, xstep, ystep, epaisseur, color)\n}\n\n/**\n * Trace une droite verticale graduée\n * @param {number} [ymin=-2] Valeur minimale sur l'axe vertical\n * @param {number} [ymax=5] Valeur maximale sur l'axe vertical\n * @param {number} [thick=0.2] Largeur des tirets de chaque graduation principale\n * @param {number} [ystep=1] Pas sur l'axe des ordonnées\n * @param {number} [epaisseur=2] Epaisseur des deux axes\n * @param {string} [color='black'] Couleur du codage : du type 'blue' ou du type '#f15929'.\n * @param {number} [ytick=2] Nombre de partage entre deux graduations principales\n * @param {string} [titre=''] Titre de l'axe\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {number[]} bordures Coordonnées de la fenêtre d'affichage du genre [-2,-2,5,5]\n * @author Frédéric Piou\n * @class\n */\n// JSDOC Validee par EE Juin 2022\nexport class AxeY extends ObjetMathalea2D {\n  constructor(\n    ymin = -2,\n    ymax = 5,\n    thick = 0.2,\n    ystep = 1,\n    epaisseur = 2,\n    color = 'black',\n    ytick = 2,\n    titre = '',\n  ) {\n    super()\n    this.objets = []\n    if (titre !== '') {\n      this.objets.push(\n        texteParPoint(\n          titre,\n          point(-1 - thick - 0.1, ymax),\n          0,\n          color,\n          1,\n          'milieu',\n          false,\n          1,\n        ),\n      )\n    }\n    const ordonnee = segment(-1, ymin.valueOf(), -1, ymax.valueOf(), color)\n    ordonnee.styleExtremites = '->'\n    ordonnee.epaisseur = epaisseur\n    this.objets.push(ordonnee)\n    for (let y = ymin; y < ymax; y = y + ystep) {\n      const s = segment(-1 - thick, y.valueOf(), -1, y.valueOf(), color)\n      s.epaisseur = epaisseur\n      this.objets.push(s)\n    }\n    for (let y = ymin; y < ymax; y = y + ystep / ytick) {\n      const s = segment(-1 - thick / 2, y.valueOf(), -1, y.valueOf(), color)\n      s.epaisseur = epaisseur\n      this.objets.push(s)\n    }\n    this.bordures = [1000, 1000, -1000, -1000]\n    for (const objet of this.objets) {\n      if (objet.bordures !== undefined) {\n        this.bordures = [\n          Math.min(this.bordures[0], objet.bordures[0]),\n          Math.min(this.bordures[1], objet.bordures[1]),\n          Math.max(this.bordures[2], objet.bordures[2]),\n          Math.max(this.bordures[3], objet.bordures[3]),\n        ]\n      }\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**\n * Trace une droite verticale graduée\n * @param {number} [ymin=-2] Valeur minimale sur l'axe vertical\n * @param {number} [ymax=5] Valeur maximale sur l'axe vertical\n * @param {number} [thick=0.2] Largeur des tirets de chaque graduation principale\n * @param {number} [ystep=1] Pas sur l'axe des ordonnées\n * @param {number} [epaisseur=2] Epaisseur des deux axes\n * @param {string} [color='black'] Couleur du codage : du type 'blue' ou du type '#f15929'.\n * @param {number} [ytick=2] Nombre de partage entre deux graduations principales\n * @param {string} [titre=''] Titre de l'axe\n * @example axeY()\n * // Trace un axe noir vertical gradué de -2 à 5, de 1 en 1, avec une petite graduation entre deux graduations principales (de longueur 0.2 et d'épaisseur 2), et sans titre\n * @example axeY(0,10,0.25,2,1,'red',5,'titre')\n * // Trace un axe rouge vertical gradué de 0 à 10, de 2 en 2, avec quatre petites graduations entre deux graduations principales (de longueur 0.25 et d'épaisseur 1), et avec comme titre de l'axe : titre\n * @author Frédéric Piou\n * @return {AxeY}\n */\n// JSDOC Validee par EE Juin 2022\nexport function axeY(\n  ymin = -2,\n  ymax = 5,\n  thick = 0.2,\n  ystep = 1,\n  epaisseur = 2,\n  color = 'black',\n  ytick = 2,\n  titre = '',\n) {\n  return new AxeY(ymin, ymax, thick, ystep, epaisseur, color, ytick, titre)\n}\n\n/**  Place des labels sur un axe vertical précédemment\n * @param  {number} [ymin = 1] Ordonnée minimale sur l'axe\n * @param  {number} [ymax = 20] Ordonnée maximale sur l'axe\n * @param  {number} [step = 1] Pas entre chaque label\n * @param {string} [color = 'black'] Couleur des labels : du type 'blue' ou du type '#f15929'\n * @param  {number} [pos = -0.6] Décalage entre les labels et l'axe vertical\n * @param  {number} [coeff = 1] Coefficient multiplicatif sur chaque label\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @author Rémi Angot modifié par Frédéric Piou\n * @class\n */\n// JSDOC Validee par EE Septembre 2022\nexport class LabelY extends ObjetMathalea2D {\n  constructor(\n    ymin = 1,\n    ymax = 20,\n    step = 1,\n    color = 'black',\n    pos = -0.6,\n    coeff = 1,\n  ) {\n    super()\n    this.objets = []\n    for (let y = Math.ceil(ymin / coeff); y * coeff <= ymax; y = y + step) {\n      this.objets.push(\n        texteParPoint(\n          stringNombre(y * coeff, 3),\n          point(pos, y),\n          0,\n          color,\n          1,\n          'gauche',\n          true,\n        ),\n      )\n    }\n    const bordures = fixeBordures(this.objets, {\n      rxmin: 0,\n      rxmax: 0,\n      rymin: 0,\n      rymax: 0,\n    })\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**  Place des labels sur un axe vertical précédemment\n * @param  {number} [ymin = 1] Ordonnée minimale sur l'axe\n * @param  {number} [ymax = 20] Ordonnée maximale sur l'axe\n * @param  {number} [step = 1] Pas entre chaque label\n * @param {string} [color = 'black'] Couleur des labels : du type 'blue' ou du type '#f15929'\n * @param  {number} [pos = -0.6] Décalage entre les labels et l'axe vertical\n * @param  {number} [coeff = 1] Coefficient multiplicatif sur chaque label\n * @example labelY()\n * // Note, sur un axe (prédéfini de 1 en 1), des labels noirs, de 0 à 20, de 2 en 2, avec un décalage de -0,6 par rapport à l'axe\n * @example labelY(0, 160, 2, 'red', -2, 20)\n * // Note, sur un axe (prédéfini de 1 en 1), des labels rouges, de 0 à 160, de 40 (2*20) en 40, avec un décalage de -2 par rapport à l'axe.\n * @author Rémi Angot modifié par Frédéric Piou\n * @return {LabelY}\n */\n// JSDOC Validee par EE Septembre 2022\nexport function labelY(\n  ymin = 1,\n  ymax = 20,\n  step = 1,\n  color = 'black',\n  pos = -0.6,\n  coeff = 1,\n) {\n  return new LabelY(ymin, ymax, step, color, pos, coeff)\n}\n\n/**  Trace une grille quadrillée dont le coin en bas à gauche est (xmin, ymin) et celui à droite est au maximum (xmax, ymax), de couleur et opacité choisie, avec un pas choisi et avec ou sans pointillés\n * @param {number} [xmin = -30] Abscisse du coin en bas à gauche de la grille\n * @param {number} [ymin = -30] Ordonnée du coin en bas à gauche de la grille\n * @param {number} [xmax = 30] Abscisse du coin en haut à droite de la grille\n * @param {number} [ymax = 30] Ordonnée du coin en haut à droite de la grille\n * @param {string} [color = 'gray'] Couleur de la grille : du type 'blue' ou du type '#f15929'\n * @param {number} [opacite = 0.4] Opacité de la grille : entre 0 et 1\n * @param {number} [step = 1] Pas de la grille\n * @param {number} [pointilles = 0] Style des pointillés de la grille (entier entre 1 et 5). Si autre chose, pas de pointillés.\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur de la grille. À associer obligatoirement à colorToLatexOrHTML().\n * @property {number} opacite Opacité de la grille : entre 0 et 1\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Aout 2022\nexport class Grille extends ObjetMathalea2D {\n  constructor(\n    xmin = -30,\n    ymin = -30,\n    xmax = 30,\n    ymax = 30,\n    color = 'gray',\n    opacite = 0.4,\n    step = 1,\n    pointilles = 0,\n  ) {\n    super()\n    this.color = colorToLatexOrHTML(color)\n    this.opacite = opacite\n    this.objets = []\n    let x = xmin\n    let nbStep = Math.round((xmax - xmin) / step)\n    for (let i = 0; i <= nbStep; i++) {\n      const s = segment(x, ymin, x, ymax, color)\n      x += step\n      s.opacite = this.opacite\n      if (pointilles) {\n        s.pointilles = 5\n      }\n      this.objets.push(s)\n    }\n    let y = ymin\n    nbStep = Math.round((ymax - ymin) / step)\n    for (let i = 0; i <= nbStep; i++) {\n      const s = segment(xmin, y, xmax, y, color)\n      y += step\n      s.opacite = this.opacite\n      if (pointilles) {\n        s.pointilles = 5\n      }\n      this.objets.push(s)\n    }\n    this.bordures = [xmin, ymin, xmax, ymax]\n  }\n\n  // this.commentaire = `Grille(xmin = ${xmin}, ymin = ${ymin}, xmax = ${xmax}, ymax = ${ymax}, color = ${this.color}, opacite = ${this.opacite}, pas = ${step})`\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (objet.svgml) {\n        code += '\\n\\t' + objet.svgml(coeff, amp)\n      } else {\n        code += '\\n\\t' + objet.svg(coeff)\n      }\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.tikzml === 'undefined') {\n        code += '\\n\\t' + objet.tikz()\n      } else {\n        code += '\\n\\t' + objet.tikzml(amp)\n      }\n    }\n    return code\n  }\n}\n\n/**  Trace une grille quadrillée dont le coin en bas à gauche est (xmin, ymin) et celui à droite est au maximum (xmax, ymax), de couleur et opacité choisie, avec un pas choisi et avec ou sans pointillés\n * @param {number} [xmin = -30] Abscisse du coin en bas à gauche de la grille\n * @param {number} [ymin = -30] Ordonnée du coin en bas à gauche de la grille\n * @param {number} [xmax = 30] Abscisse du coin en haut à droite de la grille\n * @param {number} [ymax = 30] Ordonnée du coin en haut à droite de la grille\n * @param {string} [color = 'gray'] Couleur de la grille : du type 'blue' ou du type '#f15929'\n * @param {number} [opacite = 0.4] Opacité de la grille : entre 0 et 1\n * @param {number} [step = 1] Pas de la grille\n * @param {number} [pointilles = 0] Style des pointillés de la grille (entier entre 1 et 5). Si autre chose, pas de pointillés.\n * @example grid = grille() // Trace une grille avec toutes les options par défaut\n * @example grid = grille(-3, -3, 27, 18, 'red', 0.2, 0.5, true) // Trace une grille avec toutes les options différentes de celles par défaut\n * @author Rémi Angot\n * @return {Grille}\n */\n// JSDOC Validee par EE Aout 2022\nexport function grille(\n  xmin = -30,\n  ymin = -30,\n  xmax = 30,\n  ymax = 30,\n  color = 'gray',\n  opacite = 0.4,\n  step = 1,\n  pointilles = 0,\n) {\n  return new Grille(xmin, ymin, xmax, ymax, color, opacite, step, pointilles)\n}\n\n/**  Trace des parallèles à l'axe des abscisses\n * @param {number} [xmin = -30] Abscisse du coin en bas à gauche de ces parallèles\n * @param {number} [ymin = -30] Ordonnée du coin en bas à gauche de ces parallèles\n * @param {number} [xmax = 30] Abscisse du coin en haut à droite de ces parallèles\n * @param {number} [ymax = 30] Ordonnée du coin en haut à droite de ces parallèles\n * @param {string} [color = 'gray'] Couleur de ces parallèles : du type 'blue' ou du type '#f15929'\n * @param {number} [opacite = 0.4] Opacité de ces parallèles : entre 0 et 1\n * @param {number} [step = 1] Pas de ces parallèles\n * @param {number} [pointilles = 0] Style des pointillés de ces parallèles (entier entre 1 et 5). Si autre chose, pas de pointillés.\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur de ces parallèles. À associer obligatoirement à colorToLatexOrHTML().\n * @property {number} opacite Opacité de ces parallèles : entre 0 et 1\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Aout 2022\nexport class LignesHorizontales extends ObjetMathalea2D {\n  constructor(\n    xmin = -30,\n    ymin = -30,\n    xmax = 30,\n    ymax = 30,\n    color = 'gray',\n    opacite = 0.4,\n    step = 1,\n    pointilles = '',\n  ) {\n    super()\n    this.color = colorToLatexOrHTML(color)\n    this.opacite = opacite\n    this.objets = []\n    for (let i = ymin; i <= ymax; i += step) {\n      const s = segment(xmin, i, xmax, i, color)\n      s.opacite = this.opacite\n      if (pointilles) {\n        s.pointilles = 5\n      }\n      this.objets.push(s)\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**  Trace des parallèles à l'axe des abscisses\n * @param {number} [xmin = -30] Abscisse du coin en bas à gauche de ces parallèles\n * @param {number} [ymin = -30] Ordonnée du coin en bas à gauche de ces parallèles\n * @param {number} [xmax = 30] Abscisse du coin en haut à droite de ces parallèles\n * @param {number} [ymax = 30] Ordonnée du coin en haut à droite de ces parallèles\n * @param {string} [color = 'gray'] Couleur de ces parallèles : du type 'blue' ou du type '#f15929'\n * @param {number} [opacite = 0.4] Opacité de ces parallèles : entre 0 et 1\n * @param {number} [step = 1] Pas de ces parallèles\n * @param {number} [pointilles = 0] Style des pointillés de ces parallèles (entier entre 1 et 5). Si autre chose, pas de pointillés.\n * @example grid = lignesHorizontales() // Trace des parallèles à l'axe des abscisses avec toutes les options par défaut\n * @example grid = lignesHorizontales(-3, -3, 27, 18, 'red', 0.2, 0.5, true) // Trace des parallèles à l'axe des abscisses avec toutes les options différentes de celles par défaut\n * @author Rémi Angot\n * @return {LignesHorizontales}\n */\n// JSDOC Validee par EE Aout 2022\nexport function lignesHorizontales(\n  xmin = -30,\n  ymin = -30,\n  xmax = 30,\n  ymax = 30,\n  color = 'gray',\n  opacite = 0.4,\n  step = 1,\n  pointilles = '',\n) {\n  return new LignesHorizontales(\n    xmin,\n    ymin,\n    xmax,\n    ymax,\n    color,\n    opacite,\n    step,\n    pointilles,\n  )\n}\n\n/**  Trace des verticales à l'axe des ordonnées\n * @param {number} [xmin = -30] Abscisse du coin en bas à gauche de ces parallèles\n * @param {number} [ymin = -30] Ordonnée du coin en bas à gauche de ces parallèles\n * @param {number} [xmax = 30] Abscisse du coin en haut à droite de ces parallèles\n * @param {number} [ymax = 30] Ordonnée du coin en haut à droite de ces parallèles\n * @param {string} [color = 'gray'] Couleur de ces parallèles : du type 'blue' ou du type '#f15929'\n * @param {number} [opacite = 0.4] Opacité de ces parallèles : entre 0 et 1\n * @param {number} [step = 1] Pas de ces parallèles\n * @param {number} [pointilles = 0] Style des pointillés de ces parallèles (entier entre 1 et 5). Si autre chose, pas de pointillés.\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur de ces parallèles. À associer obligatoirement à colorToLatexOrHTML().\n * @property {number} opacite Opacité de ces parallèles : entre 0 et 1\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Aout 2022\nexport class LignesVerticales extends ObjetMathalea2D {\n  constructor(\n    xmin = -30,\n    ymin = -30,\n    xmax = 30,\n    ymax = 30,\n    color = 'gray',\n    opacite = 0.4,\n    step = 1,\n    pointilles = '',\n  ) {\n    super()\n    this.color = colorToLatexOrHTML(color)\n    this.opacite = opacite\n    this.objets = []\n    for (let i = xmin; i <= xmax; i = i + step) {\n      const s = segment(i, ymin, i, ymax, color)\n      s.opacite = this.opacite\n      if (pointilles) {\n        s.pointilles = 5\n      }\n      this.objets.push(s)\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**\n * LignesVerticales(xmin,ymin,xmax,ymax,color,opacite,pas)\n *\n * @author Rémi Angot\n */\n/**  Trace des parallèles à l'axe des ordonnées\n * @param {number} [xmin = -30] Abscisse du coin en bas à gauche de ces parallèles\n * @param {number} [ymin = -30] Ordonnée du coin en bas à gauche de ces parallèles\n * @param {number} [xmax = 30] Abscisse du coin en haut à droite de ces parallèles\n * @param {number} [ymax = 30] Ordonnée du coin en haut à droite de ces parallèles\n * @param {string} [color = 'gray'] Couleur de ces parallèles : du type 'blue' ou du type '#f15929'\n * @param {number} [opacite = 0.4] Opacité de ces parallèles : entre 0 et 1\n * @param {number} [step = 1] Pas de ces parallèles\n * @param {number} [pointilles = 0] Style des pointillés de ces parallèles (entier entre 1 et 5). Si autre chose, pas de pointillés.\n * @example grid = lignesHorizontales() // Trace des parallèles à l'axe des ordonnées avec toutes les options par défaut\n * @example grid = lignesHorizontales(-3, -3, 27, 18, 'red', 0.2, 0.5, true) // Trace des parallèles à l'axe des ordonnées avec toutes les options différentes de celles par défaut\n * @author Rémi Angot\n * @return {LignesVerticales}\n */\n// JSDOC Validee par EE Aout 2022\nexport function lignesVerticales(\n  xmin = -30,\n  ymin = -30,\n  xmax = 30,\n  ymax = 30,\n  color = 'gray',\n  opacite = 0.4,\n  step = 1,\n  pointilles = '',\n) {\n  return new LignesVerticales(\n    xmin,\n    ymin,\n    xmax,\n    ymax,\n    color,\n    opacite,\n    step,\n    pointilles,\n  )\n}\n\nexport class Seyes extends ObjetMathalea2D {\n  constructor(\n    xmin = 0,\n    ymin = 0,\n    xmax = 15,\n    ymax = 15,\n    opacite1 = 0.5,\n    opacite2 = 0.2,\n  ) {\n    super()\n    this.objets = []\n    for (let y = ymin; y <= ymax; y = y + 0.25) {\n      if (y % 1 !== 0) {\n        const d = segment(xmin, y, xmax, y, 'red')\n        d.opacite = opacite2\n        this.objets.push(d)\n      }\n    }\n    this.objets.push(grille(xmin, ymin, xmax, ymax, 'blue', opacite1, 1))\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**\n * Fais un quadrillage avec des grands carreaux.\n *\n * Pour une sortie LaTeX, il faut penser à ajouter scale = .8\n *\n * @param {number} xmin\n * @param {number} ymin\n * @param {number} xmax\n * @param {number} ymax\n * @param {number?} opacite1=0.5\n * @param {number?} opacite2=0.2\n * @author Rémi Angot\n */\nexport function seyes(\n  xmin: number,\n  ymin: number,\n  xmax: number,\n  ymax: number,\n  opacite1 = 0.5,\n  opacite2 = 0.2,\n) {\n  return new Seyes(xmin, ymin, xmax, ymax, opacite1, opacite2)\n}\n\n/**\n * @param {number?} xmin=-10\n * @param {number?} ymin=10\n * @param {number?} xmax=-10\n * @param {number?} ymax=10\n * @param {number?} xstep=1\n * @param {number?} ystep=1\n * @param {'quad'|'hexa'|'equi'?} type='quad'\n * @param {string?} pointColor='black'\n * @param {number?} pointRayon=0.05\n * @param {number?} opacite=1\n * @param {number?} opaciteDeRemplissage=1\n * @constructor\n * @author Jean-Claude Lhote\n */\nexport class PapierPointe extends ObjetMathalea2D {\n  plots: Plot[]\n  listeCoords: [number, number][]\n  constructor({\n    xmin = -10,\n    xmax = 10,\n    ymin = -10,\n    ymax = 10,\n    xstep = 1,\n    ystep = 1,\n    type = 'quad',\n    pointColor = 'black',\n    pointRayon = 0.05,\n    opacite = 1,\n    opaciteDeRemplissage = 1,\n  }) {\n    super()\n    this.listeCoords = []\n    this.plots = []\n    let xstep1, xstep2, ystep1, stepper\n    switch (type) {\n      case 'quad':\n        for (let x = xmin; x <= xmax; x += xstep) {\n          for (let y = ymin; y <= ymax; y += ystep) {\n            this.plots.push(\n              plot(x, y, {\n                rayon: pointRayon,\n                couleur: pointColor,\n                opacite,\n                couleurDeRemplissage: 'black',\n                opaciteDeRemplissage,\n              }),\n            )\n            this.listeCoords.push([x, y])\n          }\n        }\n        break\n      case 'hexa':\n        stepper = false\n        ystep1 = Math.min(xstep, ystep)\n        xstep1 = 0.866 * ystep1\n        xstep2 = 1.732 * ystep1\n        for (let x = xmin; x <= xmax; x += xstep2) {\n          for (let y = ymin; y <= ymax; y += 1.5 * ystep1) {\n            stepper = !stepper\n            if (stepper) {\n              this.plots.push(\n                plot(x, y, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.plots.push(\n                plot(x + xstep1, y + ystep1 / 2, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.plots.push(\n                plot(x + xstep1, y + ystep1 * 1.5, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.listeCoords.push(\n                [x, y],\n                [x + xstep1, y + ystep1 / 2],\n                [x + xstep1, y + ystep1 * 1.5],\n              )\n            } else {\n              this.plots.push(\n                plot(x, y + ystep1 / 2, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.listeCoords.push([x, y + ystep1 / 2])\n            }\n          }\n          stepper = !stepper\n        }\n        break\n      case 'equi':\n        stepper = false\n        ystep1 = Math.min(xstep, ystep)\n        xstep1 = 0.866 * ystep1\n        xstep2 = 1.732 * ystep1\n        for (let x = xmin; x <= xmax; x = x + xstep2) {\n          for (let y = ymin; y <= ymax; y = y + 1.5 * ystep1) {\n            stepper = !stepper\n            if (stepper) {\n              this.plots.push(\n                plot(x, y, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.plots.push(\n                plot(x, y + ystep1, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.plots.push(\n                plot(x + xstep1, y + ystep1 / 2, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.plots.push(\n                plot(x + xstep1, y + ystep1 * 1.5, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.listeCoords.push(\n                [x, y],\n                [x, y + ystep1],\n                [x + xstep1, y + ystep1 / 2],\n                [x + xstep1, y + ystep1 * 1.5],\n              )\n            } else {\n              this.plots.push(\n                plot(x + xstep1, y + ystep1, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.plots.push(\n                plot(x, y + ystep1 / 2, {\n                  rayon: pointRayon,\n                  couleur: pointColor,\n                  opacite,\n                  couleurDeRemplissage: context.isHtml ? 'none' : '',\n                  opaciteDeRemplissage,\n                }),\n              )\n              this.listeCoords.push(\n                [x + xstep1, y + ystep1],\n                [x, y + ystep1 / 2],\n              )\n            }\n          }\n          stepper = !stepper\n        }\n        break\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    for (const objet of this.plots) {\n      code += objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz = () => {\n    let code = ''\n    for (const objet of this.plots) {\n      code += objet.tikz()\n    }\n    return code\n  }\n}\n\nexport function papierPointe({\n  xmin = -10,\n  xmax = 10,\n  ymin = -10,\n  ymax = 10,\n  xstep = 1,\n  ystep = 1,\n  type = 'quad',\n  pointColor = 'black',\n  pointRayon = 0.05,\n  opacite = 0.4,\n  opaciteDeRemplissage = 0.4,\n}) {\n  return new PapierPointe({\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    xstep,\n    ystep,\n    type,\n    pointColor,\n    pointRayon,\n    opacite,\n    opaciteDeRemplissage,\n  })\n}\n\n/**\n * repere({xUnite, yUnite, xMin, xMax, yMin, yMax, axeX, axeY, axesEpaisseur, axesCouleur, axeXStyle, axeYStyle, thickEpaisseur,\n * thickHauteur, thickCouleur, xThickDistance, xThickListe, xThickMin, xThickMax, yThickDistance, yThickListe,\n * yThickMin, yThickMax, xLabelDistance, xLabelListe, xLabelMin, xLabelMax, yLabelDistance, yLabelListe,\n * yLabelMin, yLabelMax, xLegende,xLegendePosition, yLegende, yLegendePosition, grille, grilleDistance,\n * grilleCouleur,grilleOpacite, grilleEpaisseur, grilleSecondaire, grilleSecondaireDistance, grilleSecondaireCouleur,\n * grilleSecondaireOpacite, grilleSecondaireEpaisseur, grilleX, grilleXListe, grilleXDistance, grilleXMin, grilleXMax,\n * grilleXCouleur, grilleXOpacite, grilleY, grilleYListe, grilleYDistance, grilleYMin, grilleYMax, grilleYCouleur,\n * grilleYOpacite, grilleSecondaireX, grilleSecondaireXListe, grilleSecondaireXDistance, grilleSecondaireXMin, grilleSecondaireXMax,\n * grilleSecondaireXCouleur, grilleSecondaireXOpacite, grilleSecondaireY, grilleSecondaireYListe, grilleSecondaireYDistance,\n * grilleSecondaireYMin, grilleSecondaireYMax, grilleSecondaireYCouleur, grilleSecondaireYOpacite})\n *\n * repere() trace un repère classique. De nombreux paramètres permettent d'en modifier l'aspect\n *\n * @author Rémi Angot\n * @param {object} options\n * @param {number}  options.xUnite = 1,\n * @param {number}  options.yUnite = 1,\n * @param {number}  options.xMin = -10,\n * @param {number}  options.xMax = 10,\n * @param {number}  options.yMin = -10,\n * @param {number}  options.yMax = 10,\n * @param {boolean?}  options.axeXisVisible = true,\n * @param {boolean?}  options.axeYisVisible = true,\n * @param {number}  options.axesEpaisseur = 2,\n * @param {string}  options.axesCouleur = 'black',\n * @param {string}  options.axeXStyle = '->',\n * @param {string}  options.axeYStyle = '->',\n * @param {number}  options.thickEpaisseur = 2,\n * @param {number}  options.thickHauteur = 0.2,\n * @param {string}  options.thickCouleur = axesCouleur,\n * @param {number}  options.xThickDistance = 1,\n * @param {number[]}  options.xThickListe = false,\n * @param {number}  options.xThickMin = xMin + xThickDistance,\n * @param {number}  options.xThickMax = xMax - xThickDistance,\n * @param {number}  options.yThickDistance = 1,\n * @param {number[]}  options.yThickListe = false,\n * @param {number}  options.yThickMin = yMin + yThickDistance,\n * @param {number}  options.yThickMax = yMax - yThickDistance,\n * @param {number}  options.xLabelDistance = xThickDistance,\n * @param {number[]}  options.xLabelListe = false,\n * @param {number}  options.xLabelMin = xThickMin,\n * @param {number}  options.xLabelMax = xThickMax,\n * @param {number}  options.yLabelDistance = yThickDistance,\n * @param {number[]}  options.yLabelListe = false,\n * @param {number}  options.yLabelMin = yThickMin,\n * @param {number}  options.yLabelMax = yThickMax,\n * @param {number}  options.precisionLabelX = 1,\n * @param {number}  options.precisionLabelY = 1,\n * @param {number}  options.xLabelEcart = 0.5,\n * @param {number}  options.yLabelEcart = 0.5,\n * @param {string}  options.xLegende = '',\n * @param {number}  options.xLegendePosition = [],\n * @param {string}  options.yLegende = '',\n * @param {number}  options.yLegendePosition = [],\n * @param {boolean?}  options.grille = true,\n * @param {number}  options.grilleDistance = false,\n * @param {string}  options.grilleCouleur = 'black',\n * @param {number}  options.grilleOpacite = 0.5,\n * @param {number}  options.grilleEpaisseur = 1,\n * @param {boolean?}  options.grilleSecondaire = false,\n * @param {number}  options.grilleSecondaireDistance = false,\n * @param {string}  options.grilleSecondaireCouleur = 'gray',\n * @param {number}  options.grilleSecondaireOpacite = 0.3,\n * @param {number}  options.grilleSecondaireEpaisseur = 1,\n * @param {boolean?}  options.grilleX = grille,\n * @param {number[]}  options.grilleXListe = false,\n * @param {number}  options.grilleXDistance = grilleDistance,\n * @param {number}  options.grilleXMin = false,\n * @param {number}  options.grilleXMax = false,\n * @param {string}  options.grilleXCouleur = grilleCouleur,\n * @param {number}  options.grilleXOpacite = grilleOpacite,\n * @param {boolean?}  options.grilleY = grille,\n * @param {number[]}  options.grilleYListe = false,\n * @param {number}  options.grilleYDistance = grilleDistance,\n * @param {number}  options.grilleYMin = false,\n * @param {number}  options.grilleYMax = false,\n * @param {string}  options.grilleYCouleur = grilleCouleur,\n * @param {number}  options.grilleYOpacite = grilleOpacite,\n * @param {boolean?}  options.grilleSecondaireX = grilleSecondaire,\n * @param {number[]}  options.grilleSecondaireXListe = false,\n * @param {number}  options.grilleSecondaireXDistance = grilleSecondaireDistance,\n * @param {number}  options.grilleSecondaireXMin = false,\n * @param {number}  options.grilleSecondaireXMax = false,\n * @param {string}  options.grilleSecondaireXCouleur = grilleSecondaireCouleur,\n * @param {number}  options.grilleSecondaireXOpacite = grilleSecondaireOpacite,\n * @param {boolean?}  options.grilleSecondaireY = grilleSecondaire,\n * @param {number[]}  options.grilleSecondaireYListe = false,\n * @param {number}  options.grilleSecondaireYDistance = grilleSecondaireDistance,\n * @param {number}  options.grilleSecondaireYMin = false,\n * @param {number}  options.grilleSecondaireYMax = false,\n * @param {string}  options.grilleSecondaireYCouleur = grilleSecondaireCouleur,\n * @param {number}  options.grilleSecondaireYOpacite = grilleSecondaireOpacite\n */\nexport class Repere extends ObjetMathalea2D {\n  xUnite: number\n  yUnite: number\n  xMin: number\n  xMax: number\n  yMin: number\n  yMax: number\n  grilleXMin: number\n  grilleXMax: number\n  grilleYMin: number\n  grilleYMax: number\n  objets: ObjetMathalea2D[]\n\n  constructor({\n    xUnite = 1,\n    yUnite = 1,\n    xMin = -10,\n    xMax = 10,\n    yMin = -10,\n    yMax = 10,\n    axeXisVisible = true,\n    axeYisVisible = true,\n    axesEpaisseur = 1.2,\n    axesCouleur = 'black',\n    axeXStyle = '->',\n    axeYStyle = '->',\n    thickEpaisseur = 1.2,\n    thickHauteur = 0.13,\n    thickCouleur = axesCouleur,\n    xThickDistance = 1,\n    xThickListe = [],\n    xThickMin = xMin + xThickDistance,\n    xThickMax = xMax - xThickDistance,\n    yThickDistance = 1,\n    yThickListe = [],\n    yThickMin = yMin + yThickDistance,\n    yThickMax = yMax - yThickDistance,\n    xLabelDistance = xThickDistance,\n    xLabelListe = [],\n    xLabelMin = xThickMin,\n    xLabelMax = xThickMax,\n    yLabelDistance = yThickDistance,\n    yLabelListe = [],\n    yLabelMin = yThickMin,\n    yLabelMax = yThickMax,\n    precisionLabelX = 1,\n    precisionLabelY = 1,\n    xLabelEcart = 0.5,\n    yLabelEcart = 0.5,\n    xLegende = '',\n    xLegendePosition = [],\n    yLegende = '',\n    yLegendePosition = [],\n    grille = true,\n    grilleDistance = 1,\n    grilleCouleur = 'black',\n    grilleOpacite = 0.4,\n    grilleEpaisseur = 1,\n    grilleSecondaire = false,\n    grilleSecondaireDistance = 1,\n    grilleSecondaireCouleur = 'gray',\n    grilleSecondaireOpacite = 0.3,\n    grilleSecondaireEpaisseur = 1,\n    grilleX = grille,\n    grilleXListe = [],\n    grilleXDistance = grilleDistance,\n    grilleXMin = xMin,\n    grilleXMax = xMax,\n    grilleXCouleur = grilleCouleur,\n    grilleXOpacite = grilleOpacite,\n    grilleY = grille,\n    grilleYListe = [],\n    grilleYDistance = grilleDistance,\n    grilleYMin = yMin,\n    grilleYMax = yMax,\n    grilleYCouleur = grilleCouleur,\n    grilleYOpacite = grilleOpacite,\n    grilleSecondaireX = grilleSecondaire,\n    grilleSecondaireXListe = [],\n    grilleSecondaireXDistance = grilleSecondaireDistance,\n    grilleSecondaireXMin = xMin,\n    grilleSecondaireXMax = xMax,\n    grilleSecondaireXCouleur = grilleSecondaireCouleur,\n    grilleSecondaireXOpacite = grilleSecondaireOpacite,\n    grilleSecondaireY = grilleSecondaire,\n    grilleSecondaireYListe = [],\n    grilleSecondaireYDistance = grilleSecondaireDistance,\n    grilleSecondaireYMin = yMin,\n    grilleSecondaireYMax = yMax,\n    grilleSecondaireYCouleur = grilleSecondaireCouleur,\n    grilleSecondaireYOpacite = grilleSecondaireOpacite,\n  }: {\n    xUnite?: number\n    yUnite?: number\n    xMin?: number\n    xMax?: number\n    yMin?: number\n    yMax?: number\n    axeXisVisible?: boolean\n    axeYisVisible?: boolean\n    axesEpaisseur?: number\n    axesCouleur?: string\n    axeXStyle?: string\n    axeYStyle?: string\n    thickEpaisseur?: number\n    thickHauteur?: number\n    thickCouleur?: string\n    xThickDistance?: number\n    xThickListe?: number[] | boolean\n    xThickMin?: number\n    xThickMax?: number\n    yThickDistance?: number\n    yThickListe?: number[] | boolean\n    yThickMin?: number\n    yThickMax?: number\n    xLabelDistance?: number\n    xLabelListe?: boolean | (number | { valeur: number; texte: string })[]\n    xLabelMin?: number\n    xLabelMax?: number\n    yLabelDistance?: number\n    yLabelListe?: boolean | (number | { valeur: number; texte: string })[]\n    yLabelMin?: number\n    yLabelMax?: number\n    precisionLabelX?: number\n    precisionLabelY?: number\n    xLabelEcart?: number\n    yLabelEcart?: number\n    xLegende?: string\n    xLegendePosition?: number[]\n    yLegende?: string\n    yLegendePosition?: number[]\n    grille?: boolean | 'pointilles'\n    grilleDistance?: number\n    grilleCouleur?: string\n    grilleOpacite?: number\n    grilleEpaisseur?: number\n    grilleSecondaire?: boolean\n    grilleSecondaireDistance?: number\n    grilleSecondaireCouleur?: string\n    grilleSecondaireOpacite?: number\n    grilleSecondaireEpaisseur?: number\n    grilleX?: boolean | 'pointilles'\n    grilleXListe?: number[]\n    grilleXDistance?: number\n    grilleXMin?: number\n    grilleXMax?: number\n    grilleXCouleur?: string\n    grilleXOpacite?: number\n    grilleY?: boolean | 'pointilles'\n    grilleYListe?: number[]\n    grilleYDistance?: number\n    grilleYMin?: number\n    grilleYMax?: number\n    grilleYCouleur?: string\n    grilleYOpacite?: number\n    grilleSecondaireX?: boolean | 'pointilles'\n    grilleSecondaireXListe?: number[]\n    grilleSecondaireXDistance?: number\n    grilleSecondaireXMin?: number\n    grilleSecondaireXMax?: number\n    grilleSecondaireXCouleur?: string\n    grilleSecondaireXOpacite?: number\n    grilleSecondaireY?: boolean | 'pointilles'\n    grilleSecondaireYListe?: number[]\n    grilleSecondaireYDistance?: number\n    grilleSecondaireYMin?: number\n    grilleSecondaireYMax?: number\n    grilleSecondaireYCouleur?: string\n    grilleSecondaireYOpacite?: number\n  }) {\n    super()\n\n    // Les propriétés exportables\n    this.xUnite = xUnite\n    this.yUnite = yUnite\n    this.xMin = xMin\n    this.xMax = xMax\n    this.yMin = yMin\n    this.yMax = yMax\n    this.grilleXMin = grilleXMin ?? xMin\n    this.grilleXMax = grilleXMax ?? xMax\n    this.grilleYMin = grilleYMin ?? yMin\n    this.grilleYMax = grilleYMax ?? yMax\n\n    if (thickHauteur === 0) {\n      xThickListe = false\n      yThickListe = false\n    }\n    this.objets = []\n    // LES AXES\n    const ordonneeAxe = Math.max(0, yMin)\n    if (xLegendePosition.length === 0) {\n      xLegendePosition = [xMax * xUnite + 0.5, 0.5 + ordonneeAxe]\n    }\n    const axeX = segment(\n      xMin * xUnite,\n      ordonneeAxe * yUnite,\n      xMax * xUnite,\n      ordonneeAxe * yUnite,\n      axesCouleur,\n    )\n    axeX.epaisseur = axesEpaisseur\n    axeX.styleExtremites = axeXStyle\n    const abscisseAxe = Math.max(0, xMin)\n    if (yLegendePosition.length === 0) {\n      yLegendePosition = [0.5 + abscisseAxe, yMax * yUnite + 0.5]\n    }\n    const axeY = segment(\n      abscisseAxe * xUnite,\n      yMin * yUnite,\n      abscisseAxe * xUnite,\n      yMax * yUnite,\n      axesCouleur,\n    )\n    axeY.epaisseur = axesEpaisseur\n    axeY.styleExtremites = axeYStyle\n    if (axeXisVisible) this.objets.push(axeX)\n    if (axeYisVisible) this.objets.push(axeY)\n    // Cache les objets intermédiaires pour ne pas les afficher en double dans mathalea2d.html\n    // axeX.isVisible = false\n    // axeY.isVisible = false\n    // GRILLE PRINCIPALE\n\n    // Les traits horizontaux\n    if (grilleY) {\n      if (grilleYListe.length === 0) {\n        // Ceux qui ne sont pas définis reprennent les valeurs de thick\n        if (typeof grilleYMin !== 'number') {\n          grilleYMin = yThickMin\n        }\n        if (typeof grilleYMax !== 'number') {\n          grilleYMax = yThickMax\n        }\n        if (!grilleYDistance) {\n          grilleYDistance = yThickDistance\n        }\n        // On créé la liste avec ces valeurs\n        grilleYListe = []\n        if (grilleYMin < 0 && grilleYMax > 0) {\n          grilleYListe.push(0)\n          for (\n            let y = grilleYDistance / yUnite;\n            y < Math.max(-grilleYMin, grilleYMax);\n            y += grilleYDistance / yUnite\n          ) {\n            if (y <= grilleYMax) grilleYListe.push(y)\n            if (y <= -grilleYMin) grilleYListe.push(-y)\n          }\n        } else if (grilleYMin >= 0 && grilleYMax > 0) {\n          for (\n            let y = grilleYMin;\n            y <= grilleYMax;\n            y += grilleYDistance / yUnite\n          ) {\n            grilleYListe.push(y)\n          }\n        } else if (grilleYMin < 0 && grilleYMax <= 0) {\n          for (\n            let y = grilleYMax;\n            y >= grilleYMin;\n            y -= grilleYDistance / yUnite\n          ) {\n            grilleYListe.push(y)\n          }\n        }\n      }\n      for (const y of grilleYListe) {\n        if (y !== 0 || !axeXisVisible) {\n          const traitH = segment(\n            xMin * xUnite,\n            y * yUnite,\n            xMax * xUnite,\n            y * yUnite,\n            grilleYCouleur,\n          )\n          //  traitH.isVisible = false // Pourquoi demander la création de ces traits si c'est pour les rendre invisibles ?\n          traitH.opacite = grilleYOpacite\n          traitH.epaisseur = grilleEpaisseur\n          if (grilleY === 'pointilles') {\n            traitH.pointilles = 5\n          }\n          this.objets.push(traitH)\n        }\n      }\n    }\n    // Les traits verticaux\n    if (grilleX) {\n      if (grilleXListe.length === 0) {\n        // Ceux qui ne sont pas définis reprennent les valeurs de thick\n        if (typeof grilleXMin !== 'number') {\n          grilleXMin = xThickMin\n        }\n        if (typeof grilleXMax !== 'number') {\n          grilleXMax = xThickMax\n        }\n        if (typeof grilleXDistance !== 'number') {\n          grilleXDistance = xThickDistance\n        }\n        // On créé la liste avec ces valeurs\n        grilleXListe = []\n        if (grilleXMin < 0 && grilleXMax > 0) {\n          grilleXListe.push(0)\n          for (\n            let x = grilleXDistance / xUnite;\n            x < Math.max(-grilleXMin, grilleXMax);\n            x += grilleXDistance / xUnite\n          ) {\n            if (x <= grilleXMax) grilleXListe.push(x)\n            if (x <= -grilleXMin) grilleXListe.push(-x)\n          }\n        } else if (grilleXMin >= 0 && grilleXMax > 0) {\n          for (\n            let x = grilleXMin;\n            x <= grilleXMax;\n            x += grilleXDistance / xUnite\n          ) {\n            grilleXListe.push(x)\n          }\n        } else if (grilleXMin < 0 && grilleXMax <= 0) {\n          for (\n            let x = grilleXMax;\n            x >= grilleXMin;\n            x -= grilleXDistance / xUnite\n          ) {\n            grilleXListe.push(x)\n          }\n        }\n      }\n      for (const x of grilleXListe) {\n        if (x !== 0 || !axeYisVisible) {\n          const traitV = segment(\n            x * xUnite,\n            (this.grilleYMin ? this.grilleYMin : yMin) * yUnite,\n            x * xUnite,\n            (this.grilleYMax ? this.grilleYMax : yMax) * yUnite,\n            grilleXCouleur,\n          )\n          //  traitV.isVisible = false\n          traitV.opacite = grilleXOpacite\n          traitV.epaisseur = grilleEpaisseur\n          if (grilleX === 'pointilles') {\n            traitV.pointilles = 5\n          }\n          this.objets.push(traitV)\n        }\n      }\n    }\n\n    // GRILLE SECONDAIRE\n\n    // Les traits horizontaux\n    if (grilleSecondaireY) {\n      if (grilleSecondaireYListe.length === 0) {\n        // Ceux qui ne sont pas définis reprennent les valeurs de thick\n        if (typeof grilleSecondaireYMin !== 'number') {\n          grilleSecondaireYMin = yThickMin\n        }\n        if (typeof grilleSecondaireYMax !== 'number') {\n          grilleSecondaireYMax = yThickMax\n        }\n        if (typeof grilleSecondaireYDistance !== 'number') {\n          grilleSecondaireYDistance = yThickDistance / 2\n        }\n        // On créé la liste avec ces valeurs\n        grilleSecondaireYListe = []\n        if (grilleSecondaireYMin < 0 && grilleSecondaireYMax > 0) {\n          grilleSecondaireYListe.push(0)\n          for (\n            let y = grilleSecondaireYDistance / yUnite;\n            y < Math.max(-grilleSecondaireYMin, grilleSecondaireYMax);\n            y += grilleSecondaireYDistance / yUnite\n          ) {\n            if (y <= grilleSecondaireYMax) grilleSecondaireYListe.push(y)\n            if (y <= -grilleSecondaireYMin) grilleSecondaireYListe.push(-y)\n          }\n        } else if (grilleSecondaireYMin >= 0 && grilleSecondaireYMax > 0) {\n          for (\n            let y = grilleSecondaireYMin;\n            y <= grilleSecondaireYMax;\n            y += grilleSecondaireYDistance / yUnite\n          ) {\n            grilleSecondaireYListe.push(y)\n          }\n        } else if (grilleSecondaireYMin < 0 && grilleSecondaireYMax <= 0) {\n          for (\n            let y = grilleSecondaireYMax;\n            y >= grilleSecondaireYMin;\n            y -= grilleSecondaireYDistance / yUnite\n          ) {\n            grilleSecondaireYListe.push(y)\n          }\n        }\n      }\n      for (const y of grilleSecondaireYListe) {\n        const traitH = segment(\n          (grilleSecondaireXMin || xMin) * xUnite,\n          y * yUnite,\n          (grilleSecondaireXMax || xMax) * xUnite,\n          y * yUnite,\n          grilleSecondaireYCouleur,\n        )\n        // traitH.isVisible = false\n        traitH.opacite = grilleSecondaireYOpacite\n        traitH.epaisseur = grilleSecondaireEpaisseur\n        if (grilleSecondaireY === 'pointilles') {\n          traitH.pointilles = 5\n        }\n        this.objets.push(traitH)\n      }\n    }\n    // Les traits verticaux\n    if (grilleSecondaireX) {\n      if (grilleSecondaireXListe.length === 0) {\n        // Ceux qui ne sont pas définis reprennent les valeurs de thick\n        if (typeof grilleSecondaireXMin !== 'number') {\n          grilleSecondaireXMin = xThickMin\n        }\n        if (typeof grilleSecondaireXMax !== 'number') {\n          grilleSecondaireXMax = xThickMax\n        }\n        if (typeof grilleSecondaireXDistance !== 'number') {\n          grilleSecondaireXDistance = xThickDistance / 2\n        }\n        // On créé la liste avec ces valeurs\n        grilleSecondaireXListe = []\n        if (grilleSecondaireXMin < 0 && grilleSecondaireXMax > 0) {\n          grilleSecondaireXListe.push(0)\n          for (\n            let x = grilleSecondaireXDistance / xUnite;\n            x < Math.max(-grilleSecondaireXMin, grilleSecondaireXMax);\n            x += grilleSecondaireXDistance / xUnite\n          ) {\n            if (x <= grilleSecondaireXMax) grilleSecondaireXListe.push(x)\n            if (x <= -grilleSecondaireXMin) grilleSecondaireXListe.push(-x)\n          }\n        } else if (grilleSecondaireXMin >= 0 && grilleSecondaireXMax > 0) {\n          for (\n            let x = grilleSecondaireXMin;\n            x <= grilleSecondaireXMax;\n            x += grilleSecondaireXDistance / xUnite\n          ) {\n            grilleSecondaireXListe.push(x)\n          }\n        } else if (grilleSecondaireXMin < 0 && grilleSecondaireXMax <= 0) {\n          for (\n            let x = grilleSecondaireXMax;\n            x >= grilleSecondaireXMin;\n            x -= grilleSecondaireXDistance / xUnite\n          ) {\n            grilleSecondaireXListe.push(x)\n          }\n        }\n      }\n      for (const x of grilleSecondaireXListe) {\n        const traitV = segment(\n          x * xUnite,\n          (grilleSecondaireYMin || yMin) * yUnite,\n          x * xUnite,\n          (grilleSecondaireYMax || yMax) * yUnite,\n          grilleSecondaireXCouleur,\n        )\n        //  traitV.isVisible = false\n        traitV.opacite = grilleSecondaireXOpacite\n        traitV.epaisseur = grilleSecondaireEpaisseur\n        if (grilleSecondaireX === 'pointilles') {\n          traitV.pointilles = 5\n        }\n        this.objets.push(traitV)\n      }\n    }\n    // LES THICKS\n    if (axeXisVisible) {\n      if (\n        (typeof xThickListe === 'boolean' && xThickListe) ||\n        (Array.isArray(xThickListe) && xThickListe.length === 0)\n      ) {\n        xThickListe = []\n        if (xThickMin < 0 && xThickMax > 0) {\n          xThickListe.push(0)\n          for (\n            let x = xThickDistance;\n            x < Math.max(-xThickMin, xThickMax);\n            x += xThickDistance\n          ) {\n            if (x <= xThickMax) xThickListe.push(x)\n            if (x <= -xThickMin) xThickListe.push(-x)\n          }\n        } else if (xThickMin >= 0 && xThickMax > 0) {\n          for (let x = xThickMin; x <= xThickMax; x += xThickDistance) {\n            xThickListe.push(x)\n          }\n        } else if (xThickMin < 0 && xThickMax <= 0) {\n          for (let x = xThickMax; x >= xThickMin; x -= xThickDistance) {\n            xThickListe.push(x)\n          }\n        }\n      } else if (typeof xThickListe === 'boolean') xThickListe = []\n\n      for (const x of xThickListe) {\n        const thick = segment(\n          x * xUnite,\n          ordonneeAxe * yUnite - thickHauteur,\n          x * xUnite,\n          ordonneeAxe * yUnite + thickHauteur,\n          thickCouleur,\n        )\n        // thick.isVisible = false\n        thick.epaisseur = thickEpaisseur\n        this.objets.push(thick)\n      }\n    }\n    if (axeYisVisible) {\n      if (\n        (typeof yThickListe === 'boolean' && yThickListe) ||\n        (Array.isArray(yThickListe) && yThickListe.length === 0)\n      ) {\n        yThickListe = []\n        if (yThickMin < 0 && yThickMax > 0) {\n          yThickListe.push(0)\n          for (\n            let y = yThickDistance;\n            y < Math.max(-yThickMin, yThickMax);\n            y += yThickDistance\n          ) {\n            if (y <= yThickMax) yThickListe.push(y)\n            if (y <= -yThickMin) yThickListe.push(-y)\n          }\n        } else if (yThickMin >= 0 && yThickMax > 0) {\n          for (let y = yThickMin; y <= yThickMax; y += yThickDistance) {\n            yThickListe.push(y)\n          }\n        } else if (yThickMin < 0 && yThickMax <= 0) {\n          for (let y = yThickMax; y >= yThickMin; y -= yThickDistance) {\n            yThickListe.push(y)\n          }\n        }\n      } else if (typeof yThickListe === 'boolean') yThickListe = []\n      for (const y of yThickListe) {\n        const thick = segment(\n          abscisseAxe * xUnite - thickHauteur,\n          y * yUnite,\n          abscisseAxe * xUnite + thickHauteur,\n          y * yUnite,\n          thickCouleur,\n        )\n        // thick.isVisible = false\n        thick.epaisseur = thickEpaisseur\n        this.objets.push(thick)\n      }\n    }\n    // LES LABELS\n    if (axeXisVisible) {\n      if (\n        (typeof xLabelListe === 'boolean' && xLabelListe) ||\n        (Array.isArray(xLabelListe) && xLabelListe.length === 0)\n      ) {\n        xLabelListe = rangeMinMax(0, xLabelMax, [0], xLabelDistance).concat(\n          rangeMinMax(0, -xLabelMin, [0], xLabelDistance).map((el) => -el),\n        )\n      } else if (typeof xLabelListe === 'boolean') xLabelListe = []\n      for (const x of xLabelListe) {\n        let l\n        if (typeof x === 'number') {\n          if (x >= xMin && x <= xMax) {\n            l = latex2d(\n              `${stringNombre(x, precisionLabelX)}`,\n              x * xUnite,\n              ordonneeAxe * yUnite - xLabelEcart + 0.1,\n              // { letterSize: 'scriptsize', opacity: 0.8, color: 'black' }, // EE : Commenté car sinon taille abscisse !== taille ordonnée\n              { letterSize: 'scriptsize', opacity: 0.8, color: 'black' },\n            )\n            //   l.isVisible = false\n            this.objets.push(l)\n          }\n        } else {\n          if (x.valeur <= xMax && x.valeur >= xMin) {\n            l = latex2d(\n              x.texte,\n              x.valeur * xUnite,\n              ordonneeAxe * yUnite - xLabelEcart + 0.1,\n              // { letterSize: 'footnotesize', color: 'black', opacity: 0.8 },  // EE : Commenté car sinon taille abscisse !== taille ordonnée\n              { letterSize: 'scriptsize', color: 'black', opacity: 0.8 },\n            )\n            //  l.isVisible = false\n            this.objets.push(l)\n          }\n        }\n      }\n    }\n    if (axeYisVisible) {\n      if (\n        (typeof yLabelListe === 'boolean' && yLabelListe) ||\n        (Array.isArray(yLabelListe) && yLabelListe.length === 0)\n      ) {\n        yLabelListe = rangeMinMax(0, yLabelMax, [0], yLabelDistance).concat(\n          rangeMinMax(0, -yLabelMin, [0], yLabelDistance).map((el) => -el),\n        )\n      } else if (typeof yLabelListe === 'boolean') yLabelListe = []\n      for (const y of yLabelListe) {\n        let l\n        if (typeof y === 'number') {\n          if (y >= yMin && y <= yMax) {\n            l = latex2d(\n              `${stringNombre(y, precisionLabelY)}`,\n              abscisseAxe * xUnite - yLabelEcart,\n              y * yUnite + 0.1,\n              // { letterSize: 'small', opacity: 0.8, color: 'black' },\n              { letterSize: 'scriptsize', opacity: 0.8, color: 'black' },\n            )\n            //  l.isVisible = false\n            this.objets.push(l)\n          }\n        } else {\n          if (y.valeur >= yMin && y.valeur <= yMax) {\n            l = latex2d(\n              y.texte,\n              abscisseAxe * xUnite - yLabelEcart,\n              y.valeur * yUnite + 0.1,\n              /// { letterSize: 'small', opacity: 0.8, color: 'black' },\n              { letterSize: 'scriptsize', opacity: 0.8, color: 'black' },\n            )\n            //     l.isVisible = false\n            this.objets.push(l)\n          }\n        }\n      }\n    }\n    // LES LÉGENDES\n    if (xLegende.length > 0) {\n      this.objets.push(\n        texteParPosition(\n          xLegende,\n          xLegendePosition[0],\n          xLegendePosition[1],\n          0,\n          'black',\n          1,\n          'droite',\n        ),\n      )\n    }\n    if (yLegende.length > 0) {\n      this.objets.push(\n        texteParPosition(\n          yLegende,\n          yLegendePosition[0],\n          yLegendePosition[1],\n          0,\n          'black',\n          1,\n          'droite',\n        ),\n      )\n    }\n    const bords = fixeBordures(this.objets, {\n      rxmin: 0,\n      rxmax: 0,\n      rymin: 0,\n      rymax: 0,\n    })\n    this.bordures = [bords.xmin, bords.ymin, bords.xmax, bords.ymax]\n    // pour pouvoir ajouter des objets à ce Repere après l'avoir créé.\n  }\n\n  addObjet(objet: ObjetMathalea2D) {\n    if (!(objet instanceof ObjetMathalea2D)) return\n    this.objets?.concat(objet)\n  }\n\n  // Une méthode pour passer ce qu'il fait à mathalea2d()\n  trace() {\n    return this.objets\n  }\n\n  // LES SORTIES TiKZ et SVG\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.svgml === 'undefined') code += '\\n\\t' + objet.svg(coeff)\n      else code += '\\n\\t' + objet.svgml(coeff, amp)\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.tikzml === 'undefined') code += '\\n\\t' + objet.tikz()\n      else code += '\\n\\t' + objet.tikzml(amp)\n    }\n    return code\n  }\n}\n\n/**\n *\n * @param {object} params\n * @return {Repere}\n * @author Rémi Angot\n */\nexport function repere({\n  xUnite = 1,\n  yUnite = 1,\n  xMin = -10,\n  xMax = 10,\n  yMin = -10,\n  yMax = 10,\n  axeXisVisible = true,\n  axeYisVisible = true,\n  axesEpaisseur = 1.2,\n  axesCouleur = 'black',\n  axeXStyle = '->',\n  axeYStyle = '->',\n  thickEpaisseur = 1.2,\n  thickHauteur = 0.13,\n  thickCouleur = axesCouleur,\n  xThickDistance = 1,\n  xThickListe = [],\n  xThickMin = xMin + xThickDistance,\n  xThickMax = xMax - xThickDistance,\n  yThickDistance = 1,\n  yThickListe = [],\n  yThickMin = yMin + yThickDistance,\n  yThickMax = yMax - yThickDistance,\n  xLabelDistance = xThickDistance,\n  xLabelListe = [],\n  xLabelMin = xThickMin,\n  xLabelMax = xThickMax,\n  yLabelDistance = yThickDistance,\n  yLabelListe = [],\n  yLabelMin = yThickMin,\n  yLabelMax = yThickMax,\n  precisionLabelX = 1,\n  precisionLabelY = 1,\n  xLabelEcart = 0.5,\n  yLabelEcart = 0.5,\n  xLegende = '',\n  xLegendePosition = [],\n  yLegende = '',\n  yLegendePosition = [],\n  grille = true,\n  grilleDistance = 1,\n  grilleCouleur = 'black',\n  grilleOpacite = 0.4,\n  grilleEpaisseur = 1,\n  grilleSecondaire = false,\n  grilleSecondaireDistance = 1,\n  grilleSecondaireCouleur = 'gray',\n  grilleSecondaireOpacite = 0.3,\n  grilleSecondaireEpaisseur = 1,\n  grilleX = grille,\n  grilleXListe = [],\n  grilleXDistance = grilleDistance,\n  grilleXMin = xMin,\n  grilleXMax = xMax,\n  grilleXCouleur = grilleCouleur,\n  grilleXOpacite = grilleOpacite,\n  grilleY = grille,\n  grilleYListe = [],\n  grilleYDistance = grilleDistance,\n  grilleYMin = yMin,\n  grilleYMax = yMax,\n  grilleYCouleur = grilleCouleur,\n  grilleYOpacite = grilleOpacite,\n  grilleSecondaireX = grilleSecondaire,\n  grilleSecondaireXListe = [],\n  grilleSecondaireXDistance = grilleSecondaireDistance,\n  grilleSecondaireXMin = xMin,\n  grilleSecondaireXMax = xMax,\n  grilleSecondaireXCouleur = grilleSecondaireCouleur,\n  grilleSecondaireXOpacite = grilleSecondaireOpacite,\n  grilleSecondaireY = grilleSecondaire,\n  grilleSecondaireYListe = [],\n  grilleSecondaireYDistance = grilleSecondaireDistance,\n  grilleSecondaireYMin = yMin,\n  grilleSecondaireYMax = yMax,\n  grilleSecondaireYCouleur = grilleSecondaireCouleur,\n  grilleSecondaireYOpacite = grilleSecondaireOpacite,\n}: {\n  xUnite?: number\n  yUnite?: number\n  xMin?: number\n  xMax?: number\n  yMin?: number\n  yMax?: number\n  axeXisVisible?: boolean\n  axeYisVisible?: boolean\n  axesEpaisseur?: number\n  axesCouleur?: string\n  axeXStyle?: string\n  axeYStyle?: string\n  thickEpaisseur?: number\n  thickHauteur?: number\n  thickCouleur?: string\n  xThickDistance?: number\n  xThickListe?: number[] | boolean\n  xThickMin?: number\n  xThickMax?: number\n  yThickDistance?: number\n  yThickListe?: number[] | boolean\n  yThickMin?: number\n  yThickMax?: number\n  xLabelDistance?: number\n  xLabelListe?: boolean | (number | { valeur: number; texte: string })[]\n  xLabelMin?: number\n  xLabelMax?: number\n  yLabelDistance?: number\n  yLabelListe?: boolean | (number | { valeur: number; texte: string })[]\n  yLabelMin?: number\n  yLabelMax?: number\n  precisionLabelX?: number\n  precisionLabelY?: number\n  xLabelEcart?: number\n  yLabelEcart?: number\n  xLegende?: string\n  xLegendePosition?: number[]\n  yLegende?: string\n  yLegendePosition?: number[]\n  grille?: boolean | 'pointilles'\n  grilleDistance?: number\n  grilleCouleur?: string\n  grilleOpacite?: number\n  grilleEpaisseur?: number\n  grilleSecondaire?: boolean\n  grilleSecondaireDistance?: number\n  grilleSecondaireCouleur?: string\n  grilleSecondaireOpacite?: number\n  grilleSecondaireEpaisseur?: number\n  grilleX?: boolean | 'pointilles'\n  grilleXListe?: number[]\n  grilleXDistance?: number\n  grilleXMin?: number\n  grilleXMax?: number\n  grilleXCouleur?: string\n  grilleXOpacite?: number\n  grilleY?: boolean | 'pointilles'\n  grilleYListe?: number[]\n  grilleYDistance?: number\n  grilleYMin?: number\n  grilleYMax?: number\n  grilleYCouleur?: string\n  grilleYOpacite?: number\n  grilleSecondaireX?: boolean | 'pointilles'\n  grilleSecondaireXListe?: number[]\n  grilleSecondaireXDistance?: number\n  grilleSecondaireXMin?: number\n  grilleSecondaireXMax?: number\n  grilleSecondaireXCouleur?: string\n  grilleSecondaireXOpacite?: number\n  grilleSecondaireY?: boolean | 'pointilles'\n  grilleSecondaireYListe?: number[]\n  grilleSecondaireYDistance?: number\n  grilleSecondaireYMin?: number\n  grilleSecondaireYMax?: number\n  grilleSecondaireYCouleur?: string\n  grilleSecondaireYOpacite?: number\n}) {\n  return new Repere({\n    xUnite,\n    yUnite,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    axeXisVisible,\n    axeYisVisible,\n    axesEpaisseur,\n    axesCouleur,\n    axeXStyle,\n    axeYStyle,\n    thickEpaisseur,\n    thickHauteur,\n    thickCouleur,\n    xThickDistance,\n    xThickListe,\n    xThickMin,\n    xThickMax,\n    yThickDistance,\n    yThickListe,\n    yThickMin,\n    yThickMax,\n    xLabelDistance,\n    xLabelListe,\n    xLabelMin,\n    xLabelMax,\n    yLabelDistance,\n    yLabelListe,\n    yLabelMin,\n    yLabelMax,\n    precisionLabelX,\n    precisionLabelY,\n    xLabelEcart,\n    yLabelEcart,\n    xLegende,\n    xLegendePosition,\n    yLegende,\n    yLegendePosition,\n    grille,\n    grilleDistance,\n    grilleCouleur,\n    grilleOpacite,\n    grilleEpaisseur,\n    grilleSecondaire,\n    grilleSecondaireDistance,\n    grilleSecondaireCouleur,\n    grilleSecondaireOpacite,\n    grilleSecondaireEpaisseur,\n    grilleX,\n    grilleXListe,\n    grilleXDistance,\n    grilleXMin,\n    grilleXMax,\n    grilleXCouleur,\n    grilleXOpacite,\n    grilleY,\n    grilleYListe,\n    grilleYDistance,\n    grilleYMin,\n    grilleYMax,\n    grilleYCouleur,\n    grilleYOpacite,\n    grilleSecondaireX,\n    grilleSecondaireXListe,\n    grilleSecondaireXDistance,\n    grilleSecondaireXMin,\n    grilleSecondaireXMax,\n    grilleSecondaireXCouleur,\n    grilleSecondaireXOpacite,\n    grilleSecondaireY,\n    grilleSecondaireYListe,\n    grilleSecondaireYDistance,\n    grilleSecondaireYMin,\n    grilleSecondaireYMax,\n    grilleSecondaireYCouleur,\n    grilleSecondaireYOpacite,\n  })\n}\n\n/**\n * Place un point dans un repère (en récupérant xUnite et yUnite d'un objet repère)\n *\n *\n * @param {number} x\n * @param {number} y\n * @param {object} repere\n * @author Rémi Angot\n */\nexport function pointDansRepere(\n  x: number,\n  y: number,\n  repere = { xUnite: 1, yUnite: 1 },\n) {\n  return point(x * repere.xUnite, y * repere.yUnite)\n}\n"],"names":["DroiteGraduee","ObjetMathalea2D","Unite","Min","Max","x","y","axeEpaisseur","axeCouleur","axeStyle","axeHauteur","axePosition","thickEpaisseur","thickCouleur","thickDistance","thickOffset","thickSecDist","thickSec","thickTerDist","thickTer","pointListe","labelPointTaille","labelPointLargeur","pointCouleur","pointTaille","pointStyle","pointOpacite","pointEpaisseur","labelsPrincipaux","labelsSecondaires","labelColor","step1","step2","labelCustomDistance","context","labelDistance","labelListe","Legende","LegendePosition","__publicField","S","T","P","i","longueurTotale","absord","segment","point","factor","r","Min2","Max2","pas1","pas2","j","latexParCoordonnees","nombreAvecEspace","arrondi","t","p","latex2d","texteParPosition","lab","tracePoint","bordures","fixeBordures","droiteGraduee","AxeY","ymin","ymax","thick","ystep","epaisseur","color","ytick","titre","texteParPoint","ordonnee","s","objet","coeff","code","axeY","LabelY","step","pos","stringNombre","labelY","Grille","xmin","xmax","opacite","pointilles","colorToLatexOrHTML","nbStep","amp","grille","LignesHorizontales","lignesHorizontales","LignesVerticales","lignesVerticales","Seyes","opacite1","opacite2","d","seyes","PapierPointe","xstep","type","pointColor","pointRayon","opaciteDeRemplissage","xstep1","xstep2","ystep1","stepper","plot","papierPointe","Repere","xUnite","yUnite","xMin","xMax","yMin","yMax","axeXisVisible","axeYisVisible","axesEpaisseur","axesCouleur","axeXStyle","axeYStyle","thickHauteur","xThickDistance","xThickListe","xThickMin","xThickMax","yThickDistance","yThickListe","yThickMin","yThickMax","xLabelDistance","xLabelListe","xLabelMin","xLabelMax","yLabelDistance","yLabelListe","yLabelMin","yLabelMax","precisionLabelX","precisionLabelY","xLabelEcart","yLabelEcart","xLegende","xLegendePosition","yLegende","yLegendePosition","grilleDistance","grilleCouleur","grilleOpacite","grilleEpaisseur","grilleSecondaire","grilleSecondaireDistance","grilleSecondaireCouleur","grilleSecondaireOpacite","grilleSecondaireEpaisseur","grilleX","grilleXListe","grilleXDistance","grilleXMin","grilleXMax","grilleXCouleur","grilleXOpacite","grilleY","grilleYListe","grilleYDistance","grilleYMin","grilleYMax","grilleYCouleur","grilleYOpacite","grilleSecondaireX","grilleSecondaireXListe","grilleSecondaireXDistance","grilleSecondaireXMin","grilleSecondaireXMax","grilleSecondaireXCouleur","grilleSecondaireXOpacite","grilleSecondaireY","grilleSecondaireYListe","grilleSecondaireYDistance","grilleSecondaireYMin","grilleSecondaireYMax","grilleSecondaireYCouleur","grilleSecondaireYOpacite","ordonneeAxe","axeX","abscisseAxe","traitH","traitV","rangeMinMax","el","l","bords","_a","repere","pointDansRepere"],"mappings":"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"}
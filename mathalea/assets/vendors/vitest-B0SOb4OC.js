var ft=Object.defineProperty;var lt=(t,i,u)=>i in t?ft(t,i,{enumerable:!0,configurable:!0,writable:!0,value:u}):t[i]=u;var W=(t,i,u)=>lt(t,typeof i!="symbol"?i+"":i,u);import{g as mt}from"./vitest_runner-CqFJvfZ7.js";import{e as be,a as dt,u as He,b as ce}from"./chai-DTVZgaf2.js";import{A as pt,g as Ae,s as Ee,a as yt,G as We,J as ht,b as Tt,c as wt,e as kt,i as vt,d as gt}from"./vitest_expect-r-L7D122.js";import{s as Ue,a as bt,S as At}from"./vitest_snapshot-Bihmomkt.js";import{a as Et,g as Me,c as St,p as It}from"./vitest_utils-CZP3wGXz.js";import{f as Pt,s as Ot,m as Se,i as Mt}from"./vitest_spy-CVeaWOS9.js";function Ce(){const t=globalThis.__vitest_worker__;if(!t){const i=`Vitest failed to access its internal state.

One of the following is possible:
- "vitest" is imported directly without running "vitest" command
- "vitest" is imported inside "globalSetup" (to fix this, use "setupFiles" instead, because "globalSetup" runs in a different context)
- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues
`;throw new Error(i)}return t}function Ct(){const t=Ce();return t==null?void 0:t.environment.name}var ae=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function xt(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function Ke(){return typeof process<"u"&&!!process.send}const D=Date;let Pe=null;class K extends D{constructor(i,u,l,y,c,m,d){super();let h;switch(arguments.length){case 0:Pe!==null?h=new D(Pe.valueOf()):h=new D;break;case 1:h=new D(i);break;default:l=typeof l>"u"?1:l,y=y||0,c=c||0,m=m||0,d=d||0,h=new D(i,u,l,y,c,m,d);break}return Object.setPrototypeOf(h,K.prototype),h}}K.UTC=D.UTC;K.now=function(){return new K().valueOf()};K.parse=function(t){return D.parse(t)};K.toString=function(){return D.toString()};function jt(t){const i=new D(t.valueOf());if(Number.isNaN(i.getTime()))throw new TypeError(`mockdate: The time set is an invalid date: ${t}`);globalThis.Date=K,Pe=i.valueOf()}function _t(){globalThis.Date=D}var oe={};function Ft(t,i=!1){const u=[/\/vitest\/dist\//,/\/vite-node\/dist\//,/vitest-virtual-\w+\/dist/,/@vitest\/dist/,...i?[]:[/^mock:/]];t.forEach((l,y)=>{u.some(c=>c.test(y))||t.invalidateModule(l)})}function Nt(){const{setTimeout:t}=Me();return new Promise(i=>t(i,0))}async function Ve(){await Nt();const t=Ce(),i=[];let u=0;for(const l of t.moduleCache.values())l.promise&&!l.evaluated&&i.push(l.promise),l.resolving&&u++;!i.length&&!u||(await Promise.allSettled(i),await Ve())}function Rt(t){throw new Error('Could not dynamically require "'+t+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var ze={exports:{}};(function(t,i){(function(){(function(u){return typeof Rt=="function"?t.exports=u:chai.use(u)})(function(u,l){var y=u.Assertion,c=y.prototype;y.addMethod("containSubset",function(d){var h=l.flag(this,"object"),b=u.config.showDiff;c.assert.call(this,m(d,h),"expected #{act} to contain subset #{exp}","expected #{act} to not contain subset #{exp}",d,h,b)}),u.assert.containSubset=function(d,h,b){new u.Assertion(d,b).to.be.containSubset(h)};function m(d,h){if(d===h)return!0;if(typeof h!=typeof d)return!1;if(typeof d!="object"||d===null)return d===h;if(d&&!h)return!1;if(Array.isArray(d)){if(typeof h.length!="number")return!1;var b=Array.prototype.slice.call(h);return d.every(function(w){return b.some(function(s){return m(w,s)})})}return d instanceof Date?h instanceof Date?d.getTime()===h.getTime():!1:Object.keys(d).every(function(w){var s=d[w],p=h[w];return typeof s=="object"&&s!==null&&p!==null?m(s,p):typeof s=="function"?s(p):p===s})}})}).call(ae)})(ze);var Dt=ze.exports,$t=xt(Dt);const Ge=Symbol.for("matchers-object"),qt=Symbol.for("$$jest-matchers-object"),Lt=Symbol.for("expect-global"),Bt=Symbol.for("asymmetric-matchers-object");if(!Object.prototype.hasOwnProperty.call(globalThis,Ge)){const t=new WeakMap,i=Object.create(null),u=[],l=Object.create(null);Object.defineProperty(globalThis,Ge,{get:()=>t}),Object.defineProperty(globalThis,qt,{configurable:!0,get:()=>({state:t.get(globalThis[Lt]),matchers:i,customEqualityTesters:u})}),Object.defineProperty(globalThis,Bt,{get:()=>l})}function Ht(t,i){return t&&i instanceof Promise&&(i=i.finally(()=>{const u=t.promises.indexOf(i);u!==-1&&t.promises.splice(u,1)}),t.promises||(t.promises=[]),t.promises.push(i)),i}let Ie;function se(){return Ie||(Ie=new At({isEqual:(t,i)=>kt(t,i,[vt,gt])})),Ie}function Je(t,i){if(typeof t!="function"){if(!i)throw new Error(`expected must be a function, received ${typeof t}`);return t}try{t()}catch(u){return u}throw new Error("snapshot function didn't throw")}const Ut=(t,i)=>{const u=l=>{var y;return l?{filepath:(y=l.file)==null?void 0:y.filepath,name:mt(l).slice(1).join(" > ")}:{}};for(const l of["matchSnapshot","toMatchSnapshot"])i.addMethod(t.Assertion.prototype,l,function(y,c){if(i.flag(this,"negate"))throw new Error(`${l} cannot be used with "not"`);const d=i.flag(this,"object"),h=i.flag(this,"vitest-test");typeof y=="string"&&typeof c>"u"&&(c=y,y=void 0);const b=i.flag(this,"message");se().assert({received:d,message:c,isInline:!1,properties:y,errorMessage:b,...u(h)})});i.addMethod(t.Assertion.prototype,"toMatchFileSnapshot",function(l,y){if(i.flag(this,"negate"))throw new Error('toMatchFileSnapshot cannot be used with "not"');const m=i.flag(this,"object"),d=i.flag(this,"vitest-test"),h=i.flag(this,"message"),b=se().assertRaw({received:m,message:y,isInline:!1,rawSnapshot:{file:l},errorMessage:h,...u(d)});return Ht(d,b)}),i.addMethod(t.Assertion.prototype,"toMatchInlineSnapshot",function(y,c,m){var d;if(i.flag(this,"negate"))throw new Error('toMatchInlineSnapshot cannot be used with "not"');const b=i.flag(this,"vitest-test");if(b&&(b.each||((d=b.suite)==null?void 0:d.each)))throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");const s=i.flag(this,"object"),p=i.flag(this,"error");typeof y=="string"&&(m=c,c=y,y=void 0),c&&(c=Ue(c));const A=i.flag(this,"message");se().assert({received:s,message:m,isInline:!0,properties:y,inlineSnapshot:c,error:p,errorMessage:A,...u(b)})}),i.addMethod(t.Assertion.prototype,"toThrowErrorMatchingSnapshot",function(l){if(i.flag(this,"negate"))throw new Error('toThrowErrorMatchingSnapshot cannot be used with "not"');const c=i.flag(this,"object"),m=i.flag(this,"vitest-test"),d=i.flag(this,"promise"),h=i.flag(this,"message");se().assert({received:Je(c,d),message:l,errorMessage:h,...u(m)})}),i.addMethod(t.Assertion.prototype,"toThrowErrorMatchingInlineSnapshot",function(y,c){var m;if(i.flag(this,"negate"))throw new Error('toThrowErrorMatchingInlineSnapshot cannot be used with "not"');const h=i.flag(this,"vitest-test");if(h&&(h.each||((m=h.suite)==null?void 0:m.each)))throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");const w=i.flag(this,"object"),s=i.flag(this,"error"),p=i.flag(this,"promise"),A=i.flag(this,"message");y&&(y=Ue(y)),se().assert({received:Je(w,p),message:c,inlineSnapshot:y,isInline:!0,error:s,errorMessage:A,...u(h)})}),i.addMethod(t.expect,"addSnapshotSerializer",bt)};ce(ht);ce(Tt);ce($t);ce(Ut);ce(wt);function Gt(t){const i=(c,m)=>{const{assertionCalls:d}=Ae(i);return Ee({assertionCalls:d+1,soft:!1},i),be(c,m)};Object.assign(i,be),Object.assign(i,globalThis[pt]),i.getState=()=>Ae(i),i.setState=c=>Ee(c,i);const u=Ae(globalThis[We])||{};Ee({...u,assertionCalls:0,isExpectingAssertions:!1,isExpectingAssertionsError:null,expectedAssertionsNumber:null,expectedAssertionsNumberErrorGen:null,environment:Ct(),testPath:u.testPath,currentTestName:u.currentTestName},i),i.extend=c=>be.extend(i,c),i.addEqualityTesters=c=>yt(c),i.soft=(...c)=>{const m=i(...c);return i.setState({soft:!0}),m},i.unreachable=c=>{dt.fail(`expected${c?` "${c}" `:" "}not to be reached`)};function l(c){const m=()=>new Error(`expected number of assertions to be ${c}, but got ${i.getState().assertionCalls}`);Error.captureStackTrace&&Error.captureStackTrace(m(),l),i.setState({expectedAssertionsNumber:c,expectedAssertionsNumberErrorGen:m})}function y(){const c=new Error("expected any number of assertion, but got none");Error.captureStackTrace&&Error.captureStackTrace(c,y),i.setState({isExpectingAssertions:!0,isExpectingAssertionsError:c})}return He.addMethod(i,"assertions",l),He.addMethod(i,"hasAssertions",y),i}const Jt=Gt();Object.defineProperty(globalThis,We,{value:Jt,writable:!0,configurable:!0});var me;typeof ae<"u"?me=ae:typeof window<"u"?me=window:me=self;var Wt=me;let Oe;try{({}).__proto__,Oe=!1}catch{Oe=!0}var Kt=Oe,Vt=Function.call,zt=Kt,Xe=["size","caller","callee","arguments"];zt&&Xe.push("__proto__");var te=function(i){return Object.getOwnPropertyNames(i).reduce(function(u,l){return Xe.includes(l)||typeof i[l]!="function"||(u[l]=Vt.bind(i[l])),u},Object.create(null))},Xt=te,xe=Xt(Array.prototype);xe.every;var Yt={};(function(t){t.wrap=function(i,u){var l=function(){return t.printWarning(u),i.apply(this,arguments)};return i.prototype&&(l.prototype=i.prototype),l},t.defaultMsg=function(i,u){return`${i}.${u} is deprecated and will be removed from the public API in a future version of ${i}.`},t.printWarning=function(i){typeof process=="object"&&process.emitWarning?process.emitWarning(i):console.info?console.info(i):console.log(i)}})(Yt);xe.sort;xe.slice;var Qt=te;Qt(Function.prototype);var Zt=te;Zt(Map.prototype);var er=te;er(Object.prototype);var tr=te;tr(Set.prototype);var rr=te;rr(String.prototype);var nr={exports:{}};(function(t,i){(function(u,l){t.exports=l()})(ae,function(){var u=typeof Promise=="function",l=typeof self=="object"?self:ae,y=typeof Symbol<"u",c=typeof Map<"u",m=typeof Set<"u",d=typeof WeakMap<"u",h=typeof WeakSet<"u",b=typeof DataView<"u",w=y&&typeof Symbol.iterator<"u",s=y&&typeof Symbol.toStringTag<"u",p=m&&typeof Set.prototype.entries=="function",A=c&&typeof Map.prototype.entries=="function",j=p&&Object.getPrototypeOf(new Set().entries()),R=A&&Object.getPrototypeOf(new Map().entries()),B=w&&typeof Array.prototype[Symbol.iterator]=="function",S=B&&Object.getPrototypeOf([][Symbol.iterator]()),I=w&&typeof String.prototype[Symbol.iterator]=="function",$=I&&Object.getPrototypeOf(""[Symbol.iterator]()),U=8,_=-1;function X(O){var ue=typeof O;if(ue!=="object")return ue;if(O===null)return"null";if(O===l)return"global";if(Array.isArray(O)&&(s===!1||!(Symbol.toStringTag in O)))return"Array";if(typeof window=="object"&&window!==null){if(typeof window.location=="object"&&O===window.location)return"Location";if(typeof window.document=="object"&&O===window.document)return"Document";if(typeof window.navigator=="object"){if(typeof window.navigator.mimeTypes=="object"&&O===window.navigator.mimeTypes)return"MimeTypeArray";if(typeof window.navigator.plugins=="object"&&O===window.navigator.plugins)return"PluginArray"}if((typeof window.HTMLElement=="function"||typeof window.HTMLElement=="object")&&O instanceof window.HTMLElement){if(O.tagName==="BLOCKQUOTE")return"HTMLQuoteElement";if(O.tagName==="TD")return"HTMLTableDataCellElement";if(O.tagName==="TH")return"HTMLTableHeaderCellElement"}}var V=s&&O[Symbol.toStringTag];if(typeof V=="string")return V;var M=Object.getPrototypeOf(O);return M===RegExp.prototype?"RegExp":M===Date.prototype?"Date":u&&M===Promise.prototype?"Promise":m&&M===Set.prototype?"Set":c&&M===Map.prototype?"Map":h&&M===WeakSet.prototype?"WeakSet":d&&M===WeakMap.prototype?"WeakMap":b&&M===DataView.prototype?"DataView":c&&M===R?"Map Iterator":m&&M===j?"Set Iterator":B&&M===S?"Array Iterator":I&&M===$?"String Iterator":M===null?"Object":Object.prototype.toString.call(O).slice(U,_)}return X})})(nr);var ir={global:Wt};const Ye=ir.global;let ee;if(typeof __vitest_required__<"u")try{ee=__vitest_required__.timers}catch{}function je(t){const i=Math.pow(2,31)-1,u=1e12,l=function(){},y=function(){return[]},c=t.setTimeout(l,0),m=typeof c=="object",d=t.process&&typeof t.process.hrtime=="function",h=d&&typeof t.process.hrtime.bigint=="function",b=t.process&&typeof t.process.nextTick=="function",w=t.process&&t.__vitest_required__&&t.__vitest_required__.util.promisify,s=t.performance&&typeof t.performance.now=="function",p=t.Performance&&(typeof t.Performance).match(/^(function|object)$/),A=t.performance&&t.performance.constructor&&t.performance.constructor.prototype,j=t.hasOwnProperty("queueMicrotask"),R=t.requestAnimationFrame&&typeof t.requestAnimationFrame=="function",B=t.cancelAnimationFrame&&typeof t.cancelAnimationFrame=="function",S=t.requestIdleCallback&&typeof t.requestIdleCallback=="function",I=t.cancelIdleCallback&&typeof t.cancelIdleCallback=="function",$=t.setImmediate&&typeof t.setImmediate=="function",U=t.Intl&&typeof t.Intl=="object";t.clearTimeout(c);const _=t.Date,X=t.Intl;let O=u;function ue(r){return Number.isFinite?Number.isFinite(r):isFinite(r)}let V=!1;function M(r,n){r.loopLimit&&n===r.loopLimit-1&&(V=!0)}function re(){V=!1}function Fe(r){if(!r)return 0;const n=r.split(":"),o=n.length;let a=o,e=0,g;if(o>3||!/^(\d\d:){0,2}\d\d?$/.test(r))throw new Error("tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits");for(;a--;){if(g=parseInt(n[a],10),g>=60)throw new Error(`Invalid time ${r}`);e+=g*Math.pow(60,o-a-1)}return e*1e3}function Ze(r){const o=r*1e6%1e6,a=o<0?o+1e6:o;return Math.floor(a)}function Ne(r){if(!r)return 0;if(typeof r.getTime=="function")return r.getTime();if(typeof r=="number")return r;throw new TypeError("now should be milliseconds since UNIX epoch")}function et(r,n,o){return o&&o.callAt>=r&&o.callAt<=n}function pe(r,n){const o=new Error(`Aborting after running ${r.loopLimit} timers, assuming an infinite loop!`);if(!n.error)return o;const a=/target\.*[<|(|[].*?[>|\]|)]\s*/;let e=new RegExp(String(Object.keys(r).join("|")));m&&(e=new RegExp(`\\s+at (Object\\.)?(?:${Object.keys(r).join("|")})\\s+`));let g=-1;n.error.stack.split(`
`).some(function(P,q){return P.match(a)?(g=q,!0):P.match(e)?(g=q,!1):g>=0});const C=`${o}
${n.type||"Microtask"} - ${n.func.name||"anonymous"}
${n.error.stack.split(`
`).slice(g+1).join(`
`)}`;try{Object.defineProperty(o,"stack",{value:C})}catch{}return o}function Re(r,n){let o;for(o in n)n.hasOwnProperty(o)&&(r[o]=n[o]);return n.now?r.now=function(){return r.clock.now}:delete r.now,n.toSource?r.toSource=function(){return n.toSource()}:delete r.toSource,r.toString=function(){return n.toString()},r.prototype=n.prototype,r.parse=n.parse,r.UTC=n.UTC,r.prototype.toUTCString=n.prototype.toUTCString,r.isFake=!0,r}function tt(){function r(n,o,a,e,g,C,P){if(!(this instanceof r))return new _(r.clock.now).toString();switch(arguments.length){case 0:return new _(r.clock.now);case 1:return new _(n);case 2:return new _(n,o);case 3:return new _(n,o,a);case 4:return new _(n,o,a,e);case 5:return new _(n,o,a,e,g);case 6:return new _(n,o,a,e,g,C);default:return new _(n,o,a,e,g,C,P)}}return Re(r,_)}function rt(){const r={...X};return r.DateTimeFormat=function(...n){const o=new X.DateTimeFormat(...n),a={};return["formatRange","formatRangeToParts","resolvedOptions"].forEach(e=>{a[e]=o[e].bind(o)}),["format","formatToParts"].forEach(e=>{a[e]=function(g){return o[e](g||r.clock.now)}}),a},r.DateTimeFormat.prototype=Object.create(X.DateTimeFormat.prototype),r.DateTimeFormat.supportedLocalesOf=X.DateTimeFormat.supportedLocalesOf,r}function nt(r,n){r.jobs||(r.jobs=[]),r.jobs.push(n)}function G(r){if(r.jobs){for(let n=0;n<r.jobs.length;n++){const o=r.jobs[n];if(o.func.apply(null,o.args),M(r,n),r.loopLimit&&n>r.loopLimit)throw pe(r,o)}re(),r.jobs=[]}}function z(r,n){if(n.func===void 0)throw new Error("Callback must be provided to timer calls");if(m&&typeof n.func!="function")throw new TypeError(`[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${n.func} of type ${typeof n.func}`);if(V&&(n.error=new Error),n.type=n.immediate?"Immediate":"Timeout",n.hasOwnProperty("delay")&&(typeof n.delay!="number"&&(n.delay=parseInt(n.delay,10)),ue(n.delay)||(n.delay=0),n.delay=n.delay>i?1:n.delay,n.delay=Math.max(0,n.delay)),n.hasOwnProperty("interval")&&(n.type="Interval",n.interval=n.interval>i?1:n.interval),n.hasOwnProperty("animation")&&(n.type="AnimationFrame",n.animation=!0),n.hasOwnProperty("idleCallback")&&(n.type="IdleCallback",n.idleCallback=!0),r.timers||(r.timers={}),n.id=O++,n.createdAt=r.now,n.callAt=r.now+(parseInt(n.delay)||(r.duringTick?1:0)),r.timers[n.id]=n,m){const o={refed:!0,ref:function(){return this.refed=!0,o},unref:function(){return this.refed=!1,o},hasRef:function(){return this.refed},refresh:function(){return n.callAt=r.now+(parseInt(n.delay)||(r.duringTick?1:0)),r.timers[n.id]=n,o},[Symbol.toPrimitive]:function(){return n.id}};return o}return n.id}function ye(r,n){if(r.callAt<n.callAt)return-1;if(r.callAt>n.callAt)return 1;if(r.immediate&&!n.immediate)return-1;if(!r.immediate&&n.immediate)return 1;if(r.createdAt<n.createdAt)return-1;if(r.createdAt>n.createdAt)return 1;if(r.id<n.id)return-1;if(r.id>n.id)return 1}function he(r,n,o){const a=r.timers;let e=null,g,C;for(g in a)a.hasOwnProperty(g)&&(C=et(n,o,a[g]),C&&(!e||ye(e,a[g])===1)&&(e=a[g]));return e}function fe(r){const n=r.timers;let o=null,a;for(a in n)n.hasOwnProperty(a)&&(!o||ye(o,n[a])===1)&&(o=n[a]);return o}function De(r){const n=r.timers;let o=null,a;for(a in n)n.hasOwnProperty(a)&&(!o||ye(o,n[a])===-1)&&(o=n[a]);return o}function Te(r,n){if(typeof n.interval=="number"?r.timers[n.id].callAt+=n.interval:delete r.timers[n.id],typeof n.func=="function")n.func.apply(null,n.args);else{const o=eval;(function(){o(n.func)})()}}function $e(r){return r==="IdleCallback"||r==="AnimationFrame"?`cancel${r}`:`clear${r}`}function it(r){return r==="IdleCallback"||r==="AnimationFrame"?`request${r}`:`set${r}`}function ot(){let r=0;return function(n){!r++&&console.warn(n)}}const st=ot();function ne(r,n,o){if(!n)return;r.timers||(r.timers={});const a=Number(n);if(Number.isNaN(a)||a<u){const e=$e(o);if(r.shouldClearNativeTimers===!0){const g=r[`_${e}`];return typeof g=="function"?g(n):void 0}st(`FakeTimers: ${e} was invoked to clear a native timer instead of one created by this library.
To automatically clean-up native timers, use \`shouldClearNativeTimers\`.`)}if(r.timers.hasOwnProperty(a)){const e=r.timers[a];if(e.type===o||e.type==="Timeout"&&o==="Interval"||e.type==="Interval"&&o==="Timeout")delete r.timers[a];else{const g=$e(o),C=it(e.type);throw new Error(`Cannot clear timer: timer created with ${C}() but cleared with ${g}()`)}}}function at(r,n){let o,a,e;const g="_hrtime",C="_nextTick";for(a=0,e=r.methods.length;a<e;a++){if(o=r.methods[a],o==="hrtime"&&t.process)t.process.hrtime=r[g];else if(o==="nextTick"&&t.process)t.process.nextTick=r[C];else if(o==="performance"){const P=Object.getOwnPropertyDescriptor(r,`_${o}`);P&&P.get&&!P.set?Object.defineProperty(t,o,P):P.configurable&&(t[o]=r[`_${o}`])}else if(t[o]&&t[o].hadOwnProperty)t[o]=r[`_${o}`];else try{delete t[o]}catch{}if(r.timersModuleMethods!==void 0)for(let P=0;P<r.timersModuleMethods.length;P++){const q=r.timersModuleMethods[P];ee[q.methodName]=q.original}}return n.shouldAdvanceTime===!0&&t.clearInterval(r.attachedInterval),r.methods=[],r.timers?Object.keys(r.timers).map(function(q){return r.timers[q]}):[]}function we(r,n,o){if(o[n].hadOwnProperty=Object.prototype.hasOwnProperty.call(r,n),o[`_${n}`]=r[n],n==="Date"){const a=Re(o[n],r[n]);r[n]=a}else if(n==="Intl")r[n]=o[n];else if(n==="performance"){const a=Object.getOwnPropertyDescriptor(r,n);if(a&&a.get&&!a.set){Object.defineProperty(o,`_${n}`,a);const e=Object.getOwnPropertyDescriptor(o,n);Object.defineProperty(r,n,e)}else r[n]=o[n]}else r[n]=function(){return o[n].apply(o,arguments)},Object.defineProperties(r[n],Object.getOwnPropertyDescriptors(o[n]));r[n].clock=o}function ct(r,n){r.tick(n)}const F={setTimeout:t.setTimeout,clearTimeout:t.clearTimeout,setInterval:t.setInterval,clearInterval:t.clearInterval,Date:t.Date};$&&(F.setImmediate=t.setImmediate,F.clearImmediate=t.clearImmediate),d&&(F.hrtime=t.process.hrtime),b&&(F.nextTick=t.process.nextTick),s&&(F.performance=t.performance),R&&(F.requestAnimationFrame=t.requestAnimationFrame),j&&(F.queueMicrotask=!0),B&&(F.cancelAnimationFrame=t.cancelAnimationFrame),S&&(F.requestIdleCallback=t.requestIdleCallback),I&&(F.cancelIdleCallback=t.cancelIdleCallback),U&&(F.Intl=t.Intl);const Y=t.setImmediate||t.setTimeout;function qe(r,n){r=Math.floor(Ne(r)),n=n||1e3;let o=0;const a=[0,0];if(_===void 0)throw new Error("The global scope doesn't have a `Date` object (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)");const e={now:r,Date:tt(),loopLimit:n};e.Date.clock=e;function g(){return 16-(e.now-r)%16}function C(T){const f=e.now-a[0]-r,k=Math.floor(f/1e3),v=(f-k*1e3)*1e6+o-a[1];if(Array.isArray(T)){if(T[1]>1e9)throw new TypeError("Number of nanoseconds can't exceed a billion");const E=T[0];let x=v-T[1],Q=k-E;return x<0&&(x+=1e9,Q-=1),[Q,x]}return[k,v]}function P(){const T=C();return T[0]*1e3+T[1]/1e6}h&&(C.bigint=function(){const T=C();return BigInt(T[0])*BigInt(1e9)+BigInt(T[1])}),U&&(e.Intl=rt(),e.Intl.clock=e),e.requestIdleCallback=function(f,k){let v=0;e.countTimers()>0&&(v=50);const E=z(e,{func:f,args:Array.prototype.slice.call(arguments,2),delay:typeof k>"u"?v:Math.min(k,v),idleCallback:!0});return Number(E)},e.cancelIdleCallback=function(f){return ne(e,f,"IdleCallback")},e.setTimeout=function(f,k){return z(e,{func:f,args:Array.prototype.slice.call(arguments,2),delay:k})},typeof t.Promise<"u"&&w&&(e.setTimeout[w.custom]=function(f,k){return new t.Promise(function(E){z(e,{func:E,args:[k],delay:f})})}),e.clearTimeout=function(f){return ne(e,f,"Timeout")},e.nextTick=function(f){return nt(e,{func:f,args:Array.prototype.slice.call(arguments,1),error:V?new Error:null})},e.queueMicrotask=function(f){return e.nextTick(f)},e.setInterval=function(f,k){return k=parseInt(k,10),z(e,{func:f,args:Array.prototype.slice.call(arguments,2),delay:k,interval:k})},e.clearInterval=function(f){return ne(e,f,"Interval")},$&&(e.setImmediate=function(f){return z(e,{func:f,args:Array.prototype.slice.call(arguments,1),immediate:!0})},typeof t.Promise<"u"&&w&&(e.setImmediate[w.custom]=function(f){return new t.Promise(function(v){z(e,{func:v,args:[f],immediate:!0})})}),e.clearImmediate=function(f){return ne(e,f,"Immediate")}),e.countTimers=function(){return Object.keys(e.timers||{}).length+(e.jobs||[]).length},e.requestAnimationFrame=function(f){const k=z(e,{func:f,delay:g(),get args(){return[P()]},animation:!0});return Number(k)},e.cancelAnimationFrame=function(f){return ne(e,f,"AnimationFrame")},e.runMicrotasks=function(){G(e)};function q(T,f,k,v){const E=typeof T=="number"?T:Fe(T),x=Math.floor(E),Q=Ze(E);let le=o+Q,L=e.now+x;if(E<0)throw new TypeError("Negative ticks are not supported");le>=1e6&&(L+=1,le-=1e6),o=le;let J=e.now,ke=e.now,H,Z,N,Le,ve,ge;e.duringTick=!0,N=e.now,G(e),N!==e.now&&(J+=e.now-N,L+=e.now-N);function Be(){for(H=he(e,J,L);H&&J<=L;){if(e.timers[H.id]){J=H.callAt,e.now=H.callAt,N=e.now;try{G(e),Te(e,H)}catch(ie){Z=Z||ie}if(f){Y(Le);return}ve()}ge()}if(N=e.now,G(e),N!==e.now&&(J+=e.now-N,L+=e.now-N),e.duringTick=!1,H=he(e,J,L),H)try{e.tick(L-e.now)}catch(ie){Z=Z||ie}else e.now=L,o=le;if(Z)throw Z;if(f)k(e.now);else return e.now}return Le=f&&function(){try{ve(),ge(),Be()}catch(ie){v(ie)}},ve=function(){N!==e.now&&(J+=e.now-N,L+=e.now-N,ke+=e.now-N)},ge=function(){H=he(e,ke,L),ke=J},Be()}return e.tick=function(f){return q(f,!1)},typeof t.Promise<"u"&&(e.tickAsync=function(f){return new t.Promise(function(k,v){Y(function(){try{q(f,!0,k,v)}catch(E){v(E)}})})}),e.next=function(){G(e);const f=fe(e);if(!f)return e.now;e.duringTick=!0;try{return e.now=f.callAt,Te(e,f),G(e),e.now}finally{e.duringTick=!1}},typeof t.Promise<"u"&&(e.nextAsync=function(){return new t.Promise(function(f,k){Y(function(){try{const v=fe(e);if(!v){f(e.now);return}let E;e.duringTick=!0,e.now=v.callAt;try{Te(e,v)}catch(x){E=x}e.duringTick=!1,Y(function(){E?k(E):f(e.now)})}catch(v){k(v)}})})}),e.runAll=function(){let f,k;for(G(e),k=0;k<e.loopLimit;k++){if(!e.timers||(f=Object.keys(e.timers).length,f===0))return re(),e.now;e.next(),M(e,k)}const v=fe(e);throw pe(e,v)},e.runToFrame=function(){return e.tick(g())},typeof t.Promise<"u"&&(e.runAllAsync=function(){return new t.Promise(function(f,k){let v=0;function E(){Y(function(){try{let x;if(v<e.loopLimit){if(!e.timers){re(),f(e.now);return}if(x=Object.keys(e.timers).length,x===0){re(),f(e.now);return}e.next(),v++,E(),M(e,v);return}const Q=fe(e);k(pe(e,Q))}catch(x){k(x)}})}E()})}),e.runToLast=function(){const f=De(e);return f?e.tick(f.callAt-e.now):(G(e),e.now)},typeof t.Promise<"u"&&(e.runToLastAsync=function(){return new t.Promise(function(f,k){Y(function(){try{const v=De(e);v||f(e.now),f(e.tickAsync(v.callAt-e.now))}catch(v){k(v)}})})}),e.reset=function(){o=0,e.timers={},e.jobs=[],e.now=r},e.setSystemTime=function(f){const k=Ne(f),v=k-e.now;let E,x;a[0]=a[0]+v,a[1]=a[1]+o,e.now=k,o=0;for(E in e.timers)e.timers.hasOwnProperty(E)&&(x=e.timers[E],x.createdAt+=v,x.callAt+=v)},e.jump=function(f){const k=typeof f=="number"?f:Fe(f),v=Math.floor(k);for(const E of Object.values(e.timers))e.now+v>E.callAt&&(E.callAt=e.now+v);e.tick(v)},s&&(e.performance=Object.create(null),e.performance.now=P),d&&(e.hrtime=C),e}function ut(r){if(arguments.length>1||r instanceof Date||Array.isArray(r)||typeof r=="number")throw new TypeError(`FakeTimers.install called with ${String(r)} install requires an object parameter`);if(t.Date.isFake===!0)throw new TypeError("Can't install fake timers twice on the same global object.");if(r=typeof r<"u"?r:{},r.shouldAdvanceTime=r.shouldAdvanceTime||!1,r.advanceTimeDelta=r.advanceTimeDelta||20,r.shouldClearNativeTimers=r.shouldClearNativeTimers||!1,r.target)throw new TypeError("config.target is no longer supported. Use `withGlobal(target)` instead.");let n,o;const a=qe(r.now,r.loopLimit);if(a.shouldClearNativeTimers=r.shouldClearNativeTimers,a.uninstall=function(){return at(a,r)},a.methods=r.toFake||[],a.methods.length===0&&(a.methods=Object.keys(F).filter(function(e){return e!=="nextTick"&&e!=="queueMicrotask"})),r.shouldAdvanceTime===!0){const e=ct.bind(null,a,r.advanceTimeDelta),g=t.setInterval(e,r.advanceTimeDelta);a.attachedInterval=g}if(a.methods.includes("performance")){const e=(()=>{if(A)return t.performance.constructor.prototype;if(p)return t.Performance.prototype})();if(e)Object.getOwnPropertyNames(e).forEach(function(g){g!=="now"&&(a.performance[g]=g.indexOf("getEntries")===0?y:l)});else if((r.toFake||[]).includes("performance"))throw new ReferenceError("non-existent performance object cannot be faked")}for(t===Ye&&ee&&(a.timersModuleMethods=[]),n=0,o=a.methods.length;n<o;n++){const e=a.methods[n];if(e==="hrtime"?t.process&&typeof t.process.hrtime=="function"&&we(t.process,e,a):e==="nextTick"?t.process&&typeof t.process.nextTick=="function"&&we(t.process,e,a):we(t,e,a),a.timersModuleMethods!==void 0&&ee[e]){const g=ee[e];a.timersModuleMethods.push({methodName:e,original:g}),ee[e]=t[e]}}return a}return{timers:F,createClock:qe,install:ut,withGlobal:je}}const _e=je(Ye);_e.timers;_e.createClock;_e.install;var or=je;class sr{constructor({global:i,config:u}){W(this,"_global");W(this,"_clock");W(this,"_fakingTime");W(this,"_fakingDate");W(this,"_fakeTimers");W(this,"_userConfig");W(this,"_now",D.now);this._userConfig=u,this._fakingDate=!1,this._fakingTime=!1,this._fakeTimers=or(i),this._global=i}clearAllTimers(){this._fakingTime&&this._clock.reset()}dispose(){this.useRealTimers()}runAllTimers(){this._checkFakeTimers()&&this._clock.runAll()}async runAllTimersAsync(){this._checkFakeTimers()&&await this._clock.runAllAsync()}runOnlyPendingTimers(){this._checkFakeTimers()&&this._clock.runToLast()}async runOnlyPendingTimersAsync(){this._checkFakeTimers()&&await this._clock.runToLastAsync()}advanceTimersToNextTimer(i=1){if(this._checkFakeTimers())for(let u=i;u>0&&(this._clock.next(),this._clock.tick(0),this._clock.countTimers()!==0);u--);}async advanceTimersToNextTimerAsync(i=1){if(this._checkFakeTimers())for(let u=i;u>0&&(await this._clock.nextAsync(),this._clock.tick(0),this._clock.countTimers()!==0);u--);}advanceTimersByTime(i){this._checkFakeTimers()&&this._clock.tick(i)}async advanceTimersByTimeAsync(i){this._checkFakeTimers()&&await this._clock.tickAsync(i)}runAllTicks(){this._checkFakeTimers()&&this._clock.runMicrotasks()}useRealTimers(){this._fakingDate&&(_t(),this._fakingDate=!1),this._fakingTime&&(this._clock.uninstall(),this._fakingTime=!1)}useFakeTimers(){var i,u,l;if(this._fakingDate)throw new Error('"setSystemTime" was called already and date was mocked. Reset timers using `vi.useRealTimers()` if you want to use fake timers again.');if(!this._fakingTime){const y=Object.keys(this._fakeTimers.timers).filter(m=>m!=="nextTick");if((u=(i=this._userConfig)==null?void 0:i.toFake)!=null&&u.includes("nextTick")&&Ke())throw new Error("process.nextTick cannot be mocked inside child_process");const c=(((l=this._userConfig)==null?void 0:l.toFake)||y).filter(m=>{switch(m){case"setImmediate":case"clearImmediate":return m in this._global&&this._global[m];default:return!0}});this._clock=this._fakeTimers.install({now:Date.now(),...this._userConfig,toFake:c}),this._fakingTime=!0}}reset(){if(this._checkFakeTimers()){const{now:i}=this._clock;this._clock.reset(),this._clock.setSystemTime(i)}}setSystemTime(i){this._fakingTime?this._clock.setSystemTime(i):(jt(i??this.getRealSystemTime()),this._fakingDate=!0)}getRealSystemTime(){return this._now()}getTimerCount(){return this._checkFakeTimers()?this._clock.countTimers():0}configure(i){this._userConfig=i}isFakeTimers(){return this._fakingTime}_checkFakeTimers(){if(!this._fakingTime)throw new Error('Timers are not mocked. Try calling "vi.useFakeTimers()" first.');return this._fakingTime}}function Qe(t,i){return i.stack!==void 0&&(t.stack=i.stack.replace(i.message,t.message)),t}function ar(t,i={}){const{setTimeout:u,setInterval:l,clearTimeout:y,clearInterval:c}=Me(),{interval:m=50,timeout:d=1e3}=typeof i=="number"?{timeout:i}:i,h=new Error("STACK_TRACE_ERROR");return new Promise((b,w)=>{let s,p="idle",A,j;const R=I=>{A&&y(A),j&&c(j),b(I)},B=()=>{let I=s;I||(I=Qe(new Error("Timed out in waitFor!"),h)),w(I)},S=()=>{if(de.isFakeTimers()&&de.advanceTimersByTime(m),p!=="pending")try{const I=t();if(I!==null&&typeof I=="object"&&typeof I.then=="function"){const $=I;p="pending",$.then(U=>{p="resolved",R(U)},U=>{p="rejected",s=U})}else return R(I),!0}catch(I){s=I}};S()!==!0&&(A=u(B,d),j=l(S,m))})}function cr(t,i={}){const{setTimeout:u,setInterval:l,clearTimeout:y,clearInterval:c}=Me(),{interval:m=50,timeout:d=1e3}=typeof i=="number"?{timeout:i}:i,h=new Error("STACK_TRACE_ERROR");return new Promise((b,w)=>{let s="idle",p,A;const j=S=>{S||(S=Qe(new Error("Timed out in waitUntil!"),h)),w(S)},R=S=>{if(S)return p&&y(p),A&&c(A),b(S),!0},B=()=>{if(de.isFakeTimers()&&de.advanceTimersByTime(m),s!=="pending")try{const S=t();if(S!==null&&typeof S=="object"&&typeof S.then=="function"){const I=S;s="pending",I.then($=>{s="resolved",R($)},$=>{s="rejected",j($)})}else return R(S)}catch(S){j(S)}};B()!==!0&&(p=u(j,d),A=l(B,m))})}function ur(){const t=typeof __vitest_mocker__<"u"?__vitest_mocker__:new Proxy({},{get(s,p){throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(p)}() is forbidden.`)}});let i=null,u=null;const l=Ce();let y;const c=()=>y||(y=new sr({global:globalThis,config:l.config.fakeTimers})),m=new Map,d=new Map,h=["PROD","DEV","SSR"],b=()=>{const p=St({stackTraceLimit:4}).split(`
`)[4],A=It(p);return(A==null?void 0:A.file)||""},w={useFakeTimers(s){var p,A,j,R;if(Ke()&&((p=s==null?void 0:s.toFake)!=null&&p.includes("nextTick")||(R=(j=(A=l.config)==null?void 0:A.fakeTimers)==null?void 0:j.toFake)!=null&&R.includes("nextTick")))throw new Error('vi.useFakeTimers({ toFake: ["nextTick"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.');return s?c().configure({...l.config.fakeTimers,...s}):c().configure(l.config.fakeTimers),c().useFakeTimers(),w},isFakeTimers(){return c().isFakeTimers()},useRealTimers(){return c().useRealTimers(),i=null,w},runOnlyPendingTimers(){return c().runOnlyPendingTimers(),w},async runOnlyPendingTimersAsync(){return await c().runOnlyPendingTimersAsync(),w},runAllTimers(){return c().runAllTimers(),w},async runAllTimersAsync(){return await c().runAllTimersAsync(),w},runAllTicks(){return c().runAllTicks(),w},advanceTimersByTime(s){return c().advanceTimersByTime(s),w},async advanceTimersByTimeAsync(s){return await c().advanceTimersByTimeAsync(s),w},advanceTimersToNextTimer(){return c().advanceTimersToNextTimer(),w},async advanceTimersToNextTimerAsync(){return await c().advanceTimersToNextTimerAsync(),w},getTimerCount(){return c().getTimerCount()},setSystemTime(s){const p=s instanceof Date?s:new Date(s);return i=p,c().setSystemTime(p),w},getMockedSystemTime(){return i},getRealSystemTime(){return c().getRealSystemTime()},clearAllTimers(){return c().clearAllTimers(),w},spyOn:Ot,fn:Pt,waitFor:ar,waitUntil:cr,hoisted(s){return Et(s,'"vi.hoisted" factory',["function"]),s()},mock(s,p){const A=b();t.queueMock(s,A,p?()=>p(()=>t.importActual(s,A,t.getMockContext().callstack)):void 0,!0)},unmock(s){t.queueUnmock(s,b())},doMock(s,p){const A=b();t.queueMock(s,A,p?()=>p(()=>t.importActual(s,A,t.getMockContext().callstack)):void 0,!1)},doUnmock(s){t.queueUnmock(s,b())},async importActual(s){return t.importActual(s,b(),t.getMockContext().callstack)},async importMock(s){return t.importMock(s,b())},mocked(s,p={}){return s},isMockFunction(s){return Mt(s)},clearAllMocks(){return Se.forEach(s=>s.mockClear()),w},resetAllMocks(){return Se.forEach(s=>s.mockReset()),w},restoreAllMocks(){return Se.forEach(s=>s.mockRestore()),w},stubGlobal(s,p){return m.has(s)||m.set(s,Object.getOwnPropertyDescriptor(globalThis,s)),Object.defineProperty(globalThis,s,{value:p,writable:!0,configurable:!0,enumerable:!0}),w},stubEnv(s,p){return d.has(s)||d.set(s,oe[s]),h.includes(s)?oe[s]=p?"1":"":oe[s]=String(p),w},unstubAllGlobals(){return m.forEach((s,p)=>{s?Object.defineProperty(globalThis,p,s):Reflect.deleteProperty(globalThis,p)}),m.clear(),w},unstubAllEnvs(){return d.forEach((s,p)=>{s===void 0?delete oe[p]:oe[p]=s}),d.clear(),w},resetModules(){return Ft(l.moduleCache),w},async dynamicImportSettled(){return Ve()},setConfig(s){u||(u={...l.config}),Object.assign(l.config,s)},resetConfig(){u&&Object.assign(l.config,u)}};return w}const fr=ur(),de=fr;export{Jt as g};
//# sourceMappingURL=vitest-B0SOb4OC.js.map

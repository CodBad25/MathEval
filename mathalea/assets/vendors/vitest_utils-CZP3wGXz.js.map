{"version":3,"file":"vitest_utils-CZP3wGXz.js","sources":["../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/helpers.js","../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/chunk-display.js","../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/chunk-colors.js","../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/index.js","../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/diff.js","../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/error.js","../../../node_modules/.pnpm/@vitest+utils@1.6.1/node_modules/@vitest/utils/dist/source-map.js"],"sourcesContent":["function notNullish(v) {\n  return v != null;\n}\nfunction assertTypes(value, name, types) {\n  const receivedType = typeof value;\n  const pass = types.includes(receivedType);\n  if (!pass)\n    throw new TypeError(`${name} value must be ${types.join(\" or \")}, received \"${receivedType}\"`);\n}\nfunction isPrimitive(value) {\n  return value === null || typeof value !== \"function\" && typeof value !== \"object\";\n}\nfunction slash(path) {\n  return path.replace(/\\\\/g, \"/\");\n}\nfunction parseRegexp(input) {\n  const m = input.match(/(\\/?)(.+)\\1([a-z]*)/i);\n  if (!m)\n    return /$^/;\n  if (m[3] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(m[3]))\n    return RegExp(input);\n  return new RegExp(m[2], m[3]);\n}\nfunction toArray(array) {\n  if (array === null || array === void 0)\n    array = [];\n  if (Array.isArray(array))\n    return array;\n  return [array];\n}\nfunction isObject(item) {\n  return item != null && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction isFinalObj(obj) {\n  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;\n}\nfunction getType(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\nfunction collectOwnProperties(obj, collector) {\n  const collect = typeof collector === \"function\" ? collector : (key) => collector.add(key);\n  Object.getOwnPropertyNames(obj).forEach(collect);\n  Object.getOwnPropertySymbols(obj).forEach(collect);\n}\nfunction getOwnProperties(obj) {\n  const ownProps = /* @__PURE__ */ new Set();\n  if (isFinalObj(obj))\n    return [];\n  collectOwnProperties(obj, ownProps);\n  return Array.from(ownProps);\n}\nconst defaultCloneOptions = { forceWritable: false };\nfunction deepClone(val, options = defaultCloneOptions) {\n  const seen = /* @__PURE__ */ new WeakMap();\n  return clone(val, seen, options);\n}\nfunction clone(val, seen, options = defaultCloneOptions) {\n  let k, out;\n  if (seen.has(val))\n    return seen.get(val);\n  if (Array.isArray(val)) {\n    out = Array(k = val.length);\n    seen.set(val, out);\n    while (k--)\n      out[k] = clone(val[k], seen, options);\n    return out;\n  }\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    out = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, out);\n    const props = getOwnProperties(val);\n    for (const k2 of props) {\n      const descriptor = Object.getOwnPropertyDescriptor(val, k2);\n      if (!descriptor)\n        continue;\n      const cloned = clone(val[k2], seen, options);\n      if (options.forceWritable) {\n        Object.defineProperty(out, k2, {\n          enumerable: descriptor.enumerable,\n          configurable: true,\n          writable: true,\n          value: cloned\n        });\n      } else if (\"get\" in descriptor) {\n        Object.defineProperty(out, k2, {\n          ...descriptor,\n          get() {\n            return cloned;\n          }\n        });\n      } else {\n        Object.defineProperty(out, k2, {\n          ...descriptor,\n          value: cloned\n        });\n      }\n    }\n    return out;\n  }\n  return val;\n}\nfunction noop() {\n}\nfunction objectAttr(source, path, defaultValue = void 0) {\n  const paths = path.replace(/\\[(\\d+)\\]/g, \".$1\").split(\".\");\n  let result = source;\n  for (const p of paths) {\n    result = Object(result)[p];\n    if (result === void 0)\n      return defaultValue;\n  }\n  return result;\n}\nfunction createDefer() {\n  let resolve = null;\n  let reject = null;\n  const p = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  p.resolve = resolve;\n  p.reject = reject;\n  return p;\n}\nfunction getCallLastIndex(code) {\n  let charIndex = -1;\n  let inString = null;\n  let startedBracers = 0;\n  let endedBracers = 0;\n  let beforeChar = null;\n  while (charIndex <= code.length) {\n    beforeChar = code[charIndex];\n    charIndex++;\n    const char = code[charIndex];\n    const isCharString = char === '\"' || char === \"'\" || char === \"`\";\n    if (isCharString && beforeChar !== \"\\\\\") {\n      if (inString === char)\n        inString = null;\n      else if (!inString)\n        inString = char;\n    }\n    if (!inString) {\n      if (char === \"(\")\n        startedBracers++;\n      if (char === \")\")\n        endedBracers++;\n    }\n    if (startedBracers && endedBracers && startedBracers === endedBracers)\n      return charIndex;\n  }\n  return null;\n}\n\nexport { assertTypes, clone, createDefer, deepClone, getCallLastIndex, getOwnProperties, getType, isObject, isPrimitive, noop, notNullish, objectAttr, parseRegexp, slash, toArray };\n","import { format as format$1, plugins } from 'pretty-format';\nimport * as loupe from 'loupe';\n\nconst {\n  AsymmetricMatcher,\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent\n} = plugins;\nconst PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher\n];\nfunction stringify(object, maxDepth = 10, { maxLength, ...options } = {}) {\n  const MAX_LENGTH = maxLength ?? 1e4;\n  let result;\n  try {\n    result = format$1(object, {\n      maxDepth,\n      escapeString: false,\n      // min: true,\n      plugins: PLUGINS,\n      ...options\n    });\n  } catch {\n    result = format$1(object, {\n      callToJSON: false,\n      maxDepth,\n      escapeString: false,\n      // min: true,\n      plugins: PLUGINS,\n      ...options\n    });\n  }\n  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(maxDepth / 2)) : result;\n}\n\nconst formatRegExp = /%[sdjifoOcj%]/g;\nfunction format(...args) {\n  if (typeof args[0] !== \"string\") {\n    const objects = [];\n    for (let i2 = 0; i2 < args.length; i2++)\n      objects.push(inspect(args[i2], { depth: 0, colors: false, compact: 3 }));\n    return objects.join(\" \");\n  }\n  const len = args.length;\n  let i = 1;\n  const template = args[0];\n  let str = String(template).replace(formatRegExp, (x) => {\n    if (x === \"%%\")\n      return \"%\";\n    if (i >= len)\n      return x;\n    switch (x) {\n      case \"%s\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\")\n          return `${value.toString()}n`;\n        if (typeof value === \"number\" && value === 0 && 1 / value < 0)\n          return \"-0\";\n        if (typeof value === \"object\" && value !== null)\n          return inspect(value, { depth: 0, colors: false, compact: 3 });\n        return String(value);\n      }\n      case \"%d\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\")\n          return `${value.toString()}n`;\n        return Number(value).toString();\n      }\n      case \"%i\": {\n        const value = args[i++];\n        if (typeof value === \"bigint\")\n          return `${value.toString()}n`;\n        return Number.parseInt(String(value)).toString();\n      }\n      case \"%f\":\n        return Number.parseFloat(String(args[i++])).toString();\n      case \"%o\":\n        return inspect(args[i++], { showHidden: true, showProxy: true });\n      case \"%O\":\n        return inspect(args[i++]);\n      case \"%c\": {\n        i++;\n        return \"\";\n      }\n      case \"%j\":\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (err) {\n          const m = err.message;\n          if (\n            // chromium\n            m.includes(\"circular structure\") || m.includes(\"cyclic structures\") || m.includes(\"cyclic object\")\n          )\n            return \"[Circular]\";\n          throw err;\n        }\n      default:\n        return x;\n    }\n  });\n  for (let x = args[i]; i < len; x = args[++i]) {\n    if (x === null || typeof x !== \"object\")\n      str += ` ${x}`;\n    else\n      str += ` ${inspect(x)}`;\n  }\n  return str;\n}\nfunction inspect(obj, options = {}) {\n  if (options.truncate === 0)\n    options.truncate = Number.POSITIVE_INFINITY;\n  return loupe.inspect(obj, options);\n}\nfunction objDisplay(obj, options = {}) {\n  if (typeof options.truncate === \"undefined\")\n    options.truncate = 40;\n  const str = inspect(obj, options);\n  const type = Object.prototype.toString.call(obj);\n  if (options.truncate && str.length >= options.truncate) {\n    if (type === \"[object Function]\") {\n      const fn = obj;\n      return !fn.name ? \"[Function]\" : `[Function: ${fn.name}]`;\n    } else if (type === \"[object Array]\") {\n      return `[ Array(${obj.length}) ]`;\n    } else if (type === \"[object Object]\") {\n      const keys = Object.keys(obj);\n      const kstr = keys.length > 2 ? `${keys.splice(0, 2).join(\", \")}, ...` : keys.join(\", \");\n      return `{ Object (${kstr}) }`;\n    } else {\n      return str;\n    }\n  }\n  return str;\n}\n\nexport { format as f, inspect as i, objDisplay as o, stringify as s };\n","const SAFE_TIMERS_SYMBOL = Symbol(\"vitest:SAFE_TIMERS\");\nconst SAFE_COLORS_SYMBOL = Symbol(\"vitest:SAFE_COLORS\");\n\nconst colorsMap = {\n  bold: [\"\\x1B[1m\", \"\\x1B[22m\", \"\\x1B[22m\\x1B[1m\"],\n  dim: [\"\\x1B[2m\", \"\\x1B[22m\", \"\\x1B[22m\\x1B[2m\"],\n  italic: [\"\\x1B[3m\", \"\\x1B[23m\"],\n  underline: [\"\\x1B[4m\", \"\\x1B[24m\"],\n  inverse: [\"\\x1B[7m\", \"\\x1B[27m\"],\n  hidden: [\"\\x1B[8m\", \"\\x1B[28m\"],\n  strikethrough: [\"\\x1B[9m\", \"\\x1B[29m\"],\n  black: [\"\\x1B[30m\", \"\\x1B[39m\"],\n  red: [\"\\x1B[31m\", \"\\x1B[39m\"],\n  green: [\"\\x1B[32m\", \"\\x1B[39m\"],\n  yellow: [\"\\x1B[33m\", \"\\x1B[39m\"],\n  blue: [\"\\x1B[34m\", \"\\x1B[39m\"],\n  magenta: [\"\\x1B[35m\", \"\\x1B[39m\"],\n  cyan: [\"\\x1B[36m\", \"\\x1B[39m\"],\n  white: [\"\\x1B[37m\", \"\\x1B[39m\"],\n  gray: [\"\\x1B[90m\", \"\\x1B[39m\"],\n  bgBlack: [\"\\x1B[40m\", \"\\x1B[49m\"],\n  bgRed: [\"\\x1B[41m\", \"\\x1B[49m\"],\n  bgGreen: [\"\\x1B[42m\", \"\\x1B[49m\"],\n  bgYellow: [\"\\x1B[43m\", \"\\x1B[49m\"],\n  bgBlue: [\"\\x1B[44m\", \"\\x1B[49m\"],\n  bgMagenta: [\"\\x1B[45m\", \"\\x1B[49m\"],\n  bgCyan: [\"\\x1B[46m\", \"\\x1B[49m\"],\n  bgWhite: [\"\\x1B[47m\", \"\\x1B[49m\"]\n};\nconst colorsEntries = Object.entries(colorsMap);\nfunction string(str) {\n  return String(str);\n}\nstring.open = \"\";\nstring.close = \"\";\nconst defaultColors = /* @__PURE__ */ colorsEntries.reduce((acc, [key]) => {\n  acc[key] = string;\n  return acc;\n}, { isColorSupported: false });\nfunction getDefaultColors() {\n  return { ...defaultColors };\n}\nfunction getColors() {\n  return globalThis[SAFE_COLORS_SYMBOL] || defaultColors;\n}\nfunction createColors(isTTY = false) {\n  const enabled = typeof process !== \"undefined\" && !(\"NO_COLOR\" in process.env || process.argv.includes(\"--no-color\")) && !(\"GITHUB_ACTIONS\" in process.env) && (\"FORCE_COLOR\" in process.env || process.argv.includes(\"--color\") || process.platform === \"win32\" || isTTY && process.env.TERM !== \"dumb\" || \"CI\" in process.env);\n  const replaceClose = (string2, close, replace, index) => {\n    const start = string2.substring(0, index) + replace;\n    const end = string2.substring(index + close.length);\n    const nextIndex = end.indexOf(close);\n    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;\n  };\n  const formatter = (open, close, replace = open) => {\n    const fn = (input) => {\n      const string2 = String(input);\n      const index = string2.indexOf(close, open.length);\n      return ~index ? open + replaceClose(string2, close, replace, index) + close : open + string2 + close;\n    };\n    fn.open = open;\n    fn.close = close;\n    return fn;\n  };\n  const colorsObject = {\n    isColorSupported: enabled,\n    reset: enabled ? (s) => `\\x1B[0m${s}\\x1B[0m` : string\n  };\n  for (const [name, formatterArgs] of colorsEntries) {\n    colorsObject[name] = enabled ? formatter(...formatterArgs) : string;\n  }\n  return colorsObject;\n}\nfunction setupColors(colors) {\n  globalThis[SAFE_COLORS_SYMBOL] = colors;\n}\n\nexport { SAFE_TIMERS_SYMBOL as S, SAFE_COLORS_SYMBOL as a, getDefaultColors as b, createColors as c, getColors as g, setupColors as s };\n","export { assertTypes, clone, createDefer, deepClone, getCallLastIndex, getOwnProperties, getType, isObject, isPrimitive, noop, notNullish, objectAttr, parseRegexp, slash, toArray } from './helpers.js';\nexport { f as format, i as inspect, o as objDisplay, s as stringify } from './chunk-display.js';\nimport { S as SAFE_TIMERS_SYMBOL, g as getColors } from './chunk-colors.js';\nexport { a as SAFE_COLORS_SYMBOL, c as createColors, b as getDefaultColors, s as setupColors } from './chunk-colors.js';\nimport 'pretty-format';\nimport 'loupe';\n\nfunction getSafeTimers() {\n  const {\n    setTimeout: safeSetTimeout,\n    setInterval: safeSetInterval,\n    clearInterval: safeClearInterval,\n    clearTimeout: safeClearTimeout,\n    setImmediate: safeSetImmediate,\n    clearImmediate: safeClearImmediate\n  } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis;\n  const {\n    nextTick: safeNextTick\n  } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis.process || { nextTick: (cb) => cb() };\n  return {\n    nextTick: safeNextTick,\n    setTimeout: safeSetTimeout,\n    setInterval: safeSetInterval,\n    clearInterval: safeClearInterval,\n    clearTimeout: safeClearTimeout,\n    setImmediate: safeSetImmediate,\n    clearImmediate: safeClearImmediate\n  };\n}\nfunction setSafeTimers() {\n  const {\n    setTimeout: safeSetTimeout,\n    setInterval: safeSetInterval,\n    clearInterval: safeClearInterval,\n    clearTimeout: safeClearTimeout,\n    setImmediate: safeSetImmediate,\n    clearImmediate: safeClearImmediate\n  } = globalThis;\n  const {\n    nextTick: safeNextTick\n  } = globalThis.process || { nextTick: (cb) => cb() };\n  const timers = {\n    nextTick: safeNextTick,\n    setTimeout: safeSetTimeout,\n    setInterval: safeSetInterval,\n    clearInterval: safeClearInterval,\n    clearTimeout: safeClearTimeout,\n    setImmediate: safeSetImmediate,\n    clearImmediate: safeClearImmediate\n  };\n  globalThis[SAFE_TIMERS_SYMBOL] = timers;\n}\n\nconst RealDate = Date;\nfunction random(seed) {\n  const x = Math.sin(seed++) * 1e4;\n  return x - Math.floor(x);\n}\nfunction shuffle(array, seed = RealDate.now()) {\n  let length = array.length;\n  while (length) {\n    const index = Math.floor(random(seed) * length--);\n    const previous = array[length];\n    array[length] = array[index];\n    array[index] = previous;\n    ++seed;\n  }\n  return array;\n}\n\nfunction createSimpleStackTrace(options) {\n  const { message = \"error\", stackTraceLimit = 1 } = options || {};\n  const limit = Error.stackTraceLimit;\n  const prepareStackTrace = Error.prepareStackTrace;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = (e) => e.stack;\n  const err = new Error(message);\n  const stackTrace = err.stack || \"\";\n  Error.prepareStackTrace = prepareStackTrace;\n  Error.stackTraceLimit = limit;\n  return stackTrace;\n}\n\nconst lineSplitRE = /\\r?\\n/;\nfunction positionToOffset(source, lineNumber, columnNumber) {\n  const lines = source.split(lineSplitRE);\n  const nl = /\\r\\n/.test(source) ? 2 : 1;\n  let start = 0;\n  if (lineNumber > lines.length)\n    return source.length;\n  for (let i = 0; i < lineNumber - 1; i++)\n    start += lines[i].length + nl;\n  return start + columnNumber;\n}\nfunction offsetToLineNumber(source, offset) {\n  if (offset > source.length) {\n    throw new Error(\n      `offset is longer than source length! offset ${offset} > length ${source.length}`\n    );\n  }\n  const lines = source.split(lineSplitRE);\n  const nl = /\\r\\n/.test(source) ? 2 : 1;\n  let counted = 0;\n  let line = 0;\n  for (; line < lines.length; line++) {\n    const lineLength = lines[line].length + nl;\n    if (counted + lineLength >= offset)\n      break;\n    counted += lineLength;\n  }\n  return line + 1;\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell\n// License: MIT.\nvar Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;\nRegularExpressionLiteral = /\\/(?![*\\/])(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\\\]).|\\\\.)*(\\/[$_\\u200C\\u200D\\p{ID_Continue}]*|\\\\)?/yu;\nPunctuator = /--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]/y;\nIdentifier = /(\\x23?)(?=[$_\\p{ID_Start}\\\\])(?:[$_\\u200C\\u200D\\p{ID_Continue}]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+/yu;\nStringLiteral = /(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?/y;\nNumericLiteral = /(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+/y;\nTemplate = /[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?/y;\nWhiteSpace = /[\\t\\v\\f\\ufeff\\p{Zs}]+/yu;\nLineTerminatorSequence = /\\r?\\n|[\\r\\u2028\\u2029]/y;\nMultiLineComment = /\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?/y;\nSingleLineComment = /\\/\\/.*/y;\nJSXPunctuator = /[<>.:={}]|\\/(?![\\/*])/y;\nJSXIdentifier = /[$_\\p{ID_Start}][$_\\u200C\\u200D\\p{ID_Continue}-]*/yu;\nJSXString = /(['\"])(?:(?!\\1)[^])*(\\1)?/y;\nJSXText = /[^<>{}]+/y;\nTokensPrecedingExpression = /^(?:[\\/+-]|\\.{3}|\\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;\nTokensNotPrecedingObjectLiteral = /^(?:=>|[;\\]){}]|else|\\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;\nKeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;\nKeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;\nNewline = RegExp(LineTerminatorSequence.source);\nvar jsTokens_1 = function*(input, {jsx = false} = {}) {\n\tvar braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;\n\t({length} = input);\n\tlastIndex = 0;\n\tlastSignificantToken = \"\";\n\tstack = [\n\t\t{tag: \"JS\"}\n\t];\n\tbraces = [];\n\tparenNesting = 0;\n\tpostfixIncDec = false;\n\twhile (lastIndex < length) {\n\t\tmode = stack[stack.length - 1];\n\t\tswitch (mode.tag) {\n\t\t\tcase \"JS\":\n\t\t\tcase \"JSNonExpressionParen\":\n\t\t\tcase \"InterpolationInTemplate\":\n\t\t\tcase \"InterpolationInJSX\":\n\t\t\t\tif (input[lastIndex] === \"/\" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n\t\t\t\t\tRegularExpressionLiteral.lastIndex = lastIndex;\n\t\t\t\t\tif (match = RegularExpressionLiteral.exec(input)) {\n\t\t\t\t\t\tlastIndex = RegularExpressionLiteral.lastIndex;\n\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"RegularExpressionLiteral\",\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tclosed: match[1] !== void 0 && match[1] !== \"\\\\\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPunctuator.lastIndex = lastIndex;\n\t\t\t\tif (match = Punctuator.exec(input)) {\n\t\t\t\t\tpunctuator = match[0];\n\t\t\t\t\tnextLastIndex = Punctuator.lastIndex;\n\t\t\t\t\tnextLastSignificantToken = punctuator;\n\t\t\t\t\tswitch (punctuator) {\n\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\tif (lastSignificantToken === \"?NonExpressionParenKeyword\") {\n\t\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\t\ttag: \"JSNonExpressionParen\",\n\t\t\t\t\t\t\t\t\tnesting: parenNesting\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparenNesting++;\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\tparenNesting--;\n\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\tif (mode.tag === \"JSNonExpressionParen\" && parenNesting === mode.nesting) {\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?NonExpressionParenEnd\";\n\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\tPunctuator.lastIndex = 0;\n\t\t\t\t\t\t\tisExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));\n\t\t\t\t\t\t\tbraces.push(isExpression);\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"}\":\n\t\t\t\t\t\t\tswitch (mode.tag) {\n\t\t\t\t\t\t\t\tcase \"InterpolationInTemplate\":\n\t\t\t\t\t\t\t\t\tif (braces.length === mode.nesting) {\n\t\t\t\t\t\t\t\t\t\tTemplate.lastIndex = lastIndex;\n\t\t\t\t\t\t\t\t\t\tmatch = Template.exec(input);\n\t\t\t\t\t\t\t\t\t\tlastIndex = Template.lastIndex;\n\t\t\t\t\t\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\t\t\t\t\t\tif (match[1] === \"${\") {\n\t\t\t\t\t\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInTemplate\";\n\t\t\t\t\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"TemplateMiddle\",\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"TemplateTail\",\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\t\t\t\t\t\tclosed: match[1] === \"`\"\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"InterpolationInJSX\":\n\t\t\t\t\t\t\t\t\tif (braces.length === mode.nesting) {\n\t\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t\t\tlastIndex += 1;\n\t\t\t\t\t\t\t\t\t\tlastSignificantToken = \"}\";\n\t\t\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: \"}\"\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostfixIncDec = braces.pop();\n\t\t\t\t\t\t\tnextLastSignificantToken = postfixIncDec ? \"?ExpressionBraceEnd\" : \"}\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"]\":\n\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"++\":\n\t\t\t\t\t\tcase \"--\":\n\t\t\t\t\t\t\tnextLastSignificantToken = postfixIncDec ? \"?PostfixIncDec\" : \"?UnaryIncDec\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tif (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {\n\t\t\t\t\t\t\t\tstack.push({tag: \"JSXTag\"});\n\t\t\t\t\t\t\t\tlastIndex += 1;\n\t\t\t\t\t\t\t\tlastSignificantToken = \"<\";\n\t\t\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\t\t\tvalue: punctuator\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t}\n\t\t\t\t\tlastIndex = nextLastIndex;\n\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"Punctuator\",\n\t\t\t\t\t\tvalue: punctuator\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tIdentifier.lastIndex = lastIndex;\n\t\t\t\tif (match = Identifier.exec(input)) {\n\t\t\t\t\tlastIndex = Identifier.lastIndex;\n\t\t\t\t\tnextLastSignificantToken = match[0];\n\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\tcase \"for\":\n\t\t\t\t\t\tcase \"if\":\n\t\t\t\t\t\tcase \"while\":\n\t\t\t\t\t\tcase \"with\":\n\t\t\t\t\t\t\tif (lastSignificantToken !== \".\" && lastSignificantToken !== \"?.\") {\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?NonExpressionParenKeyword\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\tpostfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: match[1] === \"#\" ? \"PrivateIdentifier\" : \"IdentifierName\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tStringLiteral.lastIndex = lastIndex;\n\t\t\t\tif (match = StringLiteral.exec(input)) {\n\t\t\t\t\tlastIndex = StringLiteral.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"StringLiteral\",\n\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\tclosed: match[2] !== void 0\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNumericLiteral.lastIndex = lastIndex;\n\t\t\t\tif (match = NumericLiteral.exec(input)) {\n\t\t\t\t\tlastIndex = NumericLiteral.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"NumericLiteral\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tTemplate.lastIndex = lastIndex;\n\t\t\t\tif (match = Template.exec(input)) {\n\t\t\t\t\tlastIndex = Template.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tif (match[1] === \"${\") {\n\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInTemplate\";\n\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\ttag: \"InterpolationInTemplate\",\n\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"TemplateHead\",\n\t\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"NoSubstitutionTemplate\",\n\t\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\t\tclosed: match[1] === \"`\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"JSXTag\":\n\t\t\tcase \"JSXTagEnd\":\n\t\t\t\tJSXPunctuator.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXPunctuator.exec(input)) {\n\t\t\t\t\tlastIndex = JSXPunctuator.lastIndex;\n\t\t\t\t\tnextLastSignificantToken = match[0];\n\t\t\t\t\tswitch (match[0]) {\n\t\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\t\tstack.push({tag: \"JSXTag\"});\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \">\":\n\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\tif (lastSignificantToken === \"/\" || mode.tag === \"JSXTagEnd\") {\n\t\t\t\t\t\t\t\tnextLastSignificantToken = \"?JSX\";\n\t\t\t\t\t\t\t\tpostfixIncDec = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstack.push({tag: \"JSXChildren\"});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\ttag: \"InterpolationInJSX\",\n\t\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tnextLastSignificantToken = \"?InterpolationInJSX\";\n\t\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\t\tif (lastSignificantToken === \"<\") {\n\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\tif (stack[stack.length - 1].tag === \"JSXChildren\") {\n\t\t\t\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstack.push({tag: \"JSXTagEnd\"});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastSignificantToken = nextLastSignificantToken;\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tJSXIdentifier.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXIdentifier.exec(input)) {\n\t\t\t\t\tlastIndex = JSXIdentifier.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXIdentifier\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tJSXString.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXString.exec(input)) {\n\t\t\t\t\tlastIndex = JSXString.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXString\",\n\t\t\t\t\t\tvalue: match[0],\n\t\t\t\t\t\tclosed: match[2] !== void 0\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"JSXChildren\":\n\t\t\t\tJSXText.lastIndex = lastIndex;\n\t\t\t\tif (match = JSXText.exec(input)) {\n\t\t\t\t\tlastIndex = JSXText.lastIndex;\n\t\t\t\t\tlastSignificantToken = match[0];\n\t\t\t\t\tyield ({\n\t\t\t\t\t\ttype: \"JSXText\",\n\t\t\t\t\t\tvalue: match[0]\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tswitch (input[lastIndex]) {\n\t\t\t\t\tcase \"<\":\n\t\t\t\t\t\tstack.push({tag: \"JSXTag\"});\n\t\t\t\t\t\tlastIndex++;\n\t\t\t\t\t\tlastSignificantToken = \"<\";\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\tvalue: \"<\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase \"{\":\n\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\ttag: \"InterpolationInJSX\",\n\t\t\t\t\t\t\tnesting: braces.length\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlastIndex++;\n\t\t\t\t\t\tlastSignificantToken = \"?InterpolationInJSX\";\n\t\t\t\t\t\tpostfixIncDec = false;\n\t\t\t\t\t\tyield ({\n\t\t\t\t\t\t\ttype: \"JSXPunctuator\",\n\t\t\t\t\t\t\tvalue: \"{\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t}\n\t\tWhiteSpace.lastIndex = lastIndex;\n\t\tif (match = WhiteSpace.exec(input)) {\n\t\t\tlastIndex = WhiteSpace.lastIndex;\n\t\t\tyield ({\n\t\t\t\ttype: \"WhiteSpace\",\n\t\t\t\tvalue: match[0]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tLineTerminatorSequence.lastIndex = lastIndex;\n\t\tif (match = LineTerminatorSequence.exec(input)) {\n\t\t\tlastIndex = LineTerminatorSequence.lastIndex;\n\t\t\tpostfixIncDec = false;\n\t\t\tif (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n\t\t\t\tlastSignificantToken = \"?NoLineTerminatorHere\";\n\t\t\t}\n\t\t\tyield ({\n\t\t\t\ttype: \"LineTerminatorSequence\",\n\t\t\t\tvalue: match[0]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tMultiLineComment.lastIndex = lastIndex;\n\t\tif (match = MultiLineComment.exec(input)) {\n\t\t\tlastIndex = MultiLineComment.lastIndex;\n\t\t\tif (Newline.test(match[0])) {\n\t\t\t\tpostfixIncDec = false;\n\t\t\t\tif (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {\n\t\t\t\t\tlastSignificantToken = \"?NoLineTerminatorHere\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tyield ({\n\t\t\t\ttype: \"MultiLineComment\",\n\t\t\t\tvalue: match[0],\n\t\t\t\tclosed: match[1] !== void 0\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tSingleLineComment.lastIndex = lastIndex;\n\t\tif (match = SingleLineComment.exec(input)) {\n\t\t\tlastIndex = SingleLineComment.lastIndex;\n\t\t\tpostfixIncDec = false;\n\t\t\tyield ({\n\t\t\t\ttype: \"SingleLineComment\",\n\t\t\t\tvalue: match[0]\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tfirstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));\n\t\tlastIndex += firstCodePoint.length;\n\t\tlastSignificantToken = firstCodePoint;\n\t\tpostfixIncDec = false;\n\t\tyield ({\n\t\t\ttype: mode.tag.startsWith(\"JSX\") ? \"JSXInvalid\" : \"Invalid\",\n\t\t\tvalue: firstCodePoint\n\t\t});\n\t}\n\treturn void 0;\n};\n\nvar jsTokens = /*@__PURE__*/getDefaultExportFromCjs(jsTokens_1);\n\n// src/index.ts\nvar reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\"\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\"\n  ]\n}, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), sometimesKeywords = /* @__PURE__ */ new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\nfunction isReservedWord(word) {\n  return word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word) {\n  return isReservedWord(word) || reservedWordsStrictSet.has(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nvar BRACKET = /^[()[\\]{}]$/, getTokenType = function(token) {\n  if (token.type === \"IdentifierName\") {\n    if (isKeyword(token.value) || isStrictReservedWord(token.value) || sometimesKeywords.has(token.value))\n      return \"Keyword\";\n    if (token.value[0] && token.value[0] !== token.value[0].toLowerCase())\n      return \"IdentifierCapitalized\";\n  }\n  return token.type === \"Punctuator\" && BRACKET.test(token.value) ? \"Bracket\" : token.type === \"Invalid\" && (token.value === \"@\" || token.value === \"#\") ? \"Punctuator\" : token.type;\n};\nfunction getCallableType(token) {\n  if (token.type === \"IdentifierName\")\n    return \"IdentifierCallable\";\n  if (token.type === \"PrivateIdentifier\")\n    return \"PrivateIdentifierCallable\";\n  throw new Error(\"Not a callable token\");\n}\nvar colorize = (defs, type, value) => {\n  let colorize2 = defs[type];\n  return colorize2 ? colorize2(value) : value;\n}, highlightTokens = (defs, text, jsx) => {\n  let highlighted = \"\", lastPotentialCallable = null, stackedHighlight = \"\";\n  for (let token of jsTokens(text, { jsx })) {\n    let type = getTokenType(token);\n    if (type === \"IdentifierName\" || type === \"PrivateIdentifier\") {\n      lastPotentialCallable && (highlighted += colorize(defs, getTokenType(lastPotentialCallable), lastPotentialCallable.value) + stackedHighlight, stackedHighlight = \"\"), lastPotentialCallable = token;\n      continue;\n    }\n    if (lastPotentialCallable && (token.type === \"WhiteSpace\" || token.type === \"LineTerminatorSequence\" || token.type === \"Punctuator\" && (token.value === \"?.\" || token.value === \"!\"))) {\n      stackedHighlight += colorize(defs, type, token.value);\n      continue;\n    }\n    if (stackedHighlight && !lastPotentialCallable && (highlighted += stackedHighlight, stackedHighlight = \"\"), lastPotentialCallable) {\n      let type2 = token.type === \"Punctuator\" && token.value === \"(\" ? getCallableType(lastPotentialCallable) : getTokenType(lastPotentialCallable);\n      highlighted += colorize(defs, type2, lastPotentialCallable.value) + stackedHighlight, stackedHighlight = \"\", lastPotentialCallable = null;\n    }\n    highlighted += colorize(defs, type, token.value);\n  }\n  return highlighted;\n};\nfunction highlight$1(code, options = { jsx: !1, colors: {} }) {\n  return code && highlightTokens(options.colors || {}, code, options.jsx);\n}\n\nfunction getDefs(c) {\n  const Invalid = (text) => c.white(c.bgRed(c.bold(text)));\n  return {\n    Keyword: c.magenta,\n    IdentifierCapitalized: c.yellow,\n    Punctuator: c.yellow,\n    StringLiteral: c.green,\n    NoSubstitutionTemplate: c.green,\n    MultiLineComment: c.gray,\n    SingleLineComment: c.gray,\n    RegularExpressionLiteral: c.cyan,\n    NumericLiteral: c.blue,\n    TemplateHead: (text) => c.green(text.slice(0, text.length - 2)) + c.cyan(text.slice(-2)),\n    TemplateTail: (text) => c.cyan(text.slice(0, 1)) + c.green(text.slice(1)),\n    TemplateMiddle: (text) => c.cyan(text.slice(0, 1)) + c.green(text.slice(1, text.length - 2)) + c.cyan(text.slice(-2)),\n    IdentifierCallable: c.blue,\n    PrivateIdentifierCallable: (text) => `#${c.blue(text.slice(1))}`,\n    Invalid,\n    JSXString: c.green,\n    JSXIdentifier: c.yellow,\n    JSXInvalid: Invalid,\n    JSXPunctuator: c.yellow\n  };\n}\nfunction highlight(code, options = { jsx: false }) {\n  return highlight$1(code, {\n    jsx: options.jsx,\n    colors: getDefs(options.colors || getColors())\n  });\n}\n\nexport { SAFE_TIMERS_SYMBOL, createSimpleStackTrace, getColors, getSafeTimers, highlight, lineSplitRE, offsetToLineNumber, positionToOffset, setSafeTimers, shuffle };\n","import { format, plugins } from 'pretty-format';\nimport * as diff$1 from 'diff-sequences';\nimport { g as getColors } from './chunk-colors.js';\n\nfunction getType(value) {\n  if (value === void 0) {\n    return \"undefined\";\n  } else if (value === null) {\n    return \"null\";\n  } else if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (typeof value === \"function\") {\n    return \"function\";\n  } else if (typeof value === \"number\") {\n    return \"number\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (typeof value === \"bigint\") {\n    return \"bigint\";\n  } else if (typeof value === \"object\") {\n    if (value != null) {\n      if (value.constructor === RegExp)\n        return \"regexp\";\n      else if (value.constructor === Map)\n        return \"map\";\n      else if (value.constructor === Set)\n        return \"set\";\n      else if (value.constructor === Date)\n        return \"date\";\n    }\n    return \"object\";\n  } else if (typeof value === \"symbol\") {\n    return \"symbol\";\n  }\n  throw new Error(`value of unknown type: ${value}`);\n}\n\nconst DIFF_DELETE = -1;\nconst DIFF_INSERT = 1;\nconst DIFF_EQUAL = 0;\nclass Diff {\n  0;\n  1;\n  constructor(op, text) {\n    this[0] = op;\n    this[1] = text;\n  }\n}\nconst diff_commonPrefix = function(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))\n    return 0;\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\nconst diff_commonSuffix = function(text1, text2) {\n  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))\n    return 0;\n  let pointermin = 0;\n  let pointermax = Math.min(text1.length, text2.length);\n  let pointermid = pointermax;\n  let pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\nconst diff_commonOverlap_ = function(text1, text2) {\n  const text1_length = text1.length;\n  const text2_length = text2.length;\n  if (text1_length === 0 || text2_length === 0)\n    return 0;\n  if (text1_length > text2_length)\n    text1 = text1.substring(text1_length - text2_length);\n  else if (text1_length < text2_length)\n    text2 = text2.substring(0, text1_length);\n  const text_length = Math.min(text1_length, text2_length);\n  if (text1 === text2)\n    return text_length;\n  let best = 0;\n  let length = 1;\n  while (true) {\n    const pattern = text1.substring(text_length - length);\n    const found = text2.indexOf(pattern);\n    if (found === -1)\n      return best;\n    length += found;\n    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\nconst diff_cleanupSemantic = function(diffs) {\n  let changes = false;\n  const equalities = [];\n  let equalitiesLength = 0;\n  let lastEquality = null;\n  let pointer = 0;\n  let length_insertions1 = 0;\n  let length_deletions1 = 0;\n  let length_insertions2 = 0;\n  let length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] === DIFF_EQUAL) {\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {\n      if (diffs[pointer][0] === DIFF_INSERT)\n        length_insertions2 += diffs[pointer][1].length;\n      else\n        length_deletions2 += diffs[pointer][1].length;\n      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {\n        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes)\n    diff_cleanupMerge(diffs);\n  diff_cleanupSemanticLossless(diffs);\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1];\n      const insertion = diffs[pointer][1];\n      const overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      const overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] = deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\nconst nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nconst whitespaceRegex_ = /\\s/;\nconst linebreakRegex_ = /[\\r\\n]/;\nconst blanklineEndRegex_ = /\\n\\r?\\n$/;\nconst blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\nfunction diff_cleanupSemanticLossless(diffs) {\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      return 6;\n    }\n    const char1 = one.charAt(one.length - 1);\n    const char2 = two.charAt(0);\n    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);\n    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);\n    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);\n    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);\n    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);\n    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);\n    if (blankLine1 || blankLine2) {\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      return 1;\n    }\n    return 0;\n  }\n  let pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1];\n      let edit = diffs[pointer][1];\n      let equality2 = diffs[pointer + 1][1];\n      const commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1;\n      let bestEdit = edit;\n      let bestEquality2 = equality2;\n      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n      if (diffs[pointer - 1][1] !== bestEquality1) {\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n}\nfunction diff_cleanupMerge(diffs) {\n  diffs.push(new Diff(DIFF_EQUAL, \"\"));\n  let pointer = 0;\n  let count_delete = 0;\n  let count_insert = 0;\n  let text_delete = \"\";\n  let text_insert = \"\";\n  let commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = \"\";\n        text_insert = \"\";\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === \"\")\n    diffs.pop();\n  let changes = false;\n  pointer = 1;\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  if (changes)\n    diff_cleanupMerge(diffs);\n}\n\nconst NO_DIFF_MESSAGE = \"Compared values have no visual difference.\";\nconst SIMILAR_MESSAGE = \"Compared values serialize to the same structure.\\nPrinting internal object structure without calling `toJSON` instead.\";\n\nfunction formatTrailingSpaces(line, trailingSpaceFormatter) {\n  return line.replace(/\\s+$/, (match) => trailingSpaceFormatter(match));\n}\nfunction printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {\n  return line.length !== 0 ? color(\n    `${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`\n  ) : indicator !== \" \" ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : \"\";\n}\nfunction printDeleteLine(line, isFirstOrLast, {\n  aColor,\n  aIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) {\n  return printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n}\nfunction printInsertLine(line, isFirstOrLast, {\n  bColor,\n  bIndicator,\n  changeLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) {\n  return printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n}\nfunction printCommonLine(line, isFirstOrLast, {\n  commonColor,\n  commonIndicator,\n  commonLineTrailingSpaceColor,\n  emptyFirstOrLastLinePlaceholder\n}) {\n  return printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n}\nfunction createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {\n  return patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  );\n}\nfunction joinAlignedDiffsNoExpand(diffs, options) {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines;\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n  while (i !== iLength) {\n    const iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL)\n      i += 1;\n    if (iStart !== i) {\n      if (iStart === 0) {\n        if (i > nContextLines) {\n          jLength -= i - nContextLines;\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        const n = i - iStart;\n        if (n > nContextLines) {\n          jLength -= n - nContextLines;\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        const n = i - iStart;\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2;\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL)\n      i += 1;\n  }\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n  if (nExcessesBetweenChanges !== 0)\n    jLength += nExcessesBetweenChanges + 1;\n  else if (hasExcessAtStartOrEnd)\n    jLength += 1;\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0;\n  if (hasPatch)\n    lines.push(\"\");\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n  const pushCommonLine = (line) => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n  const pushDeleteLine = (line) => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n  const pushInsertLine = (line) => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  };\n  i = 0;\n  while (i !== iLength) {\n    let iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL)\n      i += 1;\n    if (iStart !== i) {\n      if (iStart === 0) {\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1)\n          pushCommonLine(diffs[iCommon][1]);\n      } else if (i === iLength) {\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)\n          pushCommonLine(diffs[iCommon][1]);\n      } else {\n        const nCommon = i - iStart;\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)\n            pushCommonLine(diffs[iCommon][1]);\n          lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options\n          );\n          jPatchMark = lines.length;\n          lines.push(\"\");\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1)\n            pushCommonLine(diffs[iCommon][1]);\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1)\n            pushCommonLine(diffs[iCommon][1]);\n        }\n      }\n    }\n    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n  if (hasPatch)\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  return lines.join(\"\\n\");\n}\nfunction joinAlignedDiffsExpand(diffs, options) {\n  return diffs.map((diff, i, diffs2) => {\n    const line = diff[1];\n    const isFirstOrLast = i === 0 || i === diffs2.length - 1;\n    switch (diff[0]) {\n      case DIFF_DELETE:\n        return printDeleteLine(line, isFirstOrLast, options);\n      case DIFF_INSERT:\n        return printInsertLine(line, isFirstOrLast, options);\n      default:\n        return printCommonLine(line, isFirstOrLast, options);\n    }\n  }).join(\"\\n\");\n}\n\nconst noColor = (string) => string;\nconst DIFF_CONTEXT_DEFAULT = 5;\nconst DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;\nfunction getDefaultOptions() {\n  const c = getColors();\n  return {\n    aAnnotation: \"Expected\",\n    aColor: c.green,\n    aIndicator: \"-\",\n    bAnnotation: \"Received\",\n    bColor: c.red,\n    bIndicator: \"+\",\n    changeColor: c.inverse,\n    changeLineTrailingSpaceColor: noColor,\n    commonColor: c.dim,\n    commonIndicator: \" \",\n    commonLineTrailingSpaceColor: noColor,\n    compareKeys: void 0,\n    contextLines: DIFF_CONTEXT_DEFAULT,\n    emptyFirstOrLastLinePlaceholder: \"\",\n    expand: true,\n    includeChangeCounts: false,\n    omitAnnotationLines: false,\n    patchColor: c.yellow,\n    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,\n    truncateAnnotation: \"... Diff result is truncated\",\n    truncateAnnotationColor: noColor\n  };\n}\nfunction getCompareKeys(compareKeys) {\n  return compareKeys && typeof compareKeys === \"function\" ? compareKeys : void 0;\n}\nfunction getContextLines(contextLines) {\n  return typeof contextLines === \"number\" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;\n}\nfunction normalizeDiffOptions(options = {}) {\n  return {\n    ...getDefaultOptions(),\n    ...options,\n    compareKeys: getCompareKeys(options.compareKeys),\n    contextLines: getContextLines(options.contextLines)\n  };\n}\n\nfunction isEmptyString(lines) {\n  return lines.length === 1 && lines[0].length === 0;\n}\nfunction countChanges(diffs) {\n  let a = 0;\n  let b = 0;\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        a += 1;\n        break;\n      case DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return { a, b };\n}\nfunction printAnnotation({\n  aAnnotation,\n  aColor,\n  aIndicator,\n  bAnnotation,\n  bColor,\n  bIndicator,\n  includeChangeCounts,\n  omitAnnotationLines\n}, changeCounts) {\n  if (omitAnnotationLines)\n    return \"\";\n  let aRest = \"\";\n  let bRest = \"\";\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b);\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = \" \".repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = \" \".repeat(Math.max(0, -baAnnotationLengthDiff));\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = \" \".repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = \" \".repeat(Math.max(0, -baCountLengthDiff));\n    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;\n    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;\n  }\n  const a = `${aIndicator} ${aAnnotation}${aRest}`;\n  const b = `${bIndicator} ${bAnnotation}${bRest}`;\n  return `${aColor(a)}\n${bColor(b)}\n\n`;\n}\nfunction printDiffLines(diffs, truncated, options) {\n  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`\n${options.truncateAnnotation}`) : \"\");\n}\nfunction diffLinesUnified(aLines, bLines, options) {\n  const normalizedOptions = normalizeDiffOptions(options);\n  const [diffs, truncated] = diffLinesRaw(\n    isEmptyString(aLines) ? [] : aLines,\n    isEmptyString(bLines) ? [] : bLines,\n    normalizedOptions\n  );\n  return printDiffLines(\n    diffs,\n    truncated,\n    normalizedOptions\n  );\n}\nfunction diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n  const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach((diff2) => {\n    switch (diff2[0]) {\n      case DIFF_DELETE:\n        diff2[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n      case DIFF_INSERT:\n        diff2[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n      default:\n        diff2[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));\n}\nfunction diffLinesRaw(aLines, bLines, options) {\n  const truncate = (options == null ? void 0 : options.truncateThreshold) ?? false;\n  const truncateThreshold = Math.max(Math.floor((options == null ? void 0 : options.truncateThreshold) ?? 0), 0);\n  const aLength = truncate ? Math.min(aLines.length, truncateThreshold) : aLines.length;\n  const bLength = truncate ? Math.min(bLines.length, truncateThreshold) : bLines.length;\n  const truncated = aLength !== aLines.length || bLength !== bLines.length;\n  const isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2];\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1)\n      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n    for (; bIndex !== bCommon; bIndex += 1)\n      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)\n      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));\n  };\n  const diffSequences = diff$1.default.default || diff$1.default;\n  diffSequences(aLength, bLength, isCommon, foundSubsequence);\n  for (; aIndex !== aLength; aIndex += 1)\n    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n  for (; bIndex !== bLength; bIndex += 1)\n    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n  return [diffs, truncated];\n}\n\nfunction getNewLineSymbol(string) {\n  return string.includes(\"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n}\nfunction diffStrings(a, b, options) {\n  const truncate = (options == null ? void 0 : options.truncateThreshold) ?? false;\n  const truncateThreshold = Math.max(Math.floor((options == null ? void 0 : options.truncateThreshold) ?? 0), 0);\n  let aLength = a.length;\n  let bLength = b.length;\n  if (truncate) {\n    const aMultipleLines = a.includes(\"\\n\");\n    const bMultipleLines = b.includes(\"\\n\");\n    const aNewLineSymbol = getNewLineSymbol(a);\n    const bNewLineSymbol = getNewLineSymbol(b);\n    const _a = aMultipleLines ? `${a.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}\n` : a;\n    const _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}\n` : b;\n    aLength = _a.length;\n    bLength = _b.length;\n  }\n  const truncated = aLength !== a.length || bLength !== b.length;\n  const isCommon = (aIndex2, bIndex2) => a[aIndex2] === b[bIndex2];\n  let aIndex = 0;\n  let bIndex = 0;\n  const diffs = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon)\n      diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex, aCommon)));\n    if (bIndex !== bCommon)\n      diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));\n    aIndex = aCommon + nCommon;\n    bIndex = bCommon + nCommon;\n    diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));\n  };\n  const diffSequences = diff$1.default.default || diff$1.default;\n  diffSequences(aLength, bLength, isCommon, foundSubsequence);\n  if (aIndex !== aLength)\n    diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex)));\n  if (bIndex !== bLength)\n    diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));\n  return [diffs, truncated];\n}\n\nfunction concatenateRelevantDiffs(op, diffs, changeColor) {\n  return diffs.reduce(\n    (reduced, diff) => reduced + (diff[0] === DIFF_EQUAL ? diff[1] : diff[0] === op && diff[1].length !== 0 ? changeColor(diff[1]) : \"\"),\n    \"\"\n  );\n}\nclass ChangeBuffer {\n  op;\n  line;\n  // incomplete line\n  lines;\n  // complete lines\n  changeColor;\n  constructor(op, changeColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n  pushSubstring(substring) {\n    this.pushDiff(new Diff(this.op, substring));\n  }\n  pushLine() {\n    this.lines.push(\n      this.line.length !== 1 ? new Diff(\n        this.op,\n        concatenateRelevantDiffs(this.op, this.line, this.changeColor)\n      ) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])\n      // was common diff\n    );\n    this.line.length = 0;\n  }\n  isLineEmpty() {\n    return this.line.length === 0;\n  }\n  // Minor input to buffer.\n  pushDiff(diff) {\n    this.line.push(diff);\n  }\n  // Main input to buffer.\n  align(diff) {\n    const string = diff[1];\n    if (string.includes(\"\\n\")) {\n      const substrings = string.split(\"\\n\");\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      this.pushDiff(diff);\n    }\n  }\n  // Output from buffer.\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty())\n      this.pushLine();\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n}\nclass CommonBuffer {\n  deleteBuffer;\n  insertBuffer;\n  lines;\n  constructor(deleteBuffer, insertBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0;\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty())\n      this.deleteBuffer.pushDiff(diff);\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty())\n      this.insertBuffer.pushDiff(diff);\n  }\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  }\n  // Input to buffer.\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n    if (string.includes(\"\\n\")) {\n      const substrings = string.split(\"\\n\");\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new Diff(op, substring);\n          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          this.pushDiffCommonLine(new Diff(op, substring));\n        } else if (substring.length !== 0) {\n          this.pushDiffChangeLines(new Diff(op, substring));\n        }\n      });\n    } else {\n      this.pushDiffChangeLines(diff);\n    }\n  }\n  // Output from buffer.\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n}\nfunction getAlignedDiffs(diffs, changeColor) {\n  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);\n  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach((diff) => {\n    switch (diff[0]) {\n      case DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n      case DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n}\n\nfunction hasCommonDiff(diffs, isMultiline) {\n  if (isMultiline) {\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) => diff[0] === DIFF_EQUAL && (i !== iLast || diff[1] !== \"\\n\")\n    );\n  }\n  return diffs.some((diff) => diff[0] === DIFF_EQUAL);\n}\nfunction diffStringsUnified(a, b, options) {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes(\"\\n\") || b.includes(\"\\n\");\n    const [diffs, truncated] = diffStringsRaw(\n      isMultiline ? `${a}\n` : a,\n      isMultiline ? `${b}\n` : b,\n      true,\n      // cleanupSemantic\n      options\n    );\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = normalizeDiffOptions(options);\n      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);\n      return printDiffLines(lines, truncated, optionsNormalized);\n    }\n  }\n  return diffLinesUnified(a.split(\"\\n\"), b.split(\"\\n\"), options);\n}\nfunction diffStringsRaw(a, b, cleanup, options) {\n  const [diffs, truncated] = diffStrings(a, b, options);\n  if (cleanup)\n    diff_cleanupSemantic(diffs);\n  return [diffs, truncated];\n}\n\nfunction getCommonMessage(message, options) {\n  const { commonColor } = normalizeDiffOptions(options);\n  return commonColor(message);\n}\nconst {\n  AsymmetricMatcher,\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent\n} = plugins;\nconst PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher\n];\nconst FORMAT_OPTIONS = {\n  plugins: PLUGINS\n};\nconst FALLBACK_FORMAT_OPTIONS = {\n  callToJSON: false,\n  maxDepth: 10,\n  plugins: PLUGINS\n};\nfunction diff(a, b, options) {\n  if (Object.is(a, b))\n    return \"\";\n  const aType = getType(a);\n  let expectedType = aType;\n  let omitDifference = false;\n  if (aType === \"object\" && typeof a.asymmetricMatch === \"function\") {\n    if (a.$$typeof !== Symbol.for(\"jest.asymmetricMatcher\")) {\n      return null;\n    }\n    if (typeof a.getExpectedType !== \"function\") {\n      return null;\n    }\n    expectedType = a.getExpectedType();\n    omitDifference = expectedType === \"string\";\n  }\n  if (expectedType !== getType(b)) {\n    const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    const aDisplay = format(a, formatOptions);\n    const bDisplay = format(b, formatOptions);\n    const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} \n${aDisplay}`;\n    const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} \n${bDisplay}`;\n    return `${aDiff}\n\n${bDiff}`;\n  }\n  if (omitDifference)\n    return null;\n  switch (aType) {\n    case \"string\":\n      return diffLinesUnified(a.split(\"\\n\"), b.split(\"\\n\"), options);\n    case \"boolean\":\n    case \"number\":\n      return comparePrimitive(a, b, options);\n    case \"map\":\n      return compareObjects(sortMap(a), sortMap(b), options);\n    case \"set\":\n      return compareObjects(sortSet(a), sortSet(b), options);\n    default:\n      return compareObjects(a, b, options);\n  }\n}\nfunction comparePrimitive(a, b, options) {\n  const aFormat = format(a, FORMAT_OPTIONS);\n  const bFormat = format(b, FORMAT_OPTIONS);\n  return aFormat === bFormat ? \"\" : diffLinesUnified(aFormat.split(\"\\n\"), bFormat.split(\"\\n\"), options);\n}\nfunction sortMap(map) {\n  return new Map(Array.from(map.entries()).sort());\n}\nfunction sortSet(set) {\n  return new Set(Array.from(set.values()).sort());\n}\nfunction compareObjects(a, b, options) {\n  let difference;\n  let hasThrown = false;\n  try {\n    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a, b, formatOptions, options);\n  } catch {\n    hasThrown = true;\n  }\n  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);\n  if (difference === void 0 || difference === noDiffMessage) {\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a, b, formatOptions, options);\n    if (difference !== noDiffMessage && !hasThrown) {\n      difference = `${getCommonMessage(\n        SIMILAR_MESSAGE,\n        options\n      )}\n\n${difference}`;\n    }\n  }\n  return difference;\n}\nfunction getFormatOptions(formatOptions, options) {\n  const { compareKeys } = normalizeDiffOptions(options);\n  return {\n    ...formatOptions,\n    compareKeys\n  };\n}\nfunction getObjectsDifference(a, b, formatOptions, options) {\n  const formatOptionsZeroIndent = { ...formatOptions, indent: 0 };\n  const aCompare = format(a, formatOptionsZeroIndent);\n  const bCompare = format(b, formatOptionsZeroIndent);\n  if (aCompare === bCompare) {\n    return getCommonMessage(NO_DIFF_MESSAGE, options);\n  } else {\n    const aDisplay = format(a, formatOptions);\n    const bDisplay = format(b, formatOptions);\n    return diffLinesUnified2(\n      aDisplay.split(\"\\n\"),\n      bDisplay.split(\"\\n\"),\n      aCompare.split(\"\\n\"),\n      bCompare.split(\"\\n\"),\n      options\n    );\n  }\n}\n\nexport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff, diff, diffLinesRaw, diffLinesUnified, diffLinesUnified2, diffStringsRaw, diffStringsUnified };\n","import { diff } from './diff.js';\nimport { f as format, s as stringify } from './chunk-display.js';\nimport { deepClone, getOwnProperties, getType } from './helpers.js';\nimport 'pretty-format';\nimport 'diff-sequences';\nimport './chunk-colors.js';\nimport 'loupe';\n\nconst IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\nconst IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\nfunction isImmutable(v) {\n  return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);\n}\nconst OBJECT_PROTO = Object.getPrototypeOf({});\nfunction getUnserializableMessage(err) {\n  if (err instanceof Error)\n    return `<unserializable>: ${err.message}`;\n  if (typeof err === \"string\")\n    return `<unserializable>: ${err}`;\n  return \"<unserializable>\";\n}\nfunction serializeError(val, seen = /* @__PURE__ */ new WeakMap()) {\n  if (!val || typeof val === \"string\")\n    return val;\n  if (typeof val === \"function\")\n    return `Function<${val.name || \"anonymous\"}>`;\n  if (typeof val === \"symbol\")\n    return val.toString();\n  if (typeof val !== \"object\")\n    return val;\n  if (isImmutable(val))\n    return serializeError(val.toJSON(), seen);\n  if (val instanceof Promise || val.constructor && val.constructor.prototype === \"AsyncFunction\")\n    return \"Promise\";\n  if (typeof Element !== \"undefined\" && val instanceof Element)\n    return val.tagName;\n  if (typeof val.asymmetricMatch === \"function\")\n    return `${val.toString()} ${format(val.sample)}`;\n  if (typeof val.toJSON === \"function\")\n    return val.toJSON();\n  if (seen.has(val))\n    return seen.get(val);\n  if (Array.isArray(val)) {\n    const clone = new Array(val.length);\n    seen.set(val, clone);\n    val.forEach((e, i) => {\n      try {\n        clone[i] = serializeError(e, seen);\n      } catch (err) {\n        clone[i] = getUnserializableMessage(err);\n      }\n    });\n    return clone;\n  } else {\n    const clone = /* @__PURE__ */ Object.create(null);\n    seen.set(val, clone);\n    let obj = val;\n    while (obj && obj !== OBJECT_PROTO) {\n      Object.getOwnPropertyNames(obj).forEach((key) => {\n        if (key in clone)\n          return;\n        try {\n          clone[key] = serializeError(val[key], seen);\n        } catch (err) {\n          delete clone[key];\n          clone[key] = getUnserializableMessage(err);\n        }\n      });\n      obj = Object.getPrototypeOf(obj);\n    }\n    return clone;\n  }\n}\nfunction normalizeErrorMessage(message) {\n  return message.replace(/__(vite_ssr_import|vi_import)_\\d+__\\./g, \"\");\n}\nfunction processError(err, diffOptions) {\n  if (!err || typeof err !== \"object\")\n    return { message: err };\n  if (err.stack)\n    err.stackStr = String(err.stack);\n  if (err.name)\n    err.nameStr = String(err.name);\n  if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) {\n    const clonedActual = deepClone(err.actual, { forceWritable: true });\n    const clonedExpected = deepClone(err.expected, { forceWritable: true });\n    const { replacedActual, replacedExpected } = replaceAsymmetricMatcher(clonedActual, clonedExpected);\n    err.diff = diff(replacedExpected, replacedActual, { ...diffOptions, ...err.diffOptions });\n  }\n  if (typeof err.expected !== \"string\")\n    err.expected = stringify(err.expected, 10);\n  if (typeof err.actual !== \"string\")\n    err.actual = stringify(err.actual, 10);\n  try {\n    if (typeof err.message === \"string\")\n      err.message = normalizeErrorMessage(err.message);\n    if (typeof err.cause === \"object\" && typeof err.cause.message === \"string\")\n      err.cause.message = normalizeErrorMessage(err.cause.message);\n  } catch {\n  }\n  try {\n    return serializeError(err);\n  } catch (e) {\n    return serializeError(new Error(`Failed to fully serialize error: ${e == null ? void 0 : e.message}\nInner error message: ${err == null ? void 0 : err.message}`));\n  }\n}\nfunction isAsymmetricMatcher(data) {\n  const type = getType(data);\n  return type === \"Object\" && typeof data.asymmetricMatch === \"function\";\n}\nfunction isReplaceable(obj1, obj2) {\n  const obj1Type = getType(obj1);\n  const obj2Type = getType(obj2);\n  return obj1Type === obj2Type && (obj1Type === \"Object\" || obj1Type === \"Array\");\n}\nfunction replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {\n  if (!isReplaceable(actual, expected))\n    return { replacedActual: actual, replacedExpected: expected };\n  if (actualReplaced.has(actual) || expectedReplaced.has(expected))\n    return { replacedActual: actual, replacedExpected: expected };\n  actualReplaced.add(actual);\n  expectedReplaced.add(expected);\n  getOwnProperties(expected).forEach((key) => {\n    const expectedValue = expected[key];\n    const actualValue = actual[key];\n    if (isAsymmetricMatcher(expectedValue)) {\n      if (expectedValue.asymmetricMatch(actualValue))\n        actual[key] = expectedValue;\n    } else if (isAsymmetricMatcher(actualValue)) {\n      if (actualValue.asymmetricMatch(expectedValue))\n        expected[key] = actualValue;\n    } else if (isReplaceable(actualValue, expectedValue)) {\n      const replaced = replaceAsymmetricMatcher(\n        actualValue,\n        expectedValue,\n        actualReplaced,\n        expectedReplaced\n      );\n      actual[key] = replaced.replacedActual;\n      expected[key] = replaced.replacedExpected;\n    }\n  });\n  return {\n    replacedActual: actual,\n    replacedExpected: expected\n  };\n}\n\nexport { processError, replaceAsymmetricMatcher, serializeError };\n","import { notNullish, isPrimitive } from './helpers.js';\n\nfunction normalizeWindowsPath(input = \"\") {\n  if (!input || !input.includes(\"\\\\\")) {\n    return input;\n  }\n  return input.replace(/\\\\/g, \"/\");\n}\nconst _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/;\nfunction cwd() {\n  if (typeof process !== \"undefined\") {\n    return process.cwd().replace(/\\\\/g, \"/\");\n  }\n  return \"/\";\n}\nconst resolve$2 = function(...arguments_) {\n  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {\n    const path = index >= 0 ? arguments_[index] : cwd();\n    if (!path || path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isAbsolute(path);\n  }\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);\n  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {\n    return `/${resolvedPath}`;\n  }\n  return resolvedPath.length > 0 ? resolvedPath : \".\";\n};\nfunction normalizeString(path, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let char = null;\n  for (let index = 0; index <= path.length; ++index) {\n    if (index < path.length) {\n      char = path[index];\n    } else if (char === \"/\") {\n      break;\n    } else {\n      char = \"/\";\n    }\n    if (char === \"/\") {\n      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n            }\n            lastSlash = index;\n            dots = 0;\n            continue;\n          } else if (res.length > 0) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"/..\" : \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path.slice(lastSlash + 1, index)}`;\n        } else {\n          res = path.slice(lastSlash + 1, index);\n        }\n        lastSegmentLength = index - lastSlash - 1;\n      }\n      lastSlash = index;\n      dots = 0;\n    } else if (char === \".\" && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst isAbsolute = function(p) {\n  return _IS_ABSOLUTE_RE.test(p);\n};\n\nconst comma = ','.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator$1);\n}\nfunction sortComparator$1(a, b) {\n    return a[0] - b[0];\n}\n\n// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: UrlType.Absolute,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = UrlType.SchemeRelative;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = UrlType.AbsolutePath;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? UrlType.Query\n            : input.startsWith('#')\n                ? UrlType.Hash\n                : UrlType.RelativePath\n        : UrlType.Empty;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve$1(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case UrlType.Empty:\n                url.hash = baseUrl.hash;\n            // fall through\n            case UrlType.Hash:\n                url.query = baseUrl.query;\n            // fall through\n            case UrlType.Query:\n            case UrlType.RelativePath:\n                mergePaths(url, baseUrl);\n            // fall through\n            case UrlType.AbsolutePath:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case UrlType.SchemeRelative:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case UrlType.Hash:\n        case UrlType.Query:\n            return queryHash;\n        case UrlType.RelativePath: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case UrlType.AbsolutePath:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolve$1(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nlet generatedPositionFor;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n(() => {\n    decodedMappings = (map) => {\n        return (map._decoded || (map._decoded = decode(map._encoded)));\n    };\n    originalPositionFor = (map, { line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1)\n            return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1)\n            return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n    function generatedPosition(map, source, line, column, bias, all) {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return all ? [] : GMapping(null, null);\n        const generated = (map._bySources || (map._bySources = buildBySources(decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return all ? [] : GMapping(null, null);\n        const memo = map._bySourceMemos[sourceIndex];\n        if (all)\n            return sliceGeneratedPositions(segments, memo, line, column, bias);\n        const index = traceSegmentInternal(segments, memo, line, column, bias);\n        if (index === -1)\n            return GMapping(null, null);\n        const segment = segments[index];\n        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n})();\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n    return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND)\n        min++;\n    if (min === -1 || min === segments.length)\n        return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found)\n        min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\n\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nconst stackIgnorePatterns = [\n  \"node:internal\",\n  /\\/packages\\/\\w+\\/dist\\//,\n  /\\/@vitest\\/\\w+\\/dist\\//,\n  \"/vitest/dist/\",\n  \"/vitest/src/\",\n  \"/vite-node/dist/\",\n  \"/vite-node/src/\",\n  \"/node_modules/chai/\",\n  \"/node_modules/tinypool/\",\n  \"/node_modules/tinyspy/\",\n  \"/deps/chai.js\",\n  /__vitest_browser__/\n];\nfunction extractLocation(urlLike) {\n  if (!urlLike.includes(\":\"))\n    return [urlLike];\n  const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n  const parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n  if (!parts)\n    return [urlLike];\n  let url = parts[1];\n  if (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n    const urlObj = new URL(url);\n    url = urlObj.pathname;\n  }\n  if (url.startsWith(\"/@fs/\")) {\n    url = url.slice(typeof process !== \"undefined\" && process.platform === \"win32\" ? 5 : 4);\n  }\n  return [url, parts[2] || void 0, parts[3] || void 0];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n  let line = raw.trim();\n  if (SAFARI_NATIVE_CODE_REGEXP.test(line))\n    return null;\n  if (line.includes(\" > eval\"))\n    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n  if (!line.includes(\"@\") && !line.includes(\":\"))\n    return null;\n  const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n  const matches = line.match(functionNameRegex);\n  const functionName = matches && matches[1] ? matches[1] : void 0;\n  const [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, \"\"));\n  if (!url || !lineNumber || !columnNumber)\n    return null;\n  return {\n    file: url,\n    method: functionName || \"\",\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction parseSingleStack(raw) {\n  const line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line))\n    return parseSingleFFOrSafariStack(line);\n  return parseSingleV8Stack(line);\n}\nfunction parseSingleV8Stack(raw) {\n  let line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line))\n    return null;\n  if (line.includes(\"(eval \"))\n    line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n  let sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n  const location = sanitizedLine.match(/ (\\(.+\\)$)/);\n  sanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n  const [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);\n  let method = location && sanitizedLine || \"\";\n  let file = url && [\"eval\", \"<anonymous>\"].includes(url) ? void 0 : url;\n  if (!file || !lineNumber || !columnNumber)\n    return null;\n  if (method.startsWith(\"async \"))\n    method = method.slice(6);\n  if (file.startsWith(\"file://\"))\n    file = file.slice(7);\n  file = resolve$2(file);\n  if (method)\n    method = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\");\n  return {\n    method,\n    file,\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction parseStacktrace(stack, options = {}) {\n  const { ignoreStackEntries = stackIgnorePatterns } = options;\n  let stacks = !CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack);\n  if (ignoreStackEntries.length)\n    stacks = stacks.filter((stack2) => !ignoreStackEntries.some((p) => stack2.file.match(p)));\n  return stacks.map((stack2) => {\n    var _a;\n    const map = (_a = options.getSourceMap) == null ? void 0 : _a.call(options, stack2.file);\n    if (!map || typeof map !== \"object\" || !map.version)\n      return stack2;\n    const traceMap = new TraceMap(map);\n    const { line, column } = originalPositionFor(traceMap, stack2);\n    if (line != null && column != null)\n      return { ...stack2, line, column };\n    return stack2;\n  });\n}\nfunction parseFFOrSafariStackTrace(stack) {\n  return stack.split(\"\\n\").map((line) => parseSingleFFOrSafariStack(line)).filter(notNullish);\n}\nfunction parseV8Stacktrace(stack) {\n  return stack.split(\"\\n\").map((line) => parseSingleV8Stack(line)).filter(notNullish);\n}\nfunction parseErrorStacktrace(e, options = {}) {\n  if (!e || isPrimitive(e))\n    return [];\n  if (e.stacks)\n    return e.stacks;\n  const stackStr = e.stack || e.stackStr || \"\";\n  let stackFrames = parseStacktrace(stackStr, options);\n  if (options.frameFilter)\n    stackFrames = stackFrames.filter((f) => options.frameFilter(e, f) !== false);\n  e.stacks = stackFrames;\n  return stackFrames;\n}\n\nexport { TraceMap, generatedPositionFor, originalPositionFor, parseErrorStacktrace, parseSingleFFOrSafariStack, parseSingleStack, parseSingleV8Stack, parseStacktrace };\n"],"names":["assertTypes","value","name","types","receivedType","isObject","item","isFinalObj","obj","getType","collectOwnProperties","collector","collect","key","getOwnProperties","ownProps","defaultCloneOptions","deepClone","val","options","clone","seen","k","out","props","k2","descriptor","cloned","objectAttr","source","path","defaultValue","paths","result","p","createDefer","resolve","reject","_resolve","_reject","AsymmetricMatcher","DOMCollection","DOMElement","Immutable","ReactElement","ReactTestComponent","plugins","PLUGINS","stringify","object","maxDepth","maxLength","MAX_LENGTH","format$1","formatRegExp","format","args","objects","i2","inspect","len","i","template","str","x","err","m","loupe.inspect","objDisplay","type","fn","keys","SAFE_TIMERS_SYMBOL","SAFE_COLORS_SYMBOL","colorsMap","colorsEntries","string","defaultColors","acc","getColors","getSafeTimers","safeSetTimeout","safeSetInterval","safeClearInterval","safeClearTimeout","safeSetImmediate","safeClearImmediate","safeNextTick","cb","createSimpleStackTrace","message","stackTraceLimit","limit","prepareStackTrace","e","stackTrace","LineTerminatorSequence","reservedWords","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","Diff","op","text","__publicField","NO_DIFF_MESSAGE","SIMILAR_MESSAGE","formatTrailingSpaces","line","trailingSpaceFormatter","match","printDiffLine","isFirstOrLast","color","indicator","emptyFirstOrLastLinePlaceholder","printDeleteLine","aColor","aIndicator","changeLineTrailingSpaceColor","printInsertLine","bColor","bIndicator","printCommonLine","commonColor","commonIndicator","commonLineTrailingSpaceColor","createPatchMark","aStart","aEnd","bStart","bEnd","patchColor","joinAlignedDiffsNoExpand","diffs","iLength","nContextLines","nContextLines2","jLength","hasExcessAtStartOrEnd","nExcessesBetweenChanges","iStart","n","hasPatch","jLast","lines","jPatchMark","pushCommonLine","j","pushDeleteLine","pushInsertLine","iCommon","iEnd","nCommon","nOmit","joinAlignedDiffsExpand","diff","diffs2","noColor","DIFF_CONTEXT_DEFAULT","DIFF_TRUNCATE_THRESHOLD_DEFAULT","getDefaultOptions","c","getCompareKeys","compareKeys","getContextLines","contextLines","normalizeDiffOptions","isEmptyString","countChanges","a","b","diff2","printAnnotation","aAnnotation","bAnnotation","includeChangeCounts","omitAnnotationLines","changeCounts","aRest","bRest","aCount","bCount","baAnnotationLengthDiff","aAnnotationPadding","bAnnotationPadding","baCountLengthDiff","aCountPadding","bCountPadding","printDiffLines","truncated","diffLinesUnified","aLines","bLines","normalizedOptions","diffLinesRaw","diffLinesUnified2","aLinesDisplay","bLinesDisplay","aLinesCompare","bLinesCompare","aIndex","bIndex","truncate","truncateThreshold","aLength","bLength","isCommon","aIndex2","bIndex2","foundSubsequence","aCommon","bCommon","diff$1.default","getCommonMessage","FORMAT_OPTIONS","FALLBACK_FORMAT_OPTIONS","aType","expectedType","omitDifference","formatOptions","getFormatOptions","aDisplay","bDisplay","aDiff","bDiff","comparePrimitive","compareObjects","sortMap","sortSet","aFormat","bFormat","map","set","difference","hasThrown","getObjectsDifference","noDiffMessage","formatOptionsZeroIndent","aCompare","bCompare","IS_RECORD_SYMBOL","IS_COLLECTION_SYMBOL","isImmutable","v","OBJECT_PROTO","getUnserializableMessage","serializeError","normalizeErrorMessage","processError","diffOptions","clonedActual","clonedExpected","replacedActual","replacedExpected","replaceAsymmetricMatcher","isAsymmetricMatcher","data","isReplaceable","obj1","obj2","obj1Type","obj2Type","actual","expected","actualReplaced","expectedReplaced","expectedValue","actualValue","replaced","normalizeWindowsPath","input","_IS_ABSOLUTE_RE","cwd","resolve$2","arguments_","argument","resolvedPath","resolvedAbsolute","index","isAbsolute","normalizeString","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","char","lastSlashIndex","chars","intToChar","charToInt","UrlType","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","extractLocation","urlLike","parts","url","parseSingleFFOrSafariStack","raw","functionNameRegex","matches","functionName","lineNumber","columnNumber","parseSingleStack","parseSingleV8Stack","sanitizedLine","location","method","file"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}
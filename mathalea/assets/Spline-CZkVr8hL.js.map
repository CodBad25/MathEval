{"version":3,"file":"Spline-CZkVr8hL.js","sources":["../../src/lib/mathFonctions/Spline.ts"],"sourcesContent":["import { polynomialRoot, round } from 'mathjs'\n\nimport type Point from 'apigeom/src/elements/points/Point'\nimport type Figure from 'apigeom/src/Figure'\nimport Decimal from 'decimal.js'\nimport {\n  colorToLatexOrHTML,\n  ObjetMathalea2D,\n} from '../../modules/2dGeneralites'\nimport FractionEtendue from '../../modules/FractionEtendue'\nimport { egal, randint } from '../../modules/outils'\nimport { BezierPath } from '../2d/courbes'\nimport { point, tracePoint } from '../2d/points'\nimport type { Repere } from '../2d/reperes'\nimport { choice } from '../outils/arrayOutils'\nimport { rangeMinMax } from '../outils/nombres'\nimport { stringNombre } from '../outils/texNombre'\nimport { brent, tableauDeVariation, variationsFonction } from './etudeFonction'\nimport { Matrice, matrice } from './Matrice'\nimport { chercheMinMaxLocal, Polynome } from './Polynome'\n\nexport type NoeudSpline = {\n  x: number\n  y: number\n  deriveeGauche: number\n  deriveeDroit: number\n  isVisible: boolean\n}\ntype OptionsNoeuds = {\n  color?: string\n  epaisseur?: number\n  taille?: number\n  style?: string\n  visible?: boolean\n  couleurDeRemplissage?: string\n}\n/**\n * Une fonction pour créer une Spline aléatoire\n * @param {number} n\n * @param {boolean} noeudsVisibles\n * @param {number} xMin\n * @param {number} step\n * @param {number} y0 ordonnée de départ de la spline aléatoire\n * @returns {Array<NoeudSpline>}\n */\nexport function noeudsSplineAleatoire(\n  n: number,\n  noeudsVisibles: boolean,\n  xMin = -n / 2,\n  y0 = 0,\n  step = 2,\n) {\n  const noeuds = []\n  const isVisible = noeudsVisibles\n\n  let y = y0\n  let deriveeDroit = Math.cos(Math.random() * Math.PI) * randint(1, 2)\n  for (let x = xMin; x < -xMin + 1; x += step) {\n    const y0 = y\n    noeuds.push({ x, y, deriveeGauche: deriveeDroit, deriveeDroit, isVisible })\n    do {\n      y = y + choice([-1, 1]) * randint(1, 2)\n    } while (y > 5 || y < -5)\n    do {\n      deriveeDroit = Math.cos(Math.random() * Math.PI) * randint(0, 2)\n    } while (deriveeDroit * (y - y0) < 0)\n  }\n  return noeuds\n}\n\n/**\n * Une fonction pour créer un nuage de noeuds différents d'un nuage passé en argument avec certaines options\n * @param {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>} noeudsF\n * @param {objet} options\n * @param {boolean} [options.symetrieH]\n * @param {boolean} [options.symetrieV]\n * @param {number} [options.echangeNoeuds]\n * @param {number} [options.decalVertical]\n * @param {number} [options.decalHorizontal]\n * @return {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>}\n */\ntype OptionsModifieNoeuds = {\n  symetrieH?: boolean\n  symetrieV?: boolean\n  echangeNoeuds?: number\n  decalVertical?: number\n  decalHorizontal?: number\n}\nexport function modifieNoeuds(\n  noeudsF: NoeudSpline[],\n  options: OptionsModifieNoeuds,\n) {\n  const noeudsG = noeudsF.map((el) =>\n    Object.assign(\n      {},\n      {\n        x: el.x,\n        y: el.y,\n        deriveeGauche: el.deriveeGauche,\n        deriveeDroit: el.deriveeDroit,\n        isVisible: el.isVisible,\n      },\n    ),\n  )\n  const nbNoeuds = noeudsF.length\n  if (options.symetrieH) {\n    for (let i = nbNoeuds; i > 0; i--) {\n      noeudsG[nbNoeuds - i] = {\n        x: noeudsF[nbNoeuds - i].x,\n        y: noeudsF[i - 1].y,\n        deriveeGauche: noeudsF[i - 1].deriveeDroit,\n        deriveeDroit: noeudsF[i - 1].deriveeGauche,\n        isVisible: noeudsF[i - 1].isVisible,\n      }\n    }\n  }\n  if (options.symetrieV) {\n    for (let i = 0; i < nbNoeuds; i++) {\n      noeudsG[i] = {\n        x: noeudsG[i].x,\n        y: -noeudsG[i].y,\n        deriveeGauche: -noeudsG[i].deriveeGauche,\n        deriveeDroit: -noeudsG[i].deriveeDroit,\n        isVisible: noeudsG[i].isVisible,\n      }\n    }\n  }\n  if (options.echangeNoeuds) {\n    const indices = rangeMinMax(0, nbNoeuds - 1)\n    // le nombre de modifications doit être pair car on va échanger 2 par 2 et il doit y en avoir moins que nbNoeuds.\n    const nbModifs =\n      options.echangeNoeuds ?? 2 * Math.round(randint(2, nbNoeuds) / 2)\n    const indiceDepartArrivee: number[] = []\n    for (let i = 0, cpt = 0; i < nbModifs / 2 && cpt < 50; ) {\n      const choix1 = choice(indices, indiceDepartArrivee)\n      const choix2 = choice(indices, indiceDepartArrivee)\n      if (choix1 != null && choix2 != null) {\n        indiceDepartArrivee.push(choix1, choix2)\n        i++\n      }\n      cpt++\n    }\n    for (let i = 0; i < indiceDepartArrivee.length; i += 2) {\n      // on va de 2 en 2 car les indices impairs sont les indices d'arrivée\n      const depart = indiceDepartArrivee[i]\n      const arrivee = indiceDepartArrivee[i + 1]\n      // on n'échange que si l'indice du noeud concerné est avant celui d'arrivée\n      const noeudInter = {\n        x: noeudsG[arrivee].x,\n        y: noeudsG[depart].y,\n        deriveeGauche: noeudsG[depart].deriveeGauche,\n        deriveeDroit: noeudsG[depart].deriveeDroit,\n        isVisible: noeudsG[depart].isVisible,\n      }\n      noeudsG[depart] = {\n        x: noeudsG[depart].x,\n        y: noeudsG[arrivee].y,\n        deriveeGauche: noeudsG[arrivee].deriveeGauche,\n        deriveeDroit: noeudsG[arrivee].deriveeDroit,\n        isVisible: noeudsG[arrivee].isVisible,\n      }\n      noeudsG[arrivee] = {\n        x: noeudInter.x,\n        y: noeudInter.y,\n        deriveeGauche: noeudInter.deriveeGauche,\n        deriveeDroit: noeudInter.deriveeDroit,\n        isVisible: noeudInter.isVisible,\n      }\n    }\n  }\n  if (options.decalVertical) {\n    const offset = Number.isInteger(options.decalVertical)\n      ? options.decalVertical\n      : randint(-2, 2, 0)\n    for (let i = 0; i < noeudsG.length; i++) {\n      noeudsG[i] = {\n        x: noeudsG[i].x,\n        y: noeudsG[i].y + offset,\n        deriveeGauche: noeudsG[i].deriveeGauche,\n        deriveeDroit: noeudsG[i].deriveeDroit,\n        isVisible: noeudsG[i].isVisible,\n      }\n    }\n  }\n  if (options.decalHorizontal) {\n    const offset = Number.isInteger(options.decalHorizontal)\n      ? options.decalHorizontal\n      : randint(-2, 2, 0)\n    for (let i = 0; i < noeudsG.length; i++) {\n      noeudsG[i] = {\n        x: noeudsG[i].x + offset,\n        y: noeudsG[i].y,\n        deriveeGauche: noeudsG[i].deriveeGauche,\n        deriveeDroit: noeudsG[i].deriveeDroit,\n        isVisible: noeudsG[i].isVisible,\n      }\n    }\n  }\n  return noeudsG\n}\n/**\n * Les noeuds sont des objets : {x,y, nombreDerive} attention à les donner dans l'ordre des x croissants\n * @author Jean-Claude Lhote\n */\nexport class Spline {\n  /**\n   * Passer au moins deux noeuds, sinon ça ne peut pas fonctionner d'où la valeur par défaut...\n   * @param {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>} noeuds la liste des noeuds avec leurs nombres dérivés\n   */\n  n: number\n  polys: Polynome[]\n  nbPointsForApiGeom: number\n  noeuds: NoeudSpline[]\n  x: number[]\n  y: number[]\n  visibles: boolean[]\n  fonctions: ((x: number) => number)[]\n\n  constructor(noeuds: NoeudSpline[]) {\n    this.polys = []\n    this.x = []\n    this.y = []\n    this.noeuds = []\n    this.visibles = []\n    this.nbPointsForApiGeom = 100 // On pourra modifier cette propriété avant de récupérer pointOfSpline\n    this.fonctions = []\n    if (noeuds == null || !Array.isArray(noeuds) || noeuds.length < 2) {\n      // on ne peut pas interpoler une courbe avec moins de 2 noeuds\n      window.notify('Spline : nombre de noeuds insuffisant', { noeuds })\n      noeuds = [\n        { x: -3, y: -5, deriveeGauche: 0, deriveeDroit: 2, isVisible: false },\n        { x: 3, y: 0, deriveeGauche: -2, deriveeDroit: -2, isVisible: false },\n      ]\n    }\n    if (!trieNoeuds(noeuds)) {\n      this.n = noeuds.length\n\n      window.notify(\n        'Il y a un problème avec ces noeuds (peut-être un doublon ?) ',\n        { noeuds },\n      )\n      return\n    } // les noeuds comportent une anomalie : deux valeur de x identiques\n    this.n = noeuds.length\n\n    for (let i = 0; i < noeuds.length - 1; i++) {\n      const x0 = noeuds[i].x\n      const y0 = noeuds[i].y\n      const d0 = noeuds[i].deriveeDroit\n      const x1 = noeuds[i + 1].x\n      const y1 = noeuds[i + 1].y\n      const d1 = noeuds[i + 1].deriveeGauche\n      const maMatrice = matrice([\n        [x0 ** 3, x0 ** 2, x0, 1],\n        [x1 ** 3, x1 ** 2, x1, 1],\n        [3 * x0 ** 2, 2 * x0, 1, 0],\n        [3 * x1 ** 2, 2 * x1, 1, 0],\n      ])\n      if (y0 + (x1 - x0) * d1 === y1 && d0 === d1) {\n        const a = (y1 - y0) / (x1 - x0)\n        const b = y0 - a * x0\n        this.polys.push(new Polynome({ coeffs: [b, a, 0, 0] }))\n      } else if (maMatrice != null) {\n        if (maMatrice.determinant() === 0) {\n          window.notify(\n            \"Spline : impossible de trouver un polynome ici car la matrice n'est pas inversible, il faut revoir vos noeuds : \",\n            {\n              noeudGauche: noeuds[i],\n              noeudDroit: noeuds[i + 1],\n            },\n          )\n          return\n        }\n        const matriceInverse = maMatrice.inverse()\n        if (matriceInverse != null) {\n          const vecteur = [y0, y1, d0, d1]\n          const prodV = matriceInverse.multiply(vecteur)\n          if (prodV != null) {\n            this.polys.push(\n              new Polynome({\n                useFraction: true,\n                coeffs: (prodV instanceof Matrice ? prodV.toArray() : prodV)\n                  .reverse()\n                  .map((el) => Number(Number(el).toFixed(6))), // parti pris : on arrondit au millionnième pour les entiers qui s'ignorent (pour les 1/3 c'est rapé, mais c'est suffisamment précis)\n              }),\n            )\n          } else {\n            window.notify(\n              \"Spline : impossible de trouver un polynome ici car la matrice n'est pas inversible, il faut revoir vos noeuds : \",\n              {\n                noeudGauche: noeuds[i],\n                noeudDroit: noeuds[i + 1],\n              },\n            )\n            return\n          }\n        }\n      }\n    }\n    this.noeuds = [...noeuds]\n    this.n = this.noeuds.length\n    this.x = this.noeuds.map((noeud) => noeud.x)\n    this.y = this.noeuds.map((noeud) => noeud.y)\n    this.visibles = this.noeuds.map((noeud) => noeud.isVisible) // On récupère la visibilité des noeuds pour la courbe\n    this.n = this.y.length // on a n valeurs de y et donc de x, soit n-1 intervalles numérotés de 1 à n-1.\n    // this.step = step // on en a besoin pour la dérivée...\n    this.fonctions = this.#convertPolyFunction()\n  }\n\n  get image() {\n    return this.fonction\n  }\n\n  pointsOfSpline(figure: Figure) {\n    const points: Point[] = []\n    const stepPoints =\n      (this.x[this.x.length - 1] - this.x[0]) / this.nbPointsForApiGeom // on fait 50 points ça devrait suffir...\n    let x = this.x[0]\n    do {\n      points.push(\n        figure.create('Point', { x, y: this.#image(x), isVisible: false }),\n      )\n      x += stepPoints\n    } while (x <= this.x[this.x.length - 1])\n    points.push(\n      figure.create('Point', {\n        x: this.x[this.x.length - 1],\n        y: this.#image(this.x[this.x.length - 1]),\n        isVisible: false,\n      }),\n    )\n    return points\n  }\n\n  /**\n   * convertit les polynomes en fonctions\n   * @returns {Function[]}\n   */\n  #convertPolyFunction(): ((x: number) => number)[] {\n    const f = []\n    for (let i = 0; i < this.n - 1; i++) {\n      f.push(this.polys[i].fonction)\n    }\n    return f\n  }\n\n  /**\n   * une méthode pour ajouter deux splines... et retourner une nouvelle spline !\n   * Attention ! il faut que les deux splines aient exactement le même nombre de noeuds, et que les abscisses de ces noeuds soient les mêmes !\n   * @param {Spline} s\n   * @param {boolean} opposite\n   */\n  add(s: Spline, opposite: boolean) {\n    if (this.n !== s.n) {\n      throw Error('Veuillez vous assurer de donner deux splines compatibles')\n    }\n    if (this.x.filter((el) => s.x.includes(el)).length !== this.n) {\n      throw Error('Veuillez vous assurer de donner deux splines compatibles')\n    }\n    const noeuds = []\n    for (let i = 0; i < this.n; i++) {\n      const x = this.x[i]\n      const y = this.y[i] + (opposite ? -1 : 1) * s.y[i]\n      const deriveeGauche =\n        this.noeuds[i].deriveeGauche +\n        (opposite ? -1 : 1) * s.noeuds[i].deriveeGauche\n      const deriveeDroit =\n        this.noeuds[i].deriveeDroit +\n        (opposite ? -1 : 1) * s.noeuds[i].deriveeDroit\n      const isVisible = this.noeuds[i].isVisible && s.noeuds[i].isVisible\n      noeuds.push({ x, y, deriveeGauche, deriveeDroit, isVisible })\n    }\n    return new Spline(noeuds)\n  }\n\n  zeros(precision = 1) {\n    const zeros = []\n    for (let x = this.x[0]; x < this.x[this.n - 1]; x += 0.5) {\n      if (this.#image(x) * this.#image(x + 0.5) < 0) {\n        const { root } = brent(this.fonction, x, x + 0.5, 0.000000001, 100)\n        if (root != null) zeros.push(round(root, precision))\n      } else {\n        if (this.#image(x) === 0) zeros.push(round(x, precision))\n        if (this.#image(x + 0.5) === 0) zeros.push(round(x + 0.5, precision))\n      }\n    }\n    return Array.from(new Set(zeros).values())\n  }\n\n  /**\n   * retourne les solutions de f(x) = y sur son domaine de définition\n   * @param {number} y\n   * @param {number} precision préciser la tolérance dans la recherche de solutions : une précision de 2 signifie que y-0.01<f(x)<y+0.01\n   * mettre 0 comme précision signifie potentiellement y-0.5<f(x)<y+0.5 !\n   * @returns {number[]}\n   */\n  solve(y: number, precision = 2) {\n    // On a eu des soucis plus loin dans polynome.add(-y) donc on s'assure que y est bien un number.\n    const yArg = y\n    y = Number(y)\n    if (!isNaN(y)) {\n      const antecedents: number[] = []\n      for (let i = 0; i < this.polys.length; i++) {\n        const polEquation = this.polys[i].add(-y) // Le polynome dont les racines sont les antécédents de y\n        // Algebrite n'aime pas beaucoup les coefficients decimaux...\n        try {\n          // si le polynome utilise des FractionEtendue, il faut les convertir au format mathjs pour polynomialRoot\n          const liste = polEquation.useFraction\n            ? polynomialRoot(...polEquation.monomes.map(Number))\n            : polynomialRoot(...polEquation.monomes.map(Number))\n          for (const valeur of liste) {\n            let arr\n            if (typeof valeur === 'number') {\n              arr = round(valeur, precision)\n            } else {\n              // complexe !\n              const module = valeur.toPolar().r\n              if (module < 10 ** (-precision - 4)) {\n                // module trop petit pour être complexe, c'est 0 !\n                arr = 0\n              } else {\n                const argument = valeur.arg()\n                if (\n                  Math.abs(argument) < 0.001 ||\n                  Math.abs(Math.abs(argument) - Math.PI) < 0.001\n                ) {\n                  // si l'argument est proche de 0 ou de Pi ou de -Pi\n                  arr = round(valeur.re, precision) // on prend la partie réelle\n                } else {\n                  arr = null // c'est une vraie racine complexe, du coup, on prend null\n                }\n              }\n            }\n            if (arr !== null && arr >= this.x[i] && arr <= this.x[i + 1]) {\n              if (!antecedents.includes(arr)) {\n                antecedents.push(arr)\n              }\n            }\n          }\n        } catch (e) {\n          const err = e instanceof Error ? e.message : String(e)\n          window.notify('Erreur dans Spline.solve()' + err, { valeur_de_y: y })\n        }\n      }\n      return antecedents\n    } else {\n      window.notify(\n        `Spline.solve() a reçu un truc bizarre à la place d'un nombre : ${yArg} !`,\n        { valeurArgument: yArg },\n      )\n    }\n  }\n\n  /**\n   * retourne un array décrivant les variations de la Spline sur son domaine de déf\n   * à améliorer... la fonction variationsFonctions ne travaille pas proprement. on peut faire beaucoup mieux avec Spline\n   * @returns {*[]|null}\n   */\n  variations(step: number | FractionEtendue = new FractionEtendue(1, 100)) {\n    return variationsFonction(\n      this.derivee,\n      this.noeuds[0].x,\n      this.noeuds[this.n - 1].x,\n      step,\n    )\n  }\n\n  /**\n   * retourne les signes pris par la Spline sur son domaine de déf\n   * à améliorer... la fonction signesFonctions ne travaille pas proprement. on peut faire beaucoup mieux avec Spline\n   * @returns {T[]}\n   */\n  signes() {\n    const signes = []\n    const zeros = this.zeros(1)\n    let x\n    if (zeros.length === 0) {\n      return [\n        {\n          xG: this.x[0],\n          xD: this.x[this.n - 1],\n          signe: this.y[0] > 0 ? '+' : '-',\n        },\n      ]\n    }\n    if (this.x[0] !== zeros[0])\n      signes.push({\n        xG: this.x[0],\n        xD: zeros[0],\n        signe: this.y[0] > 0 ? '+' : '-',\n      })\n    x = zeros[0]\n    signes.push({ xG: zeros[0], xD: zeros[0], signe: 'z' })\n    for (let i = 1; i < zeros.length; i++) {\n      const y = this.#image((x + zeros[i]) / 2)\n      signes.push({ xG: x, xD: zeros[i], signe: y > 0 ? '+' : '-' })\n      signes.push({ xG: zeros[i], xD: zeros[i], signe: 'z' })\n      x = zeros[i]\n    }\n    if (zeros[zeros.length - 1] === this.x[this.n - 1]) return signes\n    const y = this.#image((zeros[zeros.length - 1] + this.x[this.n - 1]) / 2)\n    signes.push({\n      xG: zeros[zeros.length - 1],\n      xD: this.x[this.n - 1],\n      signe: y > 0 ? '+' : '-',\n    })\n    return signes // signesFonction(this.fonction, this.noeuds[0].x, this.noeuds[this.n - 1].x, step ?? new FractionEtendue(1, 10), 0.001)\n  }\n\n  /**\n   * renvoie le tableau de signes d'une fonction\n   * @param fonction\n   * @param {object} options\n   * @param {string} [options.nomVariable] // ce qui est écrit dans l'entête de la première ligne 'x' par défaut\n   * @param {string} [options.nomFonction] // ce qui est écrit dans l'entête de la première ligne 'x' par défaut\n   * @returns {string} [options.nomFonction] // ce  qui est écrit dans l'entête de la deuxième ligne 'f(x)' par défaut\n   */\n  tableauSignes(nomVariable = 'x', nomFonction = 'f(x)') {\n    const signes = this.signes()\n    const premiereLigne = []\n    for (let i = 0; i < signes.length; i++) {\n      if (i === 0) {\n        premiereLigne.push(stringNombre(signes[0].xG, 2), 10)\n      }\n      if (i > 0 && signes[i].xG !== signes[i - 1].xG) {\n        premiereLigne.push(stringNombre(signes[i].xG, 2), 10)\n      }\n    }\n    if (signes[signes.length - 1].xD !== signes[signes.length - 1].xG)\n      premiereLigne.push(stringNombre(signes[signes.length - 1].xD, 2), 10)\n    const tabLine = ['Line', 30]\n    if (!egal(this.#image(this.x[0]), 0)) {\n      tabLine.push('', 10)\n    }\n\n    for (let i = 0; i < signes.length; i++) {\n      tabLine.push(signes[i].signe, 10)\n    }\n\n    return tableauDeVariation({\n      tabInit: [\n        [\n          [nomVariable, 2, 10],\n          [nomFonction, 2, 10],\n        ],\n        premiereLigne,\n      ],\n      tabLines: [tabLine],\n      colorBackground: '',\n      espcl: 3.5, // taille en cm entre deux antécédents\n      deltacl: 0.8, // distance entre la bordure et les premiers et derniers antécédents\n      lgt: 8, // taille de la première colonne en cm\n    })\n  }\n\n  /**\n   * retourne le nombre d'antécédents entiers trouvés pour une valeur y donnée\n   * @param {number} y\n   * @returns {number}\n   */\n  nombreAntecedentsEntiers(y: number) {\n    const solutions = this.solve(y)\n    const solutionsEntieres =\n      solutions?.filter((sol) => Number.isInteger(sol)) ?? []\n    return solutionsEntieres.length\n  }\n\n  /**\n   * retourne le nombre d'antécédents de y\n   * @param {number} y\n   * @returns {number}\n   */\n  nombreAntecedents(y: number) {\n    const solutions = this.solve(y)\n    return solutions?.length ?? 0\n  }\n\n  nombreAntecedentsMaximum(\n    yMin: number,\n    yMax: number,\n    yentier = true,\n    entiers = true,\n  ) {\n    let nbMax = 0\n    for (let k = yMin; k < yMax; k += yentier ? 1 : 0.1) {\n      if (entiers) {\n        nbMax = Math.max(nbMax, this.nombreAntecedentsEntiers(k))\n      } else {\n        nbMax = Math.max(nbMax, this.nombreAntecedents(k))\n      }\n    }\n    return nbMax\n  }\n\n  /**\n   * Retourne une valeur de y (si trouvée) pour laquelle il y a exactement n antécédents\n   * @param {number} n\n   * @param {number} yMin\n   * @param {number} yMax\n   * @returns {boolean|string|*}\n   */\n  trouveYPourNAntecedents(\n    n: number,\n    yMin: number,\n    yMax: number,\n    yEntier = true,\n    antecedentsEntiers = true,\n  ) {\n    const candidats = []\n    if (Number.isInteger(yMin) && Number.isInteger(yMax)) {\n      if (yEntier) {\n        for (let y = yMin; y <= yMax; y++) {\n          if (\n            (antecedentsEntiers &&\n              this.nombreAntecedentsEntiers(y) === n &&\n              this.nombreAntecedents(y) === n) ||\n            (!antecedentsEntiers && this.nombreAntecedents(y) === n)\n          ) {\n            candidats.push(y)\n          }\n        }\n      } else {\n        // ici, on n'a pas trouvé avec y entier entre xMin et yMax, on recommence avec un pas de 0.1\n        for (let y = yMin; y <= yMax; y += 0.1) {\n          if (\n            (antecedentsEntiers &&\n              this.nombreAntecedentsEntiers(y) === n &&\n              this.nombreAntecedents(y) === n) ||\n            (!antecedentsEntiers && this.nombreAntecedents(y) === n)\n          ) {\n            candidats.push(y)\n          }\n        }\n      }\n    } else {\n      window.notify(\n        'trouveYPourNAntecedentsEntiers() appelé avec des valeurs incorrectes',\n        { n, yMin, yMax },\n      )\n    }\n    if (candidats.length < 1) {\n      // window.notify('trouveYPourNAntecedents() : Je n\\'ai rien trouvé !', { n, yMin, yMax })\n      return false\n    }\n    return choice(candidats) // normalement, il ne devrait jamais retourner cette valeur.\n  }\n\n  /**\n   * retourne les min et max pour un repère contenant la courbe si ceux-ci sont sur des noeuds (c'est vivement conseillé)\n   * Ne fonctionne pas si yMax ou yMin sont atteints entre deux noeuds\n   */\n  trouveMaxes(): { xMin: number; xMax: number; yMin: number; yMax: number } {\n    if (Array.isArray(this.noeuds) && this.noeuds.length > 0) {\n      const xMin = Math.ceil(Math.min(...this.noeuds.map((el) => el.x)))\n      const yMin = Math.ceil(Math.min(...this.noeuds.map((el) => el.y)))\n      const xMax = Math.floor(Math.max(...this.noeuds.map((el) => el.x)))\n      const yMax = Math.floor(Math.max(...this.noeuds.map((el) => el.y)))\n      return { xMin, xMax, yMin, yMax }\n    } else {\n      window.notify(\n        \"Spline.trouveMaxes() on demande ça alors que la Spline n'a pas de noeuds !\",\n        { laSpline: JSON.stringify(this) },\n      )\n      return { xMin: 0, xMax: 0, yMin: 0, yMax: 0 }\n    }\n  }\n\n  /**\n   * retourne le minimum et le maximum de la fonction\n   * @returns {{yMin: number, yMax: number}}\n   */\n  amplitude() {\n    let yMin = 1000\n    let yMax = -1000\n    for (let i = 0; i < this.x.length - 1; i++) {\n      const { minLocal, maxLocal } = chercheMinMaxLocal({\n        poly: this.polys[i],\n        xG: this.x[i],\n        xD: this.x[i + 1],\n      })\n      yMin = Math.min(yMin, minLocal)\n      yMax = Math.max(yMax, maxLocal)\n    }\n    return { yMin, yMax }\n  }\n\n  /**\n   * fournit la fonction à passer pour simuler une fonction mathématique du type (x)=>f(x)\n   * @returns {function(*): number|*}\n   */\n  get fonction() {\n    return (x: number) => this.#image(x)\n  }\n\n  /**\n   * Retourne l'image de x par la fonction\n   * @param {number} x\n   * @returns {number}\n   */\n  #image(x: unknown) {\n    if (typeof x !== 'number') {\n      if (x instanceof FractionEtendue) {\n        x = x.valeurDecimale\n      } else if (x instanceof Decimal) {\n        x = x.toNumber()\n      }\n    }\n    const xNumber = x as number\n    let trouveK = false\n    let k = 0\n    for (let i = 0; i < this.n - 1; i++) {\n      if (xNumber >= this.x[i] && xNumber <= this.x[i + 1]) {\n        k = i\n        trouveK = true\n        break\n      }\n    }\n    if (!trouveK) {\n      const intervalle = `D = [${this.x[0]} ; ${this.x[this.n - 1]}]`\n      window.notify(\n        \"Spline: la valeur de x fournie n'est pas dans lìntervalle de définition de la fonction\",\n        {\n          x,\n          intervalle,\n        },\n      )\n      return NaN\n    } else {\n      return this.fonctions[k](xNumber)\n    }\n  }\n\n  /**\n   * retourne un array de polynomes dérivés (degré 2) de ceux de la Spline utilisé par derivee() pour définir la dérivée pour tout x du domaine\n   * la fonction est continue, mais les dérivées à gauche et à droite des noeuds ne seront pas identiques\n   * donc on ne peut pas en faire une Spline.\n   */\n  get derivees() {\n    const derivees = []\n    for (let i = 0; i < this.polys.length; i++) {\n      derivees.push(this.polys[i].derivee())\n    }\n    return derivees\n  }\n\n  /**\n   * retourne une fonction dérivée de la spline sur son domaine de définition\n   */\n  get derivee() {\n    const intervalles: { xG: number; xD: number }[] = []\n    for (let i = 0; i < this.noeuds.length - 1; i++) {\n      intervalles.push({ xG: this.noeuds[i].x, xD: this.noeuds[i + 1].x })\n    }\n    return (x: number) => {\n      const index = intervalles.findIndex(\n        (intervalle) => x >= intervalle.xG && x <= intervalle.xD,\n      )\n      return this.derivees[index].image(x)\n    }\n  }\n\n  /** retourne une spline construite avec les valeurs dérivées aux noeuds de la spline.\n   * Il faut impérativement que cette fonction soit continue donc les nombre dérivés à gauche et à droite en chacun des noeuds doivent être égaux !\n   */\n  get splineDerivee() {\n    const noeudsDerivee /** Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}> */ =\n      []\n    for (const noeud of this.noeuds) {\n      noeudsDerivee.push({\n        x: noeud.x,\n        y: noeud.deriveeGauche,\n        deriveeGauche: 0,\n        deriveeDroit: 0,\n        isVisible: noeud.isVisible,\n      })\n    }\n    return new Spline(noeudsDerivee)\n  }\n\n  /**\n   * crée l'objet mathalea2d correspondant à la courbe tracée\n   * @param {Repere} repere\n   * @param {string} color\n   * @param {number} epaisseur\n   * @param {boolean} ajouteNoeuds\n   * @param {Object} optionsNoeuds\n   * @returns {Trace}\n   */\n  courbe({\n    color = 'black',\n    epaisseur = 1,\n    ajouteNoeuds = false,\n    optionsNoeuds = {},\n  }: {\n    color?: string\n    epaisseur?: number\n    ajouteNoeuds?: boolean\n    optionsNoeuds?: Object\n  } = {}) {\n    return new Trace(this, {\n      color,\n      epaisseur,\n      ajouteNoeuds,\n      optionsNoeuds,\n    })\n  }\n}\n\n/**\n * un raccourcis pour new Spline(noeuds)\n * @param {Array<{x: number, y:number, deriveeGauche:number, deriveeDroit:number, isVisible:boolean}>} noeuds\n * @returns {Spline}\n */\nexport function spline(noeuds: NoeudSpline[]) {\n  return new Spline(noeuds)\n}\n\n/**\n * Fonction qui trie des noeuds pour Spline afin de les remettre dans l'ordre des x croissant\n * @param {Array<{x: number, y:number,nombreDerive:number}>} noeuds\n * @author Jean-Claude Lhote\n */\nexport function trieNoeuds(noeuds: NoeudSpline[]) {\n  let xInter, yInter, dGaucheInter, dDroitInter, isVisibleInter\n  for (let i = 0; i < noeuds.length - 1; i++) {\n    for (let j = i + 1; j < noeuds.length; j++) {\n      if (noeuds[i].x > noeuds[j].x) {\n        xInter = noeuds[i].x\n        yInter = noeuds[i].y\n        dGaucheInter = noeuds[i].deriveeGauche\n        dDroitInter = noeuds[i].deriveeDroit\n        isVisibleInter = noeuds[i].isVisible\n        noeuds[i].x = noeuds[j].x\n        noeuds[i].y = noeuds[j].y\n        noeuds[i].deriveeGauche = noeuds[j].deriveeGauche\n        noeuds[i].deriveeDroit = noeuds[j].deriveeDroit\n        noeuds[i].isVisible = noeuds[j].isVisible\n        noeuds[j].x = xInter\n        noeuds[j].y = yInter\n        noeuds[j].deriveeGauche = dGaucheInter\n        noeuds[j].deriveeDroit = dDroitInter\n        noeuds[j].isVisible = isVisibleInter\n      } else if (egal(noeuds[i].x, noeuds[j].x)) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * @class\n * crée la courbe de la spline (objet mathalea2d)\n */\nexport class Trace extends ObjetMathalea2D {\n  /**\n   * @param {Spline}spline La splineCatmulRom ou Spline dont on veut la Trace\n   * @param {Repere} repere le repère associé\n   * @param {number} step le pas entre deux points\n   * @param {string} color la couleur\n   * @param {number} epaisseur son épaisseur\n   * @param {boolean} ajouteNoeuds si true, des points sont ajoutés aux endroits des noeuds\n   * @param {Object} optionsNoeud\n   */\n  constructor(\n    spline: Spline,\n    {\n      color = 'black',\n      epaisseur = 2,\n      opacite = 1,\n      ajouteNoeuds = true,\n      optionsNoeuds = {},\n    }: {\n      color?: string\n      epaisseur?: number\n      opacite?: number\n      ajouteNoeuds?: boolean\n      optionsNoeuds?: OptionsNoeuds\n    },\n  ) {\n    super()\n    this.objets = []\n    const { xMin, xMax, yMin, yMax } = spline.trouveMaxes()\n    this.bordures = [xMin, yMin, xMax, yMax]\n    const listeOfTriplets: [\n      [number, number],\n      [number, number],\n      [number, number],\n    ][] = []\n\n    for (let i = 0; i < spline.n - 1; i++) {\n      const deltaX = spline.x[i + 1] - spline.x[i]\n      const deltaY = spline.y[i + 1] - spline.y[i]\n      const x1 = deltaX / 3\n      const y1 = (spline.noeuds[i].deriveeDroit * deltaX) / 3\n      const x2 = (2 * deltaX) / 3\n      const y2 = deltaY - (spline.noeuds[i + 1].deriveeGauche * deltaX) / 3\n      const x3 = deltaX\n      const y3 = deltaY\n      listeOfTriplets.push([\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n      ])\n    }\n    this.objets.push(\n      new BezierPath({\n        xStart: spline.x[0],\n        yStart: spline.y[0],\n        listeOfTriplets,\n        color,\n        epaisseur,\n        opacite,\n      }),\n    )\n    if (ajouteNoeuds) {\n      for (let i = 0; i < spline.n; i++) {\n        if (spline.visibles[i]) {\n          const noeud = point(spline.x[i], spline.y[i])\n          const traceNoeud = tracePoint(noeud)\n          if (optionsNoeuds) {\n            if (optionsNoeuds.color) {\n              traceNoeud.color = colorToLatexOrHTML(optionsNoeuds.color)\n              traceNoeud.couleurDeRemplissage = colorToLatexOrHTML(\n                optionsNoeuds.color,\n              )\n            }\n            if (optionsNoeuds.epaisseur) {\n              traceNoeud.epaisseur = optionsNoeuds.epaisseur\n            }\n            if (optionsNoeuds.style) {\n              traceNoeud.style = optionsNoeuds.style\n            }\n            if (optionsNoeuds.taille) {\n              traceNoeud.taille = optionsNoeuds.taille\n            }\n          }\n          this.objets.push(traceNoeud)\n        }\n      }\n    }\n    this.svg = function (coeff) {\n      let code = ''\n      if (this.objets == null) return code\n      for (const objet of this.objets) {\n        code += '\\n\\t' + objet.svg(coeff)\n      }\n      return code\n    }\n    this.tikz = function () {\n      let code = ''\n      if (this.objets == null) return code\n      for (const objet of this.objets) {\n        code += objet.tikz()\n      }\n      return code\n    }\n  }\n}\n"],"names":["noeudsSplineAleatoire","n","noeudsVisibles","xMin","y0","step","noeuds","isVisible","y","deriveeDroit","randint","x","choice","_Spline","__privateAdd","_Spline_instances","__publicField","trieNoeuds","i","x0","d0","x1","y1","d1","maMatrice","matrice","a","b","Polynome","matriceInverse","vecteur","prodV","Matrice","el","noeud","__privateMethod","convertPolyFunction_fn","figure","points","stepPoints","image_fn","s","opposite","deriveeGauche","precision","zeros","root","brent","round","yArg","antecedents","polEquation","liste","polynomialRoot","valeur","arr","argument","e","err","FractionEtendue","variationsFonction","signes","nomVariable","nomFonction","premiereLigne","stringNombre","tabLine","egal","tableauDeVariation","solutions","sol","yMin","yMax","yentier","entiers","nbMax","k","yEntier","antecedentsEntiers","candidats","xMax","minLocal","maxLocal","chercheMinMaxLocal","derivees","intervalles","index","intervalle","noeudsDerivee","color","epaisseur","ajouteNoeuds","optionsNoeuds","Trace","f","Decimal","xNumber","trouveK","Spline","spline","xInter","yInter","dGaucheInter","dDroitInter","isVisibleInter","j","ObjetMathalea2D","opacite","listeOfTriplets","deltaX","deltaY","x2","y2","x3","y3","BezierPath","point","traceNoeud","tracePoint","colorToLatexOrHTML","coeff","code","objet"],"mappings":"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"}
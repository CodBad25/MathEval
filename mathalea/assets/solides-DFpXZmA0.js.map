{"version":3,"file":"solides-DFpXZmA0.js","sources":["../../src/lib/3d/3dProjectionMathalea2d/solides.ts"],"sourcesContent":["import {\n  ObjetMathalea2D,\n  assombrirOuEclaircir,\n  colorToLatexOrHTML,\n  vide2d,\n} from '../../../modules/2dGeneralites'\nimport { rotation3d, translation3d, homothetie3d } from './tranformations'\nimport { context } from '../../../modules/context'\nimport { droite, distancePointDroite } from '../../2d/droites'\nimport {\n  Point,\n  point,\n  pointIntersectionDD,\n  tracePoint,\n  pointSurSegment,\n  pointDepuisPointAbstrait,\n} from '../../2d/points'\nimport {\n  polygone,\n  polyline,\n  renommePolygone,\n  polygoneAvecNom,\n} from '../../2d/polygones'\nimport { segment, longueur, vecteur, norme } from '../../2d/segmentsVecteurs'\nimport { labelPoint } from '../../2d/textes'\nimport { translation } from '../../2d/transformations'\nimport { choisitLettresDifferentes } from '../../outils/aleatoires'\nimport { arrondi } from '../../outils/nombres'\nimport {\n  Point3d,\n  Vecteur3d,\n  droite3d,\n  point3d,\n  vecteur3d,\n  cercle3d,\n  polygone3d,\n  demicercle3d,\n  Polygone3d,\n  arete3d,\n} from './elements'\nimport { cross, dot, matrix, multiply, norm } from 'mathjs'\n\nexport const math = { matrix, multiply, norm, cross, dot }\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%% OBJETS COMPLEXES %%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n*/\n/**\n * LA SPHERE - ANCIENNE FONCTION\n *\n * @author Jean-Claude Lhote\n * Produit une sphère : choisir un nombre de parallèles impair pour avoir l'équateur. normal défini l'axe Nord-Sud.\n * rayon est le rayon de la sphère. l'équateur est dans le plan xy l'axe Nord-Sud est sur z\n * @param {Point3d} centre\n * @param {Number} rayon\n * @param {Number} nbParalleles\n * @param {Number} nbMeridiens\n * @param {string} color\n */\n/**\n * Classe de la sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {number} rayon Rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison angle d'inclinaison de l'axe N-S\n * @param {boolean} faceCachee Si false on économise tout ce qui est en pointillé à l'arrière.\n * @property {Point3d} centre Centre de la sphère\n * @property {Vecteur3d} rayon Rayon de la sphère\n * @property {string} colorEquateur Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @property {string} colorEnveloppe Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbParalleles Le nombre de parallèles au total\n * @property {string} colorParalleles Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @property {number} nbMeridiens Le nombre de méridiens au total\n * @property {string} colorMeridiens Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe de la sphère.\n * @property {string} colorAxe Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @class\n */\n\nexport class Sphere3d extends ObjetMathalea2D {\n  constructor(\n    centre: Point3d,\n    rayon: Vecteur3d,\n    colorEquateur = 'red',\n    colorEnveloppe = 'blue',\n    nbParalleles = 0,\n    colorParalleles = 'gray',\n    nbMeridiens = 0,\n    colorMeridiens = 'gray',\n    affichageAxe = false,\n    colorAxe = 'black',\n    inclinaison = 0,\n    faceCachee = true,\n  ) {\n    super()\n    this.centre = centre\n    this.rayon = rayon\n    this.objets = []\n    this.colorEquateur = colorEquateur\n    this.colorEnveloppe = colorEnveloppe\n    this.nbParalleles = nbParalleles\n    this.colorParalleles = colorParalleles\n    this.nbMeridiens = nbMeridiens\n    this.colorMeridiens = colorMeridiens\n    this.affichageAxe = affichageAxe\n    this.colorAxe = colorAxe\n    const droiteRot = droite3d(\n      point3d(this.centre.x, this.centre.y, this.centre.z),\n      vecteur3d(0, 1, 0),\n    )\n    const poleNord = rotation3d(\n      point3d(\n        this.centre.x,\n        this.centre.y,\n        this.centre.z + this.rayon,\n        true,\n        choisitLettresDifferentes(1, 'OQWX' + this.centre.label)[0],\n        'left',\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    const poleSud = rotation3d(\n      point3d(\n        this.centre.x,\n        this.centre.y,\n        this.centre.z - this.rayon,\n        true,\n        choisitLettresDifferentes(\n          1,\n          'OQWX' + this.centre.label + poleNord.label,\n        )[0],\n        'left',\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    const nbParallelesDeConstruction = 36 // Ce nb de paralleles permet de construire l'enveloppe de la sphère (le \"cercle\" apparent de la sphère)\n    const divisionParalleles =\n      this.nbParalleles !== 0\n        ? Math.round((2 * nbParallelesDeConstruction) / this.nbParalleles)\n        : 1\n    let unDesParalleles\n    let centreParallele\n    let rayonDuParallele\n    let normal\n    const paralleles: {\n      listePoints3d: Point3d[][]\n      ptCachePremier: Point[]\n      indicePtCachePremier: number[]\n      ptCacheDernier: Point[]\n      indicePtCacheDernier: number[]\n    } = {\n      listePoints3d: [],\n      ptCachePremier: [],\n      indicePtCachePremier: [],\n      ptCacheDernier: [],\n      indicePtCacheDernier: [],\n    }\n    const enveloppeSphere1: Point[] = []\n    let enveloppeSphere2: Point[] = []\n    let premierParallele = 100\n    let indicePremier = 0\n    let indiceDernier = 0\n    this.c2d = []\n\n    // Construction de tous les paralleles\n    // Construction du parallèle le plus proche du pôle nord\n    centreParallele = rotation3d(\n      point3d(\n        this.centre.x,\n        this.centre.y,\n        this.centre.z +\n          this.rayon *\n            Math.sin(\n              (((nbParallelesDeConstruction - 1) / nbParallelesDeConstruction) *\n                Math.PI) /\n                2,\n            ),\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    rayonDuParallele = rotation3d(\n      vecteur3d(\n        this.rayon *\n          Math.cos(\n            (((nbParallelesDeConstruction - 1) / nbParallelesDeConstruction) *\n              Math.PI) /\n              2,\n          ),\n        0,\n        0,\n      ),\n      droiteRot,\n      inclinaison,\n    )\n    normal = rotation3d(vecteur3d(0, 0, 1), droiteRot, inclinaison)\n    unDesParalleles = cercle3d(centreParallele, normal, rayonDuParallele)\n    paralleles.listePoints3d.push(unDesParalleles[1])\n    paralleles.ptCachePremier.push(point(0, 0))\n    paralleles.indicePtCachePremier.push(0)\n    paralleles.ptCacheDernier.push(point(0, 0))\n    paralleles.indicePtCacheDernier.push(0)\n\n    // Construction de tous les autres parallèles jusqu'au plus proche du pôle sud\n    for (\n      let k = nbParallelesDeConstruction - 2, poly, j = 1;\n      k > -nbParallelesDeConstruction;\n      k -= 1\n    ) {\n      centreParallele = rotation3d(\n        point3d(\n          this.centre.x,\n          this.centre.y,\n          this.centre.z +\n            this.rayon *\n              Math.sin(((k / nbParallelesDeConstruction) * Math.PI) / 2),\n        ),\n        droiteRot,\n        inclinaison,\n      )\n      rayonDuParallele = rotation3d(\n        vecteur3d(\n          this.rayon *\n            Math.cos(((k / nbParallelesDeConstruction) * Math.PI) / 2),\n          0,\n          0,\n        ),\n        droiteRot,\n        inclinaison,\n      )\n\n      normal = rotation3d(vecteur3d(0, 0, 1), droiteRot, inclinaison)\n      poly = polygone(unDesParalleles[2])\n      unDesParalleles = cercle3d(\n        centreParallele,\n        normal,\n        rayonDuParallele,\n        false,\n      )\n      paralleles.listePoints3d.push(unDesParalleles[1])\n      for (let ee = 0; ee < paralleles.listePoints3d[0].length; ee++) {\n        paralleles.listePoints3d[j][ee].isVisible =\n          !paralleles.listePoints3d[j][ee].c2d.estDansPolygone(poly)\n      }\n      paralleles.ptCachePremier.push(point(0, 0))\n      paralleles.indicePtCachePremier.push(0)\n      paralleles.ptCacheDernier.push(point(0, 0))\n      paralleles.indicePtCacheDernier.push(0)\n\n      for (\n        let ee = 0, s, s1, d1, d2, jj, pt;\n        ee < paralleles.listePoints3d[0].length;\n        ee++\n      ) {\n        s = segment(\n          paralleles.listePoints3d[j][ee].c2d,\n          paralleles.listePoints3d[j][\n            (ee + 1) % paralleles.listePoints3d[0].length\n          ].c2d,\n        )\n        // Recherche du point d'intersection entre le parallèle actuel et le précédent.\n        if (\n          !paralleles.listePoints3d[j][ee].isVisible &&\n          paralleles.listePoints3d[j][\n            (ee + 1) % paralleles.listePoints3d[0].length\n          ].isVisible\n        ) {\n          jj = ee - 3\n          s1 = droite(\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj - 1) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n          )\n          // Le point d'intersection avec ce segment précis du parallèle actuel est avec l'un des 7 (nombre totalement empirique) segments les plus proches du parallèle précédent.\n          let cptBoucleInfinie = 0\n          while (!s.estSecant(s1) && cptBoucleInfinie < 7) {\n            jj++\n            s1 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            cptBoucleInfinie++\n          }\n          if (cptBoucleInfinie === 7) {\n            // console.info('Boucle infinie')\n          } else {\n            // s étant secant avec s1, on mène plusieurs actions :\n            d1 = droite(\n              paralleles.listePoints3d[j][ee].c2d,\n              paralleles.listePoints3d[j][\n                (ee + 1) % paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            d2 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            pt = pointIntersectionDD(d1, d2) // 1) Tout d'abord, ce point d'intersection est donc la frontière entre le visible et le caché et on l'enregistre comme élément de l'enveloppe de la sphère\n            if (!pt) {\n              window.notify(\n                \"Erreur dans le calcul du point d'intersection entre d1 et d2\",\n                { d1, d2 },\n              )\n              continue\n            }\n            enveloppeSphere1.push(pt)\n            //  2) Ensuite, si pt est le tout premier point d'intersection trouvé, on enregistre quel est le premier parallèle et quel est son indice\n            // Ces informmations serviront pour le tracé de l'enveloppe près du pôle Nord.\n            if (premierParallele >= j) {\n              premierParallele = j\n              indicePremier = jj % paralleles.listePoints3d[0].length\n            }\n            // 3) On note ce point pour le futur tracé du parallèle, si besoin\n            paralleles.ptCachePremier[j] = pt\n            paralleles.indicePtCachePremier[j] = ee\n          }\n        } else if (\n          paralleles.listePoints3d[j][ee].isVisible &&\n          !paralleles.listePoints3d[j][\n            (ee + 1) % paralleles.listePoints3d[0].length\n          ].isVisible\n        ) {\n          // Si le point précédent était l'entrée dans la partie cachée, alors celui-ci sera celui de l'entrée dans la partie visible (ou inversement)\n          // car pour chaque parallèle intersecté avec le précédent, il y a \"forcément\" deux points sauf tangence mais ce n'est pas un pb.\n          jj = ee - 3\n          s1 = droite(\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n            paralleles.listePoints3d[j - 1][\n              (paralleles.listePoints3d[0].length + jj - 1) %\n                paralleles.listePoints3d[0].length\n            ].c2d,\n          )\n          // On recherche le point d'intersection\n          let cptBoucleInfinie = 0\n          while (!s.estSecant(s1) && cptBoucleInfinie < 7) {\n            jj++\n            s1 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            cptBoucleInfinie++\n          }\n          if (cptBoucleInfinie === 7) {\n            // console.info('Boucle infinie')\n          } else {\n            // s étant secant avec s1, on mène plusieurs actions :\n            d1 = droite(\n              paralleles.listePoints3d[j][ee].c2d,\n              paralleles.listePoints3d[j][\n                (ee + 1) % paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            d2 = droite(\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n              paralleles.listePoints3d[j - 1][\n                (paralleles.listePoints3d[0].length + jj - 1) %\n                  paralleles.listePoints3d[0].length\n              ].c2d,\n            )\n            pt = pointIntersectionDD(d1, d2)\n            if (!pt) {\n              window.notify(\n                \"Erreur dans le calcul du point d'intersection entre d1 et d2\",\n                { d1, d2 },\n              )\n              continue\n            }\n            // 1) Tout d'abord, ce point d'intersection est donc la frontière entre le visible et le caché et on l'enregistre comme élément de l'enveloppe de la sphère\n            enveloppeSphere2.push(pt)\n            // 2) Ensuite, si pt est le tout premier point d'intersection trouvé, on enregistre quel est le premier parallèle et quel est son indice\n            // Ces informmations serviront pour le tracé de l'enveloppe près du pôle Sud.\n            if (premierParallele >= j) {\n              premierParallele = j\n              indiceDernier = jj\n            }\n            // 3) On note ce point pour le futur tracé du parallèle, si besoin\n            paralleles.ptCacheDernier[j] = pt\n            paralleles.indicePtCacheDernier[j] = ee\n          }\n        }\n      }\n      j++\n    }\n\n    if (this.nbParalleles !== 0) {\n      let t = tracePoint(poleNord.c2d, this.colorParalleles)\n      t.style = 'o'\n      t.taille = 0.5\n      this.c2d.push(t)\n      t = tracePoint(\n        poleSud.c2d,\n        assombrirOuEclaircir(this.colorParalleles, 50),\n      )\n      t.style = 'o'\n      t.taille = 0.5\n      this.c2d.push(t)\n    }\n\n    // Construction des parallèles demandés\n    for (\n      let k = nbParallelesDeConstruction, j = -1;\n      k > -nbParallelesDeConstruction;\n      k -= 1\n    ) {\n      const polyLineVisible = [] // Contient l'ensemble des points du parallèle contenus dans la partie visible\n      let polyLineCachee = [] // Idem pour la partie cachée.\n      if (\n        (this.nbParalleles !== 0 || k === 0) &&\n        k !== nbParallelesDeConstruction &&\n        k % divisionParalleles === 0\n      ) {\n        // k=0 : C'est l'équateur\n        for (let ee = 0; ee < paralleles.listePoints3d[0].length; ee++) {\n          if (paralleles.indicePtCachePremier[j] === ee) {\n            polyLineCachee.push(paralleles.ptCachePremier[j])\n          } else if (paralleles.indicePtCacheDernier[j] === ee) {\n            polyLineCachee.push(paralleles.ptCacheDernier[j])\n          } else {\n            // Tracé des pointilles ou pas des parallèles\n            if (\n              !paralleles.listePoints3d[j][ee].isVisible &&\n              !paralleles.listePoints3d[j][\n                (ee + 1) % paralleles.listePoints3d[0].length\n              ].isVisible\n            ) {\n              polyLineCachee.push(paralleles.listePoints3d[j][ee].c2d)\n            } else {\n              polyLineVisible.push(\n                paralleles.listePoints3d[j][\n                  (ee + 1) % paralleles.listePoints3d[0].length\n                ].c2d,\n              )\n            }\n          }\n        }\n        if (k < 36 && k > -30) {\n          // uniquement à bonne distance des pôles pour éviter les points trop proches\n          let securite = 0\n          if (polyLineCachee.length > 4) {\n            // une précaution au cas où la liste de points est courte ça pourrait boucler à l'infini\n            while (\n              securite < 10 &&\n              longueur(\n                polyLineCachee[polyLineCachee.length - 1],\n                polyLineCachee[0],\n              ) < 1\n            ) {\n              const dernierPoint = polyLineCachee.pop()\n              if (dernierPoint)\n                polyLineCachee = [\n                  point(dernierPoint.x, dernierPoint.y),\n                  ...polyLineCachee,\n                ]\n              securite++\n            }\n          }\n          if (polyLineVisible.length > 4) {\n            while (\n              securite < 20 &&\n              longueur(\n                polyLineVisible[polyLineVisible.length - 1],\n                polyLineVisible[0],\n              ) < 1\n            ) {\n              const premierPoint = polyLineVisible.shift()\n              if (premierPoint)\n                polyLineVisible.push(point(premierPoint.x, premierPoint.y))\n              securite++\n            }\n          }\n        }\n        if (faceCachee) {\n          const ligneCachee =\n            polyLineCachee.length > 0 ? polyline(...polyLineCachee) : null // parfois, il n'y a rien à cacher près du pôle nord\n          if (ligneCachee && k === 0) {\n            // là on est certain qu'il y a du monde à cacher\n            ligneCachee.color = colorToLatexOrHTML(this.colorEquateur)\n            ligneCachee.epaisseur = 1.5\n          } else {\n            if (ligneCachee)\n              ligneCachee.color = colorToLatexOrHTML(this.colorParalleles)\n          }\n          if (faceCachee && ligneCachee) {\n            ligneCachee.pointilles = 4\n            ligneCachee.opacite = 0.5\n            this.c2d.push(ligneCachee)\n          }\n        }\n        const ligneVisible =\n          polyLineVisible.length > 0 ? polyline(...polyLineVisible) : null // et rien non plus à montrer près du pôle sud.\n        if (ligneVisible && k === 0) {\n          // là on est certain qu'il y a du monde à montrer\n          ligneVisible.color = colorToLatexOrHTML(this.colorEquateur)\n          ligneVisible.epaisseur = 1.5\n        } else {\n          if (ligneVisible)\n            ligneVisible.color = colorToLatexOrHTML(this.colorParalleles)\n        }\n        if (ligneVisible) {\n          this.c2d.push(ligneVisible)\n        }\n      }\n      j++\n    }\n\n    // Construction des méridiens demandés\n    if (this.nbMeridiens !== 0) {\n      const divisionMeridiens = Math.round(36 / this.nbMeridiens)\n      for (let k = 0, s; k < 18; k += divisionMeridiens) {\n        const polyLineCachee1 = []\n        const polyLineVisible1 = []\n        const polyLineCachee2 = []\n        const polyLineVisible2 = []\n\n        for (let ee = 1; ee < paralleles.listePoints3d.length - 1; ee++) {\n          // Affichage des méridiens sans le dernier segment relié aux pôles\n          // s = segment(paralleles.listePoints3d[ee][k].c2d, paralleles.listePoints3d[(ee + 1) % paralleles.listePoints3d.length][k].c2d, this.colorMeridiens)\n          if (\n            !paralleles.listePoints3d[ee][k].isVisible &&\n            !paralleles.listePoints3d[\n              (ee + 1) % paralleles.listePoints3d.length\n            ][k].isVisible\n          ) {\n            //  s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n            //  s.opacite = 0.5\n            polyLineCachee1.push(paralleles.listePoints3d[ee][k].c2d)\n          } else {\n            polyLineVisible1.push(paralleles.listePoints3d[ee][k].c2d)\n          }\n          // this.c2d.push(s)\n          // s = segment(paralleles.listePoints3d[ee][k + 18].c2d, paralleles.listePoints3d[(ee + 1) % paralleles.listePoints3d.length][k + 18].c2d, this.colorMeridiens)\n          if (\n            !paralleles.listePoints3d[ee][k + 18].isVisible &&\n            !paralleles.listePoints3d[\n              (ee + 1) % paralleles.listePoints3d.length\n            ][k + 18].isVisible\n          ) {\n            //   s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n            //   s.opacite = 0.5\n            polyLineCachee2.push(paralleles.listePoints3d[ee][k + 18].c2d)\n          } else {\n            polyLineVisible2.push(paralleles.listePoints3d[ee][k + 18].c2d)\n          }\n        }\n        // Affichage de la partie reliée au pôle Nord\n        s = segment(\n          poleNord.c2d,\n          paralleles.listePoints3d[1][k].c2d,\n          this.colorMeridiens,\n        )\n        this.c2d.push(s)\n        s = segment(\n          paralleles.listePoints3d[1][k + 18].c2d,\n          poleNord.c2d,\n          this.colorMeridiens,\n        )\n        this.c2d.push(s)\n        // Affichage de la partie reliée au pôle Sud\n        s = segment(\n          poleSud.c2d,\n          paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k].c2d,\n          this.colorMeridiens,\n        )\n        if (\n          faceCachee &&\n          !paralleles.listePoints3d[paralleles.listePoints3d.length - 1][0]\n            .isVisible\n        ) {\n          s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n          s.opacite = 0.5\n          this.c2d.push(s)\n        } else {\n          if (faceCachee) this.c2d.push(s)\n        }\n        s = segment(\n          paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k + 18]\n            .c2d,\n          poleSud.c2d,\n          this.colorMeridiens,\n        )\n        if (\n          faceCachee &&\n          !paralleles.listePoints3d[paralleles.listePoints3d.length - 1][k]\n            .isVisible\n        ) {\n          s.pointilles = 4 // Laisser 4 car sinon les pointilles ne se voient dans les petits cercles\n          s.opacite = 0.5\n          this.c2d.push(s)\n        } else {\n          if (faceCachee) this.c2d.push(s)\n        }\n\n        const ligneVisible1 = polyline(...polyLineVisible1)\n        const ligneVisible2 = polyline(...polyLineVisible2)\n\n        if (faceCachee) {\n          const ligneCachee1 = polyline(...polyLineCachee1)\n          const ligneCachee2 = polyline(...polyLineCachee2)\n          ligneCachee1.pointilles = 4\n          ligneCachee1.opacite = 0.5\n          ligneCachee2.pointilles = 4\n          ligneCachee2.opacite = 0.5\n          this.c2d.push(ligneCachee1, ligneCachee2)\n        }\n        this.c2d.push(ligneVisible1, ligneVisible2)\n      }\n    }\n\n    // L'enveloppe finale contiendra les points de l'enveloppe 1 + les points de l'enveloppe 2 inversée (sinon le polygone serait croisé)\n    // A cela, il faut ajouter les points autour des pôles car les premiers parallèles ne s'intersectent pas forcément.\n    enveloppeSphere2 = enveloppeSphere2.reverse()\n    const enveloppeSphere = [...enveloppeSphere1]\n\n    // Pour trouver les points du cercle apparent près du pôle sud\n    // On va prendre les points du premier parallèle intersecté entre l'indice du premier point d'intersection et l'indice du dernier point d'intersection.\n    let ii = 1\n    while (\n      (indiceDernier + paralleles.listePoints3d[0].length / 2 + ii) %\n        paralleles.listePoints3d[0].length <\n      (indicePremier + paralleles.listePoints3d[0].length / 2) %\n        paralleles.listePoints3d[0].length\n    ) {\n      enveloppeSphere.push(\n        paralleles.listePoints3d[\n          2 * nbParallelesDeConstruction - 1 - premierParallele\n        ][\n          (indiceDernier + paralleles.listePoints3d[0].length / 2 + ii) %\n            paralleles.listePoints3d[0].length\n        ].c2d,\n      )\n      ii++\n    }\n    enveloppeSphere.push(...enveloppeSphere2)\n    // Pour trouver les points du cercle apparent près du pôle nord\n    // On va prendre les points du premier parallèle intersecté entre l'indice du premier point d'intersection et l'indice du dernier point d'intersection.\n    // La gestion des indices est plus compliquée car il arrive de repasser de 35 à 0 (36 modulo 36) d'où cette double gestion.\n    if (indiceDernier > indicePremier) {\n      ii = 1\n      while (\n        indiceDernier + ii <\n        indicePremier + paralleles.listePoints3d[0].length\n      ) {\n        enveloppeSphere.push(\n          paralleles.listePoints3d[premierParallele][\n            (indiceDernier + ii) % paralleles.listePoints3d[0].length\n          ].c2d,\n        )\n        ii++\n      }\n    } else {\n      ii = 1\n      while (indiceDernier + ii < indicePremier) {\n        enveloppeSphere.push(\n          paralleles.listePoints3d[premierParallele][indiceDernier + ii].c2d,\n        )\n        ii++\n      }\n    }\n    const p = polygone(enveloppeSphere, this.colorEnveloppe)\n    p.epaisseur = 1.5\n\n    this.c2d.push(p)\n\n    if (this.affichageAxe) {\n      const l = longueur(poleNord.c2d, poleSud.c2d)\n      let ee = 1\n      const poly = polygone(enveloppeSphere)\n      // poly.isVisible = false\n      while (\n        ee < 2 &&\n        pointSurSegment(poleNord.c2d, poleSud.c2d, ee * l).estDansPolygone(poly)\n      ) {\n        ee += 0.01\n      }\n\n      let s = segment(\n        poleNord.c2d,\n        pointSurSegment(poleNord.c2d, poleSud.c2d, Math.max(ee - 0.01, 1) * l),\n        this.colorAxe,\n      )\n      s.pointilles = 2\n      this.c2d.push(s)\n      s = segment(\n        poleSud.c2d,\n        pointSurSegment(poleNord.c2d, poleSud.c2d, 1.1 * l),\n        this.colorAxe,\n      )\n      this.c2d.push(s)\n      s = segment(\n        poleNord.c2d,\n        pointSurSegment(poleNord.c2d, poleSud.c2d, -0.1 * l),\n        this.colorAxe,\n      )\n      this.c2d.push(s)\n    }\n    this.objets = this.c2d\n  }\n}\n/**\n * Crée une sphère\n * @param {Point3d} centre Centre de la sphère\n * @param {Vecteur3d} rayon Vecteur correspondant au rayon de la sphère\n * @param {string} [colorEquateur = 'red'] Couleur de l'équateur : du type 'blue' ou du type '#f15929'\n * @param {string} [colorEnveloppe = 'blue'] Couleur de l'enveloppe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbParalleles = 0]  Le nombre de parallèles au total\n * @param {string} [colorParalleles = 'gray'] Couleur des parallèles de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} [nbMeridiens = 0]  Le nombre de méridiens au total\n * @param {string} [colorMeridiens = 'gray'] Couleur des méridiens de la sphère : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la sphère.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe de la sphère : du type 'blue' ou du type '#f15929'\n * @param {number} inclinaison Angle d'inclinaison de l'axe N-S\n * @example sphere3d(A,v) // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur rouge et l'enveloppe bleue\n * @example sphere3d(A,v,'green','pink') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert et l'enveloppe rose\n * @example sphere3d(A,v,'green','pink',18,'red') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert, l'enveloppe rose, avec 18 parallèles rouges\n * @example sphere3d(A,v,'green','pink',18,'red',36,'blue') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert, l'enveloppe rose, avec 18 parallèles rouges et 36 méridiens verts\n * @example sphere3d(A,v,'green','pink',18,'red',36,'blue',true,'#f15929') // Crée une sphère de centre A et dont le rayon correspond au vecteur v, l'équateur vert, l'enveloppe rose, avec 18 parallèles rouges, 36 méridiens verts et un axe affiché orange\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @return {Sphere3d}\n */\n\nexport function sphere3d(\n  centre: Point3d,\n  rayon: Vecteur3d,\n  colorEquateur = 'red',\n  colorEnveloppe = 'blue',\n  nbParalleles = 0,\n  colorParalleles = 'gray',\n  nbMeridiens = 0,\n  colorMeridiens = 'black',\n  affichageAxe = false,\n  colorAxe = 'black',\n  inclinaison = 0,\n  faceCachee = true,\n) {\n  return new Sphere3d(\n    centre,\n    rayon,\n    colorEquateur,\n    colorEnveloppe,\n    nbParalleles,\n    colorParalleles,\n    nbMeridiens,\n    colorMeridiens,\n    affichageAxe,\n    colorAxe,\n    inclinaison,\n    faceCachee,\n  )\n}\n/**\n * Classe du cône\n * @param {Point3d} centre Centre de la base du cône\n * @param {Point3d} sommet Sommet du cône\n * @param {Vecteur3d} rayon Rayon de la base du cône\n * @param {string} [color = 'black'] Couleur des génératrices visibles et de la base du cône : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = true] Permet (ou pas) l'affichage de l'axe du cône.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et du centre de la base du cône : du type 'blue' ou du type '#f15929'\n * @param {string} [colorCone = 'gray'] Couleur du cône : du type 'blue' ou du type '#f15929'\n * @param {boolean} affichageCentre Affiche ou pas le centre du cône.\n * @property {Point3d} centre centre de la base du cône\n * @property {Point3d} sommet Sommet du cône\n * @property {Vecteur3d} rayon Rayon de la base du cône\n * @property {string} color Couleur des génératrices visibles et de la base du cône : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe du cône.\n * @property {string} colorAxe Couleur de l'axe et du centre de la base du cône : du type 'blue' ou du type '#f15929'\n * @property {string} colorCone Couleur du cône : du type 'blue' ou du type '#f15929'\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @class\n */\n\nexport class Cone3d extends ObjetMathalea2D {\n  constructor(\n    centre: Point3d,\n    sommet: Point3d,\n    rayon: Vecteur3d,\n    color: string = 'black',\n    affichageAxe = true,\n    colorAxe = 'black',\n    colorCone = 'gray',\n    affichageCentre = true,\n    affichageBase = true,\n  ) {\n    super()\n    this.centre = centre\n    this.sommet = sommet\n    this.rayon = rayon\n    this.color = colorToLatexOrHTML(color)\n    this.colorAxe = colorAxe\n    this.colorCone = colorCone\n\n    const pt1 = translation3d(this.centre, this.rayon)\n    const ptsBase = [pt1]\n    const nbSommets = 36\n    for (let ee = 1; ee < nbSommets; ee++) {\n      ptsBase.push(\n        rotation3d(\n          pt1,\n          droite3d(this.centre, vecteur3d(this.sommet, this.centre)),\n          (ee * 360) / nbSommets,\n        ),\n      )\n    }\n    const p = polygone3d(ptsBase, this.color[0])\n    // this.c2d = pyramide3d(p, this.sommet, this.color, this.centre, affichageAxe, this.colorAxe, false, true, this.colorCone).c2d\n    this.c2d = pyramide3d(\n      p,\n      this.sommet,\n      this.color[0],\n      affichageCentre ? this.centre : undefined,\n      affichageAxe,\n      this.colorAxe,\n      false,\n      true,\n      this.colorCone,\n      affichageBase,\n    ).c2d\n  }\n}\n/**\n * Crée un cône\n * @param {Point3d} centre centre de la base du cône\n * @param {Point3d} sommet Sommet du cône\n * @param {Vecteur3d} rayon Rayon de la base du cône\n * @param {string} [color = 'black'] Couleur des génératrices visibles et de la base du cône : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageAxe = true] Permet (ou pas) l'affichage de l'axe du cône.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et du centre de la base du cône : du type 'blue' ou du type '#f15929'\n * @param {string} [colorCone = 'gray'] Couleur du cône : du type 'blue' ou du type '#f15929'\n * @param {boolean} affichageCentre Affiche ou pas le centre du cône.\n * @example cone3d(A,B,v) // Créé un cône de centre A, de sommet B et dont le rayon correspond au vecteur v\n * @example cone3d(A,B,v,'red') // Créé un cône de centre A, de sommet B et dont le rayon correspond au vecteur v, la couleur du cône en fil de fer est rouge\n * @example cone3d(A,B,v,'red',true,'green') // Créé un cône de centre A, de sommet B et dont le rayon correspond au vecteur v, la couleur du cône en fil de fer est rouge, l'axe est affiché en vert\n * @example cone3d(A,B,v,'red',true,'green','blue') // Créé un cône de centre A, de sommet B et dont le rayon correspond au vecteur v, la couleur du cône en fil de fer est rouge, l'axe est affiché en vert et la face externe du cône est bleue\n * @author Eric Elter\n * @return {Cone3d}\n */\n\nexport function cone3d(\n  centre: Point3d,\n  sommet: Point3d,\n  rayon: Vecteur3d,\n  color: string = 'black',\n  affichageAxe = false,\n  colorAxe = 'black',\n  colorCone = 'gray',\n  affichageCentre = true,\n  affichageBase = true,\n) {\n  return new Cone3d(\n    centre,\n    sommet,\n    rayon,\n    color,\n    affichageAxe,\n    colorAxe,\n    colorCone,\n    affichageCentre,\n    affichageBase,\n  )\n}\n/**\n * Classe du cylindre : un cylindre de révolution défini par les centres de ses 2 bases\n * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes (A VERIFIER)\n * @param {Point3d} centrebase1 Centre de la première base\n * @param {Point3d} centrebase2 Centre de la seconde base\n * @param {Vecteur3d} rayon1 Vecteur correspondant au rayon de la première base\n * @param {Vecteur3d} rayon2 Vecteur correspondant au rayon de la seconde base\n * @param {string} [color = 'black'] Couleur des \"bords\" du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageGeneratrices = true] Permet (ou pas) l'affichage de génératrices du cylindre\n * @param {boolean} [affichageCentreBases = false] Permet (ou pas) l'affichage des centres respectifs de chaque base\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe du cylindre\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et des centres respectifs de chaque base du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [cylindreColore = false] Permet (ou pas) de colorier le cylindre\n * @param {string} [colorCylindre = 'lightgray'] Couleur du cylindre (avec gestion intégrée de la nuance de couleurs): du type 'blue' ou du type '#f15929'\n * @param {boolean} [avecFaceHaut = true] Permet (ou pas) d'afficher la face haut du cylindre\n * @property {Point3d} centrebase1 Centre de la première base\n * @property {Point3d} centrebase2 Centre de la seconde base\n * @property {Vecteur3d} rayon1 Vecteur correspondant au rayon de la première base\n * @property {Vecteur3d} rayon2 Vecteur correspondant au rayon de la seconde base\n * @property {string} color Couleur des \"bords\" du cylindre : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageGeneratrices Permet (ou pas) l'affichage de génératrices du cylindre\n * @property {boolean} affichageCentreBases Permet (ou pas) l'affichage des centres respectifs de chaque base\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe du cylindre\n * @property {string} colorAxe Couleur de l'axe et des centres respectifs de chaque base du cylindre : du type 'blue' ou du type '#f15929'\n * @property {boolean} cylindreColore Permet (ou pas) de colorier le cylindre\n * @property {string} colorCylindre Couleur du cylindre (avec gestion intégrée de la nuance de couleurs): du type 'blue' ou du type '#f15929'\n * @property {number} angleDepart Angle de rotation à partir duquel les demis-cercles formant la base sont tracés\n * @property {Points[]} pointsBase1 Liste des points formant la ligne de la base 1\n * @property {Points[]} pointsBase2 Liste des points formant la ligne de la base 2\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Jean-Claude Lhote (optimisé par Eric Elter)\n * @class\n */\n\nexport class Cylindre3d extends ObjetMathalea2D {\n  constructor(\n    centrebase1: Point3d,\n    centrebase2: Point3d,\n    rayon1: Vecteur3d,\n    rayon2: Vecteur3d,\n    color: string = 'black',\n    affichageGeneratrices = true,\n    affichageCentreBases = false,\n    affichageAxe = false,\n    colorAxe = 'black',\n    cylindreColore = false,\n    colorCylindre = 'lightgray',\n    avecFaceHaut = true,\n  ) {\n    super()\n    this.centrebase1 = centrebase1\n    this.centrebase2 = centrebase2\n    this.rayon1 = rayon1\n    this.rayon2 = rayon2\n    this.color = colorToLatexOrHTML(color)\n    this.affichageGeneratrices = affichageGeneratrices\n    this.affichageCentreBases = affichageCentreBases\n    this.affichageAxe = affichageAxe\n    this.colorAxe = colorAxe\n    this.cylindreColore = cylindreColore\n    this.colorCylindre = colorCylindre\n    this.c2d = []\n    let s\n    this.normal = vecteur3d(this.centrebase1, this.centrebase2)\n    const prodvec = vecteur3d(\n      math.cross(this.normal.matrice, this.rayon1.matrice),\n    )\n    const prodscal = math.dot(prodvec.matrice, vecteur3d(0, 1, 0).matrice)\n    let cote1, cote2\n    const centre1PlusBasQueCentre2 =\n      this.centrebase1.c2d.y !== this.centrebase2.c2d.y\n        ? this.centrebase1.c2d.y < this.centrebase2.c2d.y\n        : context.anglePerspective > 0\n    if (prodscal * context.anglePerspective > 0) {\n      cote1 = centre1PlusBasQueCentre2 ? 'direct' : 'indirect'\n      cote2 = centre1PlusBasQueCentre2 ? 'indirect' : 'direct'\n    } else {\n      cote2 = centre1PlusBasQueCentre2 ? 'direct' : 'indirect'\n      cote1 = centre1PlusBasQueCentre2 ? 'indirect' : 'direct'\n    }\n    cote2 = this.rayon1.x === 0 && this.rayon1.y === 0 ? 'indirect' : cote2\n    cote1 = this.rayon1.x === 0 && this.rayon1.y === 0 ? 'direct' : cote1\n    // Cette partie permet de chercher le bon angle de départ pour le tracé des demi-bases\n    // Recherche du premier point visible sur la demi-base visible\n    let angleDepart = 0\n    let distanceMax = 0\n    const d = droite3d(this.centrebase1, this.normal)\n    let ptReference = rotation3d(\n      translation3d(this.centrebase1, this.rayon1),\n      d,\n      angleDepart,\n    )\n    const secondPt = rotation3d(\n      translation3d(this.centrebase1, this.rayon1),\n      d,\n      angleDepart + 1,\n    )\n    const sensRecherche =\n      distancePointDroite(ptReference.c2d, d.c2d) <\n      distancePointDroite(secondPt.c2d, d.c2d)\n        ? 1\n        : -1\n    while (distancePointDroite(ptReference.c2d, d.c2d) > distanceMax) {\n      distanceMax = distancePointDroite(ptReference.c2d, d.c2d)\n      angleDepart = angleDepart + sensRecherche\n      ptReference = rotation3d(\n        translation3d(this.centrebase1, this.rayon1),\n        d,\n        angleDepart,\n      )\n    }\n    angleDepart = angleDepart - sensRecherche\n    // angleDepart est donc l'angle qui permet d'avoir un tracé de demicercle3d idéal\n    this.angleDepart = angleDepart\n    // Description de chaque demi-base en position verticale\n    // c1 : cercle bas derrière\n    const c1 = demicercle3d(\n      this.centrebase1,\n      this.normal,\n      this.rayon1,\n      cote1,\n      true,\n      this.color[0],\n      angleDepart,\n    )\n    // c3 : cercle haut derrière\n    const c3 = demicercle3d(\n      this.centrebase2,\n      this.normal,\n      this.rayon2,\n      cote1,\n      false,\n      this.color[0],\n      angleDepart,\n    )\n    // c2 : cercle bas devant\n    const c2 = demicercle3d(\n      this.centrebase1,\n      this.normal,\n      this.rayon1,\n      cote2,\n      false,\n      this.color[0],\n      angleDepart,\n    )\n    // c4 : cercle haut devant\n    const c4 = demicercle3d(\n      this.centrebase2,\n      this.normal,\n      this.rayon2,\n      cote2,\n      false,\n      this.color[0],\n      angleDepart,\n    )\n    this.pointsBase1 = [...c1.listePoints, ...c2.listePoints]\n    this.pointsBase2 = [...c3.listePoints, ...c4.listePoints]\n    if (this.cylindreColore) {\n      let polygon = [...c4.listePoints]\n      for (let i = c2.listePoints.length - 1; i >= 0; i--) {\n        polygon.push(c2.listePoints[i])\n      }\n      const faceColoree = polygone(polygon, 'white')\n      faceColoree.couleurDeRemplissage = colorToLatexOrHTML(this.colorCylindre)\n      this.c2d.push(faceColoree)\n\n      polygon = [...c3.listePoints]\n      for (let i = c4.listePoints.length - 1; i >= 0; i--) {\n        polygon.push(c4.listePoints[i])\n      }\n      const baseColoree = polygone(polygon, 'white')\n      baseColoree.couleurDeRemplissage = colorToLatexOrHTML(\n        assombrirOuEclaircir(this.colorCylindre, 25),\n      )\n      this.c2d.push(baseColoree)\n    }\n\n    if (this.affichageGeneratrices) {\n      for (let i = 1; i < c1.listePoints.length - 1; i += 2) {\n        s = segment(c3.listePoints[i], c1.listePoints[i], this.color[0])\n        s.pointilles = 2\n        s.opacite = 0.3\n        this.c2d.push(s)\n      }\n    }\n\n    s = segment(c4.listePoints[0], c2.listePoints[0], this.color[0])\n    this.c2d.push(s)\n\n    if (this.affichageGeneratrices) {\n      for (let i = 1; i < c2.listePoints.length - 1; i++) {\n        s = segment(c4.listePoints[i], c2.listePoints[i], this.color[0])\n        this.c2d.push(s)\n      }\n    }\n\n    s = segment(\n      c4.listePoints[c2.listePoints.length - 1],\n      c2.listePoints[c2.listePoints.length - 1],\n      this.color[0],\n    )\n    this.c2d.push(s)\n\n    this.c2d.push(c1, c2)\n    if (avecFaceHaut) this.c2d.push(c3, c4)\n\n    if (this.affichageCentreBases) {\n      this.c2d.push(\n        tracePoint(this.centrebase1.c2d, this.centrebase2.c2d, this.colorAxe),\n      )\n    }\n\n    if (this.affichageAxe) {\n      let distanceMin = 9999\n      const pt = c2.listePoints\n      let i = 0\n      const axeCylindre = droite(this.centrebase2.c2d, this.centrebase1.c2d)\n      while (distancePointDroite(pt[i], axeCylindre) < distanceMin) {\n        distanceMin = distancePointDroite(pt[i], d.c2d)\n        i++\n      }\n      s = segment(this.centrebase2.c2d, this.centrebase1.c2d, this.colorAxe)\n      s.pointilles = 2\n      s.opacite = 0.7\n      this.c2d.push(s)\n\n      // Construction de l'extension de l'axe\n      s = droite(pt[i], pt[i - 1])\n      const ptAxe1 = pointIntersectionDD(s, axeCylindre)\n      if (!ptAxe1) {\n        window.notify('Axe du cylindre non défini correctement', {\n          s,\n          axeCylindre,\n        })\n        return\n      }\n      s = segment(this.centrebase1.c2d, ptAxe1, this.colorAxe)\n      s.pointilles = 2\n      s.opacite = 0.7\n      this.c2d.push(s)\n      s = segment(\n        translation(ptAxe1, vecteur(this.centrebase1.c2d, ptAxe1)),\n        ptAxe1,\n        this.colorAxe,\n      )\n      s.opacite = 0.7\n      this.c2d.push(s)\n\n      const ptAxe2 = translation(\n        this.centrebase2.c2d,\n        vecteur(\n          translation(ptAxe1, vecteur(this.centrebase1.c2d, ptAxe1)),\n          this.centrebase1.c2d,\n        ),\n      )\n      s = segment(ptAxe2, this.centrebase2.c2d)\n      s.opacite = 0.7\n      this.c2d.push(s)\n    }\n  }\n}\n/**\n * Crée un cylindre de révolution défini par les centres de ses 2 bases\n * Permet en faisant varier les rayons des deux bases de créer des troncs de cônes (A VERIFIER)\n * @param {Point3d} centrebase1 Centre de la première base\n * @param {Point3d} centrebase2 Centre de la seconde base\n * @param {Vecteur3d} rayon1 Vecteur correspondant au rayon de la première base\n * @param {Vecteur3d} rayon2 Vecteur correspondant au rayon de la seconde base\n * @param {string} [color = 'black'] Couleur des \"bords\" du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageGeneratrices = true] Permet (ou pas) l'affichage de génératrices du cylindre\n * @param {boolean} [affichageCentreBases = false] Permet (ou pas) l'affichage des centres respectifs de chaque base\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe du cylindre\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et des centres respectifs de chaque base du cylindre : du type 'blue' ou du type '#f15929'\n * @param {boolean} [cylindreColore = false] Permet (ou pas) de colorier le cylindre\n * @param {string} [colorCylindre = 'lightgray'] Couleur du cylindre (avec gestion intégrée de la nuance de couleurs): du type 'blue' ou du type '#f15929'\n * @param {boolean} [avecFaceHaut = true] Permet (ou pas) d'afficher la face haut du cylindre\n * @example cylindre3d(A, B, v, v, 'blue')\n * // Retourne un cylindre à bords bleus dont les bases ont pour centre respectif A et B et le rayon est donné par le vecteur v.\n * @example cylindre3d(A, B, v, v, 'green', false, true, true, 'red', true, 'lightblue')\n * // Retourne un cylindre à bords verts dont les bases ont pour centre respectif A et B et le rayon est donné par le vecteur v.\n * // Les génératrices sont invisibles, les centres et axe sont visibles et rouges, le cylindre est coloré en bleu.\n * @author Jean-Claude Lhote (optimisé par Eric Elter)\n * @return {Cylindre3d}\n */\nexport function cylindre3d(\n  centrebase1: Point3d,\n  centrebase2: Point3d,\n  rayon: Vecteur3d,\n  rayon2: Vecteur3d,\n  color: string = 'black',\n  affichageGeneratrices = true,\n  affichageCentreBases = false,\n  affichageAxe = false,\n  colorAxe = 'black',\n  cylindreColore = false,\n  colorCylindre = 'lightgray',\n  avecFaceHaut = true,\n) {\n  return new Cylindre3d(\n    centrebase1,\n    centrebase2,\n    rayon,\n    rayon2,\n    color,\n    affichageGeneratrices,\n    affichageCentreBases,\n    affichageAxe,\n    colorAxe,\n    cylindreColore,\n    colorCylindre,\n    avecFaceHaut,\n  )\n}\n/**\n * Classe du prisme droit\n * Ce prisme droit est optimisé dans son tracé des arêtes cachées pour des bases dans le plan (xOy) et son vecteur normal selon (Oz)\n * Pour d'autres usages, il faut approfondir la fonction mais laissé en l'état car justement pas d'autre usage demandé.\n * @param {Polygone3d} base Une des deux bases du prisme droit\n * @param {Vecteur3d} vecteur Vecteur normal à la base dont la norme indique la hauteur du prisme droit.\n * @param {string} [color = 'black'] Couleur des arêtes du prisme droit : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets du prisme.\n * @property {Polygone3d} base1 La base entièrement visible du prisme droit\n * @property {Vecteur3d} vecteur Vecteur normal à la base dont la norme indique la hauteur du prisme droit.\n * @property {string} [color = 'black'] Couleur des arêtes du prisme droit : du type 'blue' ou du type '#f15929'\n * @property {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets du prisme.\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @property {string} nom Nom du prisme\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @class\n */\n\nexport class Prisme3d extends ObjetMathalea2D {\n  constructor(\n    base: Polygone3d,\n    vecteur: Vecteur3d,\n    color: string = 'black',\n    affichageNom = false,\n    nomBase2?: string,\n    positionLabels2?: string[],\n  ) {\n    super()\n    this.affichageNom = affichageNom\n    this.color = colorToLatexOrHTML(color)\n    base.color = this.color[0]\n    this.vecteur = vecteur\n    if (this.vecteur.y === 0 && this.vecteur.x === 0) {\n      this.base1 =\n        this.vecteur.z >= 1\n          ? base\n          : translation3d(\n              base,\n              vecteur3d(this.vecteur.x, this.vecteur.y, -this.vecteur.z),\n            )\n      this.base2 = this.vecteur.z < 1 ? base : translation3d(base, this.vecteur)\n    } else {\n      this.base1 = base\n      this.base2 = translation3d(base, vecteur)\n    }\n    this.base2.color = this.base1.color\n    this.c2d = []\n    let s\n    // On trace this.base1 (toujours visible)\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      this.c2d.push(this.base1.c2d[i])\n    }\n    // On cherche les sommets cachés de this.base2\n    let toutesLesAretesSontVisibles = true\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      const areteVisibleOuPas = pointSurSegment(\n        this.base1.listePoints[i].c2d,\n        this.base2.listePoints[i].c2d,\n        longueur(this.base1.listePoints[i].c2d, this.base2.listePoints[i].c2d) /\n          50,\n      ).estDansPolygone(polygone(this.base1.listePoints2d))\n      this.base2.listePoints[i].isVisible = !areteVisibleOuPas\n      toutesLesAretesSontVisibles =\n        !areteVisibleOuPas && toutesLesAretesSontVisibles\n    }\n    // On trace les arêtes de this.base2\n    for (let i = 0; i < this.base2.listePoints.length; i++) {\n      s = arete3d(\n        this.base2.listePoints[i],\n        this.base2.listePoints[\n          i + 1 === this.base2.listePoints.length ? 0 : i + 1\n        ],\n        this.color[0],\n      )\n      if (toutesLesAretesSontVisibles) {\n        // Cas particulier où aucun sommet de this.base2 n'est caché (cas de certains tétraèdres)\n        let areteVisibleOuPas = true\n        for (let ee = 0; ee < this.base1.listePoints.length; ee++) {\n          const areteLiaison = segment(\n            this.base1.listePoints[ee].c2d,\n            this.base2.listePoints[ee].c2d,\n          )\n          areteVisibleOuPas =\n            areteVisibleOuPas && !!areteLiaison.estSecant(s.c2d)\n        }\n        s = arete3d(\n          this.base2.listePoints[i],\n          this.base2.listePoints[\n            i + 1 === this.base2.listePoints.length ? 0 : i + 1\n          ],\n          this.color[0],\n          !areteVisibleOuPas,\n        )\n      }\n      this.c2d.push(s.c2d)\n    }\n    // On trace les arêtes de liaison entre les bases\n    for (let i = 0; i < this.base1.listePoints.length; i++) {\n      s = arete3d(\n        this.base1.listePoints[i],\n        this.base2.listePoints[i],\n        this.color[0],\n      )\n      this.c2d.push(s.c2d)\n    }\n\n    if (this.affichageNom) {\n      let p = polygone(this.base1.listePoints2d)\n      const listeLettres = choisitLettresDifferentes(\n        this.base1.listePoints.length,\n        'OQWX',\n      )\n      const nomBase1 = base.listePoints2d.map(\n        (el, index) => el.nom ?? listeLettres[index],\n      )\n\n      renommePolygone(p, nomBase1)\n      for (let ee = 0; ee < this.base1.listePoints2d.length; ee++) {\n        this.base1.listePoints2d[ee].positionLabel =\n          base.listePoints2d[ee].positionLabel ?? 'above'\n      }\n      this.c2d.push(\n        labelPoint(\n          ...p.listePoints.map((point) => pointDepuisPointAbstrait(point)),\n        ),\n      )\n      p = polygone(this.base2.listePoints2d)\n      const listeDeLettres2 = choisitLettresDifferentes(\n        this.base1.listePoints.length,\n        'OQWX' + nomBase1,\n      )\n      renommePolygone(p, nomBase2 ?? listeDeLettres2)\n      for (let ee = 0; ee < this.base2.listePoints2d.length; ee++) {\n        this.base2.listePoints2d[ee].positionLabel =\n          positionLabels2?.[ee] ?? 'below'\n      }\n      this.c2d.push(\n        labelPoint(\n          ...p.listePoints.map((point) => pointDepuisPointAbstrait(point)),\n        ),\n      )\n      this.nom = nomBase1 + (nomBase2 ?? '')\n    }\n  }\n}\n/**\n * Crée un prisme droit\n * Ce prisme droit est optimisé dans son tracé des arêtes cachées pour des bases dans le plan (xOy) et son vecteur normal selon (Oz)\n * Pour d'autres usages, il faut approfondir la fonction mais laissé en l'état car justement pas d'autre usage demandé.\n * @param {Polygone3d} base Une des deux bases du prisme droit\n * @param {Vecteur3d} vecteur Vecteur normal à la base dont la norme indique la hauteur du prisme droit.\n * @param {string} [color = 'black'] Couleur des arêtes du prisme droit : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets du prisme.\n * @param {string} [nomBase2] Nom de la base 2\n * @param {string[]} [positionLabels2] Position des labels de la base 2\n * @example prisme3d(p, v)\n * // Retourne un prisme droit de base p dont un vecteur normal à la base est v.\n * @example prisme3d(p, v, 'blue', true)\n * // Retourne un prisme droit de base p dont un vecteur normal à la base est v, de couleur V et dont les sommets sont nommés\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @return {Prisme3d}\n */\n\nexport function prisme3d(\n  base: Polygone3d,\n  vecteur: Vecteur3d,\n  color: string = 'black',\n  affichageNom = false,\n  nomBase2?: string,\n  positionLabels2?: string[],\n) {\n  return new Prisme3d(\n    base,\n    vecteur,\n    color,\n    affichageNom,\n    nomBase2,\n    positionLabels2,\n  )\n}\n/**\n * Classe de la pyramide\n * (optimisée au niveau des pointillés pour une base sur le plan xOy et un sommet plus haut ou plus bas que la base)\n * @param {Polygone3d} base Base de la pyramide\n * @param {Point3d} sommet Sommet de la pyramide\n * @param {string} [color = 'black'] Couleur des arêtes du prisme droit : du type 'blue' ou du type '#f15929'\n * @param {Point3d} [centre] Centre de la pyramide... Entraine l'affichage de ce centre\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la pyramide. Ne fonctionne que si centre est défini.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et du centre de la base de la pyramide : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets de la pyramide.\n * @param {boolean} [estCone = false] Permet (ou pas) de considérer la pyramide comme un cône... dans le cas où la base est un disque.\n * @param {string} [colorCone = 'gray'] Couleur du cône : du type 'blue' ou du type '#f15929'\n * @property {Polygone3d} base Base de la pyramide\n * @property {Point3d} sommet Sommet de la pyramide\n * @property {string} color Couleur des arêtes de la pyramide : du type 'blue' ou du type '#f15929'\n * @property {Point3d} centre Centre de la pyramide... Entraine l'affichage de ce centre\n * @property {boolean} affichageAxe Permet (ou pas) l'affichage de l'axe de la pyramide. Ne fonctionne que si centre est défini.\n * @property {string} colorAxe Couleur de l'axe et du centre de la base de la pyramide : du type 'blue' ou du type '#f15929'\n * @property {boolean} affichageNom Permet (ou pas) l'affichage du nom des sommets de la pyramide.\n * @property {string} nom Nom de la pyramide (si affichageNom = true)\n * @property {string} colorCone Couleur du cône : du type 'blue' ou du type '#f15929'\n * @property {arete3d[]} aretesSommet Ce tableau contient les arêtes liant le sommet de la pyramide aux sommets de la base\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @class\n */\n\nexport class Pyramide3d extends ObjetMathalea2D {\n  constructor(\n    base: Polygone3d,\n    sommet: Point3d,\n    color: string = 'black',\n    centre?: Point3d,\n    affichageAxe = false,\n    colorAxe = 'black',\n    affichageNom = false,\n    estCone = false,\n    colorCone = 'gray',\n    affichageBase = true,\n  ) {\n    super()\n    base.color = color\n    this.base = base\n    this.sommet = sommet\n    this.color = colorToLatexOrHTML(color)\n    this.centre = centre\n    this.affichageAxe = affichageAxe\n    this.colorAxe = colorAxe\n    this.affichageNom = affichageNom\n    this.estCone = estCone\n    this.colorCone = colorCone\n    this.c2d = []\n    this.nom = ''\n    let s\n\n    // Stockage de toutes les arêtes issues du sommet\n    this.aretesSommet = []\n\n    for (let i = 0; i < this.base.listePoints.length; i++) {\n      s = arete3d(this.base.listePoints[i], this.sommet, color, true)\n      // s.c2d.isVisible = false\n      this.aretesSommet.push(s)\n    }\n\n    // Stockage de toutes les arêtes de la base\n    const aretesBase = []\n    for (let i = 0; i < this.base.listePoints.length; i++) {\n      s = arete3d(\n        this.base.listePoints[i],\n        this.base.listePoints[(i + 1) % this.base.listePoints.length],\n        color,\n        true,\n      )\n      aretesBase.push(s)\n    }\n\n    // Recherche des sommets arrières (donc toutes les arêtes issues de ce point sont cachées)\n    let sommetCache = false\n    let sommetCacheAvant\n    const angleReference = [0, 0]\n    const sommetGeneratriceCone = []\n\n    for (let i = 0; i < this.base.listePoints.length; i++) {\n      sommetCacheAvant = sommetCache\n      sommetCache = false\n      for (let j = 1; j < this.base.listePoints.length - 1; j++) {\n        const poly = polygone([\n          this.sommet.c2d,\n          this.base.listePoints[(i + j) % this.base.listePoints.length].c2d,\n          this.base.listePoints[(i + j + 1) % this.base.listePoints.length].c2d,\n        ])\n        poly.isVisible = false\n        sommetCache =\n          sommetCache || this.base.listePoints[i].c2d.estDansPolygone(poly)\n      }\n      if (this.estCone && sommetCacheAvant !== sommetCache && i !== 0) {\n        if (sommetCache)\n          sommetGeneratriceCone.push(\n            this.aretesSommet[\n              (this.aretesSommet.length + i - 1) % this.aretesSommet.length\n            ],\n          )\n        else sommetGeneratriceCone.push(this.aretesSommet[i])\n        if (sommetCache) angleReference[1] = i\n        else angleReference[0] = i\n      }\n      if (sommetCache) {\n        if (sommet.z > this.base.listePoints[0].z) {\n          // Si le sommet est au-dessus de la base\n          this.aretesSommet[i].isVisible = false\n          this.aretesSommet[i].c2d.pointilles = 2\n          aretesBase[i].c2d.pointilles = 2\n          aretesBase[\n            (this.base.listePoints.length + i - 1) %\n              this.base.listePoints.length\n          ].c2d.pointilles = 2\n        }\n      }\n    }\n\n    if (this.estCone && angleReference[1] <= angleReference[0]) {\n      angleReference[1] += this.base.listePoints.length\n    }\n\n    if (this.estCone && sommetGeneratriceCone.length === 1) {\n      sommetGeneratriceCone.push(\n        this.aretesSommet[this.aretesSommet.length - 1],\n      )\n      angleReference[1] = this.aretesSommet.length - 1\n    }\n    if (this.estCone) {\n      const premierPlan = [this.sommet.c2d]\n      for (let i = angleReference[0]; i < angleReference[1]; i++) {\n        premierPlan.push(\n          this.base.listePoints[i % this.base.listePoints.length].c2d,\n        )\n        // ok\n      }\n      const faceAv = polygone(premierPlan, this.colorCone)\n      faceAv.couleurDeRemplissage = colorToLatexOrHTML(this.colorCone)\n      this.c2d.push(faceAv)\n    }\n\n    if (!this.estCone) {\n      let longueurSegment\n      if (this.sommet.z > this.base.listePoints[0].z) {\n        // Si le sommet est au-dessus de la base\n        // Recherche de l'arête cachée possible issue de deux sommets non cachés.\n        for (let i = 0; i < this.base.listePoints.length; i++) {\n          sommetCache = false\n          longueurSegment = longueur(\n            this.base.listePoints[i].c2d,\n            this.base.listePoints[(i + 1) % this.base.listePoints.length].c2d,\n          )\n          s = segment(\n            pointSurSegment(\n              this.base.listePoints[i].c2d,\n              this.base.listePoints[(i + 1) % this.base.listePoints.length].c2d,\n              longueurSegment / 20,\n            ),\n            pointSurSegment(\n              this.base.listePoints[i].c2d,\n              this.base.listePoints[(i + 1) % this.base.listePoints.length].c2d,\n              (19 * longueurSegment) / 20,\n            ),\n          )\n          s.isVisible = false\n          for (let j = 0; j < this.aretesSommet.length; j++) {\n            sommetCache = sommetCache || !!s.estSecant(this.aretesSommet[j].c2d)\n          }\n          if (sommetCache) aretesBase[i].c2d.pointilles = 2\n        }\n      } else {\n        // Si le sommet est en-dessous de la base\n        for (let i = 0; i < this.base.listePoints.length; i++) {\n          longueurSegment = longueur(\n            this.base.listePoints[i].c2d,\n            this.sommet.c2d,\n          )\n          s = segment(\n            pointSurSegment(\n              this.base.listePoints[i].c2d,\n              this.sommet.c2d,\n              longueurSegment / 20,\n            ),\n            this.sommet.c2d,\n          )\n          s.isVisible = false\n          let j = 0\n          while (j < aretesBase.length && !s.estSecant(aretesBase[j].c2d)) {\n            j++\n          }\n          if (j < aretesBase.length) this.aretesSommet[i].c2d.pointilles = 2\n        }\n      }\n      for (let i = 0; i < this.base.listePoints.length; i++) {\n        this.c2d.push(this.aretesSommet[i].c2d)\n      }\n    } else {\n      for (let i = 0; i < sommetGeneratriceCone.length; i++) {\n        this.c2d.push(sommetGeneratriceCone[i].c2d)\n      }\n    }\n\n    if (affichageBase) {\n      for (let i = 0; i < this.base.listePoints.length; i++) {\n        this.c2d.push(aretesBase[i].c2d)\n      }\n    }\n\n    if (this.centre !== undefined && this.centre.constructor === Point3d) {\n      this.c2d.push(tracePoint(this.centre.c2d, this.colorAxe))\n      if (this.centre.label === '')\n        this.centre.label = choisitLettresDifferentes(1, 'OQWX')[0]\n      this.c2d.push(...labelPoint(this.centre.c2d))\n\n      if (this.affichageAxe) {\n        // Axe affiché que si centre précisé\n        if (this.sommet.z > 0) {\n          let intersectionTrouvee = false\n          let ee = 0\n          // Recherche du point d'intersection visuelle entre l'axe et une arête visible de la base\n          while (!intersectionTrouvee && ee < aretesBase.length) {\n            s = aretesBase[ee].c2d\n            if (s.pointilles !== 2) {\n              // L'arête coupée doit être visible\n              const d1 = droite(this.centre.c2d, this.sommet.c2d)\n              d1.isVisible = false\n              intersectionTrouvee = !!s.estSecant(d1)\n            }\n            ee++\n          }\n          if (intersectionTrouvee) {\n            ee--\n            const d1 = droite(\n              this.base.listePoints[ee].c2d,\n              this.base.listePoints[(ee + 1) % this.base.listePoints.length]\n                .c2d,\n            )\n            d1.isVisible = false\n            const d2 = droite(this.centre.c2d, this.sommet.c2d)\n            d2.isVisible = false\n            const ptBase = pointIntersectionDD(d1, d2)\n            if (!ptBase) {\n              window.notify('Axe de la pyramide non défini correctement', {\n                d1,\n                d2,\n              })\n              return\n            }\n            s = segment(ptBase, this.sommet.c2d, this.colorAxe)\n            s.pointilles = 2\n            this.c2d.push(s)\n            s = segment(\n              ptBase,\n              translation(ptBase, vecteur(this.centre.c2d, ptBase)),\n              this.colorAxe,\n            )\n            this.c2d.push(s)\n            s = segment(\n              this.sommet.c2d,\n              translation(this.sommet.c2d, vecteur(ptBase, this.centre.c2d)),\n              this.colorAxe,\n            )\n            this.c2d.push(s)\n          }\n        } else {\n          s = segment(this.centre.c2d, this.sommet.c2d, this.colorAxe)\n          s.pointilles = 2\n          this.c2d.push(s)\n          const v = vecteur(this.centre.c2d, this.sommet.c2d)\n          const L = longueur(this.base.listePoints[0].c2d, this.centre.c2d)\n          const h = 2 * norme(v)\n          s = segment(\n            this.sommet.c2d,\n            translation(this.sommet.c2d, vecteur((L * v.x) / h, (L * v.y) / h)),\n            this.colorAxe,\n          )\n          this.c2d.push(s)\n          s = segment(\n            this.centre.c2d,\n            translation(\n              this.centre.c2d,\n              vecteur((-L * v.x) / h, (-L * v.y) / h),\n            ),\n            this.colorAxe,\n          )\n          this.c2d.push(s)\n        }\n      }\n    }\n\n    if (this.affichageNom) {\n      const p = polygone(this.base.listePoints2d)\n      p.isVisible = false\n      if (this.centre.label === '' || this.centre.label === this.sommet.label)\n        this.sommet.label = choisitLettresDifferentes(1, 'OQWX')[0]\n      const nomBase = choisitLettresDifferentes(\n        this.base.listePoints.length,\n        'OQWX' + this.sommet.label + this.centre.label,\n      )\n      renommePolygone(p, nomBase)\n      for (let ee = 0; ee < this.base.listePoints2d.length; ee++) {\n        this.base.listePoints2d[ee].positionLabel =\n          this.sommet.z > 0 ? 'below' : 'above'\n      }\n      this.c2d.push(\n        labelPoint(\n          ...p.listePoints.map((point) => pointDepuisPointAbstrait(point)),\n        ),\n      )\n      this.c2d.push(labelPoint(this.sommet))\n      this.nom = nomBase.join('') + this.sommet.label\n    }\n  }\n}\n/**\n * Crée une pyramide\n * @param {Polygone3d} base Base de la pyramide\n * @param {Point3d} sommet Sommet de la pyramide\n * @param {string} [color = 'black'] Couleur des arêtes de la pyramide : du type 'blue' ou du type '#f15929'\n * @param {Point3d} [centre] Centre de la pyramide... Entraine l'affichage de ce centre\n * @param {boolean} [affichageAxe = false] Permet (ou pas) l'affichage de l'axe de la pyramide. Ne fonctionne que si centre est défini.\n * @param {string} [colorAxe = 'black'] Couleur de l'axe et du centre de la base de la pyramide : du type 'blue' ou du type '#f15929'\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets de la pyramide.\n * @param {boolean} [estCone = false] Permet (ou pas) de considérer la pyramide comme un cône\n * @param {string} [colorCone = 'gray'] Couleur du cône : du type 'blue' ou du type '#f15929'\n * @author Eric Elter (d'après version précédente de Jean-Claude Lhote)\n * @example pyramide3d(p,A) // Créé une pyramide de base p et de sommet A\n * @example pyramide3d(p,A,'red') // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges\n * @example pyramide3d(p,A,'red',B) // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges, le centre affiché est B\n * @example pyramide3d(p,A,'red',B,true,'green') // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges, le centre affiché est B, l'axe affiché est vert\n * @example pyramide3d(p,A,'red',B,true,'green',true) // Créé une pyramide de base p et de sommet A et dont les arêtes sont rouges, le centre affiché est B, l'axe affiché est vert, les sommets sont nommés\n * @example pyramide3d(c,A,'red',B,true,'green',false,true) // Créé un CONE de cercle c et de sommet A et dont les \"arêtes\" sont rouges, le centre affiché est B, l'axe affiché est vert\n * @example pyramide3d(c,A,'red',B,true,'green',false,true,'blue') // Créé un CONE de cercle c et de sommet A et dont les \"arêtes\" sont rouges, le centre affiché est B, l'axe affiché est vert et le cône est peint en vert\n * @return {Pyramide3d}\n */\n\nexport function pyramide3d(\n  base: Polygone3d,\n  sommet: Point3d,\n  color = 'black',\n  centre?: Point3d,\n  affichageAxe = false,\n  colorAxe = 'black',\n  affichageNom = false,\n  estCone = false,\n  colorCone = 'gray',\n  affichageBase = true,\n) {\n  return new Pyramide3d(\n    base,\n    sommet,\n    color,\n    centre,\n    affichageAxe,\n    colorAxe,\n    affichageNom,\n    estCone,\n    colorCone,\n    affichageBase,\n  )\n}\n/**\n * La pyramide tronquée\n *\n * @author Jean-Claude Lhote\n * Crée une pyramide à partir d'une base Polygone3d d'un sommet et d'un coefficient compris entre 0 et 1\n * un coefficient de 0.5 coupera la pyramide à mi-hauteur (valeur par défaut).\n */\n\nexport class PyramideTronquee3d extends ObjetMathalea2D {\n  constructor(base: Polygone3d, sommet: Point3d, coeff = 0.5, color = 'black') {\n    super()\n    this.color = colorToLatexOrHTML(color)\n    base.color = color\n    this.base = base\n    this.coeff = coeff\n    this.aretes = []\n    this.sommet = sommet\n    this.c2d = []\n    const sommetsBase2 = []\n    for (let i = 0, pointSection; i < this.base.listePoints.length; i++) {\n      pointSection = homothetie3d(sommet, base.listePoints[i], coeff)\n      pointSection.isVisible = true\n      sommetsBase2.push(pointSection)\n    }\n    this.base2 = polygone3d(...sommetsBase2)\n    this.c2d.push(...this.base.c2d)\n    for (let i = 0; i < base.listePoints.length; i++) {\n      this.aretes.push(\n        arete3d(\n          base.listePoints[i],\n          this.base2.listePoints[i],\n          color,\n          base.listePoints[i].isVisible,\n        ),\n      )\n      this.c2d.push(this.aretes[i].c2d)\n    }\n    this.c2d.push(...this.base2.c2d)\n  }\n}\n\nexport function pyramideTronquee3d(\n  base: Polygone3d,\n  sommet: Point3d,\n  coeff = 0.5,\n  color = 'black',\n) {\n  return new PyramideTronquee3d(base, sommet, coeff, color)\n}\n/**\n * Classe du cube : construit le cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z\n * (la face avant est dans le plan xz, la face de droite est toujours visible, la face de haut ou du bas est visible selon context.anglePerspective)\n * @param {number} x Abscisse du sommet du cube en bas à gauche\n * @param {number} y Ordonnée du sommet du cube en bas à gauche\n * @param {number} x Altitude du sommet du cube en bas à gauche\n * @param {number} c Longueur de l'arête du cube\n * @param {string} [color = 'black'] Couleur des arêtes du cube : du type 'blue' ou du type '#f15929'\n * @param {string} [colorAV = 'lightgray'] Couleur de la face avant du cube : du type 'blue' ou du type '#f15929'\n * @param {string} [colorHautouBas = 'white'] Couleur de la face visible du dessus (ou du dessous) du cube : du type 'blue' ou du type '#f15929'\n * @param {string} [colorDr = 'darkgray'] Couleur de la face de droite (toujours visible) du cube : du type 'blue' ou du type '#f15929'\n * @param {boolean} [aretesCachee = true] Si true, les arêtes cachées sont visibles.\n * @param {boolean} [affichageNom = false] Si true, le nom des sommets est affiché\n * @param {string[]} [nom = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']] Nom du cube\n * @property {boolean} affichageNom Si true, le nom des sommets est affiché\n * @property {Point3d[]} sommets Tableau contenant les sommets du cube\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Jean-Claude Lhote (Amendée par Eric Elter)\n * @class\n */\n\nexport class Cube3d extends ObjetMathalea2D {\n  constructor(\n    x: number,\n    y: number,\n    z: number,\n    c: number,\n    color = 'black',\n    colorAV = 'lightgray',\n    colorHautouBas = 'white',\n    colorDr = 'darkgray',\n    aretesCachee = true,\n    affichageNom = false,\n    nom = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],\n  ) {\n    super()\n    this.affichageNom = affichageNom\n    const A = point3d(x, y, z)\n    A.c2d.nom = nom[0]\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n    const B = translation3d(A, vx)\n    B.c2d.nom = nom[1]\n    const C = translation3d(B, vz)\n    C.c2d.nom = nom[2]\n    const D = translation3d(A, vz)\n    D.c2d.nom = nom[3]\n    let pointsFace = [A.c2d, B.c2d, C.c2d, D.c2d]\n    const faceAV = this.affichageNom\n      ? polygoneAvecNom(...pointsFace)\n      : polygone(pointsFace, color)\n    if (this.affichageNom) faceAV[0].color = colorToLatexOrHTML(color)\n    const E = translation3d(A, vy)\n    E.c2d.nom = nom[4]\n    const F = translation3d(E, vx)\n    F.c2d.nom = nom[5]\n    const G = translation3d(F, vz)\n    G.c2d.nom = nom[6]\n    const H = translation3d(D, vy)\n    H.c2d.nom = nom[7]\n    pointsFace = [E.c2d, F.c2d, G.c2d, H.c2d]\n    const faceArr = this.affichageNom\n      ? polygoneAvecNom(...pointsFace)\n      : vide2d()\n\n    const faceDr = polygone([B.c2d, F.c2d, G.c2d, C.c2d], color)\n    let faceVisibleHautOuBas, areteCachee3, areteCachee2, areteCachee1\n    if (context.anglePerspective > 0) {\n      faceVisibleHautOuBas = polygone([D.c2d, C.c2d, G.c2d, H.c2d], color) // Cette face est en fonction de context.anglePerspective\n      areteCachee1 = segment(E.c2d, H.c2d, color)\n      areteCachee2 = segment(E.c2d, F.c2d, color)\n      areteCachee3 = segment(E.c2d, A.c2d, color)\n    } else {\n      faceVisibleHautOuBas = polygone([A.c2d, B.c2d, F.c2d, E.c2d], color)\n      areteCachee1 = segment(E.c2d, H.c2d, color)\n      areteCachee2 = segment(D.c2d, H.c2d, color)\n      areteCachee3 = segment(G.c2d, H.c2d, color)\n    }\n    areteCachee1.pointilles = 2\n    areteCachee2.pointilles = 2\n    areteCachee3.pointilles = 2\n\n    this.sommets = [A, B, C, D, E, F, G, H]\n    // Les 8 sommets sont indispensables pour pouvoir les utiliser ensuite.\n    if (aretesCachee) {\n      if (Array.isArray(faceAV)) {\n        faceAV[0].couleurDeRemplissage = colorToLatexOrHTML(colorAV)\n      } else {\n        faceAV.couleurDeRemplissage = colorToLatexOrHTML(colorAV)\n      }\n      faceVisibleHautOuBas.couleurDeRemplissage =\n        colorToLatexOrHTML(colorHautouBas)\n      faceDr.couleurDeRemplissage = colorToLatexOrHTML(colorDr)\n      this.c2d = [\n        faceAV.length === 2 ? faceAV[0] : faceAV,\n        faceAV.length === 2 ? faceAV[1] : vide2d(),\n        faceDr,\n        faceVisibleHautOuBas,\n      ]\n    } else {\n      this.c2d = [\n        faceAV.length === 2 ? faceAV[0] : faceAV,\n        faceAV.length === 2 ? faceAV[1] : vide2d(),\n        faceDr,\n        faceVisibleHautOuBas,\n        faceArr.length === 2 ? faceArr[1] : vide2d(),\n        areteCachee1,\n        areteCachee2,\n        areteCachee3,\n      ]\n    }\n  }\n}\n/**\n * Crée un cube d'arète c dont le sommet en bas à gauche a les coordonnées x,y,z\n * (la face avant est dans le plan xz, la face de droite est toujours visible, la face de haut ou du bas est visible selon context.anglePerspective)\n * @param {number} x Abscisse du sommet du cube en bas à gauche\n * @param {number} y Ordonnée du sommet du cube en bas à gauche\n * @param {number} x Altitude du sommet du cube en bas à gauche\n * @param {number} c Longueur de l'arête du cube\n * @param {string} [color = 'black'] Couleur des arêtes du cube : du type 'blue' ou du type '#f15929'\n * @param {string} [colorAV = 'lightgray'] Couleur de la face avant du cube : du type 'blue' ou du type '#f15929'\n * @param {string} [colorHautouBas = 'white'] Couleur de la face visible du dessus (ou du dessous) du cube : du type 'blue' ou du type '#f15929'\n * @param {string} [colorDr = 'darkgray'] Couleur de la face de droite (toujours visible) du cube : du type 'blue' ou du type '#f15929'\n * @param {boolean} [aretesCachee = true] Si true, les arêtes cachées sont visibles.\n * @param {boolean} [affichageNom = false] Si true, le nom des sommets est affiché\n * @param {string[]} [nom = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']] Nom du cube\n * @example cube(0,0,0,10)\n * // Construit un cube noir d'arête 10 dont le sommet en bas à gauche est l'origine du repère et dont les faces visibles sont colorées aux couleurs par défaut.\n * // Les arêtes cachées sont visibles et le cube ne porte pas de nom.\n * @example cube(0,0,0,10,'red','','','',false)\n * // Construit un cube rouge d'arête 10 dont le sommet en bas à gauche est l'origine du repère et dont aucune face n'est coloriée.\n * // Les arêtes cachées sont invisibles et le cube ne porte pas de nom.\n * @example cube(0,0,0,10,'#f15929','','','',trie,true)\n * // Construit un cube orange d'arête 10 dont le sommet en bas à gauche est l'origine du repère et dont aucune face n'est coloriée.\n * // Les arêtes cachées sont visibles et le cube s'appelle ABCDEFGH.\n * @author Jean-Claude Lhote (Amendée par Eric Elter)\n * @return {Cube3d}\n */\n\nexport function cube3d(\n  x: number,\n  y: number,\n  z: number,\n  c: number,\n  color = 'black',\n  colorAV = 'lightgray',\n  colorHautouBas = 'white',\n  colorDr = 'darkgray',\n  aretesCachee = true,\n  affichageNom = false,\n  nom = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],\n) {\n  return new Cube3d(\n    x,\n    y,\n    z,\n    c,\n    color,\n    colorAV,\n    colorHautouBas,\n    colorDr,\n    aretesCachee,\n    affichageNom,\n    nom,\n  )\n}\n/**\n * @author Jean-Claude Lhote\n * Créer une barre de l cubes de c de côté à partir du point (x,y,z)\n * La barre est positionnée suivant l'axe x\n */\n\nexport class Barre3d extends ObjetMathalea2D {\n  constructor(\n    x: number,\n    y: number,\n    z: number,\n    c: number,\n    l: number,\n    color = 'black',\n  ) {\n    super()\n    let faceAv, faceTop\n    this.c2d = []\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n    let A = point3d(x, y, z)\n    let B = A\n    let C = A\n    let D = A\n    let E = A\n    let F = A\n    let G = A\n    let H = A\n    for (let i = 0; i < l; i++) {\n      B = translation3d(A, vx)\n      C = translation3d(B, vz)\n      D = translation3d(A, vz)\n      E = translation3d(A, vy)\n      F = translation3d(E, vx)\n      G = translation3d(F, vz)\n      H = translation3d(D, vy)\n      faceAv = polygone([A.c2d, B.c2d, C.c2d, D.c2d], color)\n      faceTop = polygone([D.c2d, C.c2d, G.c2d, H.c2d], color)\n      faceAv.couleurDeRemplissage = colorToLatexOrHTML('lightgray')\n      faceTop.couleurDeRemplissage = colorToLatexOrHTML('white')\n      this.c2d.push(faceAv, faceTop)\n      A = translation3d(A, vx)\n    }\n    const faceD = polygone([B.c2d, F.c2d, G.c2d, C.c2d], color)\n    faceD.couleurDeRemplissage = colorToLatexOrHTML('darkgray')\n    this.c2d.push(faceD)\n  }\n}\n\nexport function barre3d(\n  x: number,\n  y: number,\n  z: number,\n  c: number,\n  l: number,\n  color = 'black',\n) {\n  return new Barre3d(x, y, z, c, l, color)\n}\n/**\n * @author Jean-Claude Lhote\n * Crée une plaque de cubes de côtés c de dimensions l suivant x et p suivant y\n */\n\nexport class Plaque3d extends ObjetMathalea2D {\n  constructor(\n    x: number,\n    y: number,\n    z: number,\n    c: number,\n    l: number,\n    p: number,\n    color = 'black',\n  ) {\n    super()\n    let A, B, C, D, F, G, H, faceAv, faceTop, faceD\n    this.c2d = []\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n\n    for (let i = 0; i < l; i++) {\n      for (let j = 0; j < p; j++) {\n        A = point3d(x + i * c, y + j * c, z)\n        B = translation3d(A, vx)\n        C = translation3d(B, vz)\n        D = translation3d(A, vz)\n        F = translation3d(B, vy)\n        G = translation3d(F, vz)\n        H = translation3d(D, vy)\n        if (j === 0) {\n          faceAv = polygone([A.c2d, B.c2d, C.c2d, D.c2d], color)\n          faceAv.couleurDeRemplissage = colorToLatexOrHTML('lightgray')\n          this.c2d.push(faceAv)\n        }\n        if (i === l - 1) {\n          faceD = polygone([B.c2d, F.c2d, G.c2d, C.c2d], color)\n          faceD.couleurDeRemplissage = colorToLatexOrHTML('darkgray')\n          this.c2d.push(faceD)\n        }\n        faceTop = polygone([D.c2d, C.c2d, G.c2d, H.c2d], color)\n        faceTop.couleurDeRemplissage = colorToLatexOrHTML('white')\n        this.c2d.push(faceTop)\n      }\n    }\n  }\n}\n\nexport function plaque3d(\n  x: number,\n  y: number,\n  z: number,\n  c: number,\n  l: number,\n  p: number,\n  color = 'black',\n) {\n  return new Plaque3d(x, y, z, c, l, p, color)\n}\n\nexport class PaveLPH3d extends ObjetMathalea2D {\n  constructor(\n    x: number,\n    y: number,\n    z: number,\n    c: number,\n    l: number,\n    p: number,\n    h: number,\n    color = 'black',\n  ) {\n    super()\n    let A, B, C, D, F, G, H, faceAv, faceTop, faceD\n    this.c2d = []\n    const vx = vecteur3d(c, 0, 0)\n    const vy = vecteur3d(0, c, 0)\n    const vz = vecteur3d(0, 0, c)\n\n    for (let i = 0; i < l; i++) {\n      for (let j = 0; j < p; j++) {\n        for (let k = 0; k < h; k++) {\n          A = point3d(x + i * c, y + j * c, z + k * c)\n          B = translation3d(A, vx)\n          C = translation3d(B, vz)\n          D = translation3d(A, vz)\n          F = translation3d(B, vy)\n          G = translation3d(F, vz)\n          H = translation3d(D, vy)\n          if (j === 0) {\n            faceAv = polygone([A.c2d, B.c2d, C.c2d, D.c2d], color)\n            faceAv.couleurDeRemplissage = colorToLatexOrHTML('lightgray')\n            this.c2d.push(faceAv)\n          }\n          if (i === l - 1) {\n            faceD = polygone([B.c2d, F.c2d, G.c2d, C.c2d], color)\n            faceD.couleurDeRemplissage = colorToLatexOrHTML('darkgray')\n            this.c2d.push(faceD)\n          }\n          if (k === h - 1) {\n            faceTop = polygone([D.c2d, C.c2d, G.c2d, H.c2d], color)\n            faceTop.couleurDeRemplissage = colorToLatexOrHTML('white')\n            this.c2d.push(faceTop)\n          }\n        }\n      }\n    }\n  }\n}\n/**\n *\n * @param {number} x coordonnées du sommet en bas à gauche\n * @param {number} y\n * @param {number} z\n * @param {number} c longueur de l'unité\n * @param {number} p profondeur\n * @param {number} l longueur\n * @param {number} h hauteur\n * @param {*} color couleur\n * @returns {PaveLPH3d}\n */\n\nexport function paveLPH3d(\n  x: number,\n  y: number,\n  z: number,\n  c: number,\n  l: number,\n  p: number,\n  h: number,\n  color = 'black',\n) {\n  return new PaveLPH3d(x, y, z, c, l, p, h, color)\n}\n/**\n * Classe du pavé : construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] délimitent 3 faces adjacentes.\n * La gestion des arêtes cachées est prise en compte et n'est pas forcément E.\n * En travaillant sur le signe de context.anglePerspective et sur celui de la hauteur (B.z), on peut avoir une vision de haut, de bas, de gauche, de droite comme dans l'exercice....\n * @param {Point3d} A Sommet du pavé droit\n * @param {Point3d} B Sommet du pavé droit\n * @param {Point3d} D Sommet du pavé droit\n * @param {Point3d} E Sommet du pavé droit\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets du pavé droit.\n * @param {string} [nom = 'ABCDEFGH'] Nom du pavé droit\n * @property {Point3d[]} sommets Tableau contenant les sommets du pavé droit\n * @property {string} color Couleur des arêtes du pavé droit : du type 'blue' ou du type '#f15929'\n * @property {Polygone3d} base Base ABFE du pavé droit\n * @property {Vecteur3d} hauteur Vecteur AD\n * @property {Arete3d} aretes Tableau contenant les arêtes du pavé droit\n * @property {Array} c2d Contient les commandes à tracer en 2d de cette fonction\n * @author Jean-Claude Lhote (optimisé par Eric Elter)\n * @class\n */\n\nexport class Pave3d extends ObjetMathalea2D {\n  constructor(\n    A: Point3d,\n    B: Point3d,\n    D: Point3d,\n    E: Point3d,\n    color = 'black',\n    affichageNom = false,\n    nom = 'ABCDEFGH',\n  ) {\n    super()\n    this.affichageNom = affichageNom\n    const v1 = vecteur3d(A, B)\n    const v2 = vecteur3d(A, E)\n    const C = translation3d(D, v1)\n    const H = translation3d(D, v2)\n    const G = translation3d(C, v2)\n    const F = translation3d(B, v2)\n\n    // Determination du point caché\n    function distanceMoyenne4points(pt: Point3d) {\n      const dist1 = longueur(pt.c2d, A.c2d, 5)\n      const dist2 = longueur(pt.c2d, B.c2d, 5)\n      const dist3 = longueur(pt.c2d, C.c2d, 5)\n      const dist4 = longueur(pt.c2d, D.c2d, 5)\n      return arrondi((dist1 + dist2 + dist3 + dist4) / 4, 5)\n    }\n\n    E.isVisible = !E.c2d.estDansQuadrilatere(A.c2d, B.c2d, C.c2d, D.c2d)\n    F.isVisible = !F.c2d.estDansQuadrilatere(A.c2d, B.c2d, C.c2d, D.c2d)\n    G.isVisible = !G.c2d.estDansQuadrilatere(A.c2d, B.c2d, C.c2d, D.c2d)\n    H.isVisible = !H.c2d.estDansQuadrilatere(A.c2d, B.c2d, C.c2d, D.c2d)\n    if (E.isVisible && F.isVisible && G.isVisible && H.isVisible) {\n      const minimum = Math.min(\n        distanceMoyenne4points(E),\n        distanceMoyenne4points(F),\n        distanceMoyenne4points(G),\n        distanceMoyenne4points(H),\n      )\n      E.isVisible = minimum !== distanceMoyenne4points(E)\n      F.isVisible = minimum !== distanceMoyenne4points(F)\n      G.isVisible = minimum !== distanceMoyenne4points(G)\n      H.isVisible = minimum !== distanceMoyenne4points(H)\n    }\n    // Fin de determination du point caché\n    this.sommets = [A, B, C, D, E, F, G, H]\n    this.color = colorToLatexOrHTML(color)\n    this.base = polygone3d(A, B, F, E)\n    this.hauteur = vecteur3d(A, D)\n    this.c2d = []\n    this.aretes = [\n      arete3d(A, B, color),\n      arete3d(A, D, color),\n      arete3d(A, E, color),\n      arete3d(C, B, color),\n      arete3d(F, B, color),\n      arete3d(C, D, color),\n      arete3d(C, G, color),\n      arete3d(F, G, color),\n      arete3d(F, E, color),\n      arete3d(H, G, color),\n      arete3d(H, E, color),\n      arete3d(H, D, color),\n    ]\n    for (const arete of this.aretes) {\n      this.c2d.push(arete.c2d)\n    }\n    if (this.affichageNom) {\n      let pointsFace = [A.c2d, B.c2d, C.c2d, D.c2d]\n      A.c2d.nom = nom[0]\n      B.c2d.nom = nom[1]\n      C.c2d.nom = nom[2]\n      D.c2d.nom = nom[3]\n      E.c2d.nom = nom[4]\n      F.c2d.nom = nom[5]\n      G.c2d.nom = nom[6]\n      H.c2d.nom = nom[7]\n\n      const faceAV = polygoneAvecNom(...pointsFace, context.isHtml ? 0.5 : 1.5)\n      pointsFace = [E.c2d, F.c2d, G.c2d, H.c2d]\n      const faceArr = polygoneAvecNom(...pointsFace, context.isHtml ? 0.5 : 1.5)\n      this.c2d.push(faceAV[1], faceArr[1])\n    }\n  }\n}\n/**\n * Construit le pavé ABCDEFGH dont les arêtes [AB],[AD] et [AE] délimitent 3 faces adjacentes.\n * La gestion des arêtes cachées est prise en compte et n'est pas forcément E.\n * En travaillant sur le signe de context.anglePerspective et sur celui de la hauteur (B.z), on peut avoir une vision de haut, de bas, de gauche, de droite comme dans l'exercice....\n * @param {Point3d} A Sommet du pavé droit\n * @param {Point3d} B Sommet du pavé droit\n * @param {Point3d} D Sommet du pavé droit\n * @param {Point3d} E Sommet du pavé droit\n * @param {boolean} [affichageNom = false] Permet (ou pas) l'affichage du nom des sommets du pavé droit.\n * @param {string} [nom = 'ABCDEFGH'] Nom du pavé droit\n * @example pave(A,B,D,E) // Créé un pavé noir sans nom\n * @example pave(A,B,D,E,'blue') // Créé un pavé bleu sans nom\n * @example pave(A,B,D,E,'red',true,'MNOPQRST') // Créé un pavé rouge dont les sommets sont nommés M, N, O, P, Q, R, S et T\n * @author Jean-Claude Lhote (optimisé par Eric Elter)\n * @return {Pave3d}\n */\n\nexport function pave3d(\n  A: Point3d,\n  B: Point3d,\n  D: Point3d,\n  E: Point3d,\n  color = 'black',\n  affichageNom = false,\n  nom = 'ABCDEFGH',\n) {\n  return new Pave3d(A, B, D, E, color, affichageNom, nom)\n}\n"],"names":["math","matrix","multiply","norm","cross","dot","Sphere3d","ObjetMathalea2D","centre","rayon","colorEquateur","colorEnveloppe","nbParalleles","colorParalleles","nbMeridiens","colorMeridiens","affichageAxe","colorAxe","inclinaison","faceCachee","droiteRot","droite3d","point3d","vecteur3d","poleNord","rotation3d","choisitLettresDifferentes","poleSud","nbParallelesDeConstruction","divisionParalleles","unDesParalleles","centreParallele","rayonDuParallele","normal","paralleles","enveloppeSphere1","enveloppeSphere2","premierParallele","indicePremier","indiceDernier","cercle3d","point","k","poly","j","polygone","ee","s","s1","d1","d2","jj","pt","segment","droite","cptBoucleInfinie","pointIntersectionDD","t","tracePoint","assombrirOuEclaircir","polyLineVisible","polyLineCachee","securite","longueur","dernierPoint","premierPoint","ligneCachee","polyline","colorToLatexOrHTML","ligneVisible","divisionMeridiens","polyLineCachee1","polyLineVisible1","polyLineCachee2","polyLineVisible2","ligneVisible1","ligneVisible2","ligneCachee1","ligneCachee2","enveloppeSphere","ii","p","l","pointSurSegment","sphere3d","Cone3d","sommet","color","colorCone","affichageCentre","affichageBase","pt1","translation3d","ptsBase","nbSommets","polygone3d","pyramide3d","cone3d","Cylindre3d","centrebase1","centrebase2","rayon1","rayon2","affichageGeneratrices","affichageCentreBases","cylindreColore","colorCylindre","avecFaceHaut","prodvec","prodscal","cote1","cote2","centre1PlusBasQueCentre2","context","angleDepart","distanceMax","d","ptReference","secondPt","sensRecherche","distancePointDroite","c1","demicercle3d","c3","c2","c4","polygon","i","faceColoree","baseColoree","distanceMin","axeCylindre","ptAxe1","translation","vecteur","ptAxe2","cylindre3d","Prisme3d","base","affichageNom","nomBase2","positionLabels2","toutesLesAretesSontVisibles","areteVisibleOuPas","arete3d","areteLiaison","listeLettres","nomBase1","el","index","renommePolygone","labelPoint","pointDepuisPointAbstrait","listeDeLettres2","prisme3d","Pyramide3d","estCone","aretesBase","sommetCache","sommetCacheAvant","angleReference","sommetGeneratriceCone","premierPlan","faceAv","longueurSegment","Point3d","intersectionTrouvee","ptBase","v","L","h","norme","nomBase","PyramideTronquee3d","coeff","sommetsBase2","pointSection","homothetie3d","pyramideTronquee3d","Cube3d","x","y","z","c","colorAV","colorHautouBas","colorDr","aretesCachee","nom","A","vx","vy","vz","B","C","D","pointsFace","faceAV","polygoneAvecNom","E","F","G","H","faceArr","vide2d","faceDr","faceVisibleHautOuBas","areteCachee3","areteCachee2","areteCachee1","cube3d","Barre3d","faceTop","faceD","barre3d","Plaque3d","plaque3d","PaveLPH3d","paveLPH3d","Pave3d","v1","v2","distanceMoyenne4points","dist1","dist2","dist3","dist4","arrondi","minimum","arete","pave3d"],"mappings":"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"}
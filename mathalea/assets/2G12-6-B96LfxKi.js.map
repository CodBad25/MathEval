{"version":3,"file":"2G12-6-B96LfxKi.js","sources":["../../src/exercices/2e/2G12-6.ts"],"sourcesContent":["import type { Matrix } from 'mathjs'\nimport { point, Point, tracePoint, TracePoint } from '../../lib/2d/points'\nimport { Segment, segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint } from '../../lib/2d/textes'\nimport { homothetie, rotation, similitude } from '../../lib/2d/transformations'\nimport { ajouteQuestionMathlive } from '../../lib/interactif/questionMathLive'\nimport { Matrice } from '../../lib/mathFonctions/Matrice'\nimport { choisitLettresDifferentes } from '../../lib/outils/aleatoires'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport {\n  colorToLatexOrHTML,\n  fixeBordures,\n  mathalea2d,\n} from '../../modules/2dGeneralites'\nimport type FractionEtendue from '../../modules/FractionEtendue'\nimport { fraction } from '../../modules/fractions'\nimport { gestionnaireFormulaireTexte, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const uuid = '2c20c'\nexport const titre =\n  'Lire des coordonnées en repère orthogonal, normé ou quelconque'\nexport const refs = {\n  'fr-fr': ['2G12-6'],\n  'fr-ch': ['9FA1-10', '10FA5-21'],\n}\n\n/**\n * @title Repérage 2e\n * @author Jean-Claude Lhote\n * On se propose de lire des coordonnées dans un repère orthogonal, normé ou quelconque.\n * Une version de cet exercice en sens inverse est disponible sous le titre \"Repérage 2e\" (bis).\n */\nexport default class Reperage2e extends Exercice {\n  constructor() {\n    super()\n    this.nbQuestions = 1\n    this.besoinFormulaireTexte = [\n      'Type de repère',\n      [\n        'Nombres séparés par des tirets  :',\n        '1 : Orthogonal',\n        '2 : Normé',\n        '3 : Quelconque',\n        '4 : Mélange',\n      ].join('\\n'),\n    ]\n    this.sup = '1'\n    this.besoinFormulaire2CaseACocher = [\n      'Présence de coordonnées fractionnaires',\n      false,\n    ]\n    this.sup2 = false\n    this.besoinFormulaire3Numerique = ['Nombre de points à trouver/placer', 3]\n    this.sup3 = 3\n    this.besoinFormulaire4CaseACocher = ['Papier pointé / Quadrillage', false]\n    this.sup4 = false\n    this.comment = `Exercice fait suite à une demande sur la forge de Carole Feugère.<br> Il y a trois types de repères, le premier est orthogonal mais pas normé, le deuxième est normé mais pas orthonormal, le troisième n'est ni normé ni orthogonal.<br>\n    Les points à trouver sont choisis aléatoirement à coordonnées entières. On peut choisir le nombre de points à trouver de 1 à 3.`\n  }\n\n  nouvelleVersion() {\n    const listeTypeDeReperes = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      min: 1,\n      max: 3,\n      melange: 4,\n      nbQuestions: this.nbQuestions,\n      defaut: 4,\n    })\n    const x: FractionEtendue[][] = []\n    const y: FractionEtendue[][] = []\n    const X: number[][] = []\n    const Y: number[][] = []\n    const noms: string[][] = []\n    const points: Point[][] = []\n    for (let i = 0; i < this.nbQuestions; ) {\n      x[i] = []\n      y[i] = []\n      X[i] = []\n      Y[i] = []\n      points[i] = []\n      noms[i] = []\n      let coordsI: [number, number]\n      let coordsK: [number, number]\n      let matrice: Matrice\n      let matriceInverse: Matrice | undefined\n      const listeNoms = choisitLettresDifferentes(3 + this.sup3)\n      const [labelI, labelK, labelO] = listeNoms.slice(0, 3)\n      noms[i] = listeNoms.slice(3)\n      const pointO = point(0, 0, labelO, 'below left')\n\n      do {\n        switch (listeTypeDeReperes[i]) {\n          case 1:\n            coordsI = [choice([1.5, 2.5]), 0]\n            coordsK = [0, choice([1, 2])]\n            break\n          case 2:\n            {\n              const I = similitude(\n                point(randint(6, 8) * 0.2, 0),\n                pointO,\n                randint(-20, 20),\n                1,\n              )\n              coordsI = [I.x, I.y]\n              const K = similitude(\n                point(...coordsI),\n                pointO,\n                randint(60, 80),\n                1,\n              )\n              coordsK = [K.x, K.y]\n            }\n            break\n          case 3:\n          default:\n            {\n              coordsI = [1.5, randint(-4, 4, [0]) * 0.2]\n              const K = similitude(\n                point(...coordsI),\n                pointO,\n                randint(60, 80),\n                choice([0.6, 0.7, 1.25, 1.3, 1.4]),\n              )\n              coordsK = [K.x, K.y]\n            }\n            break\n        }\n        matrice = new Matrice([\n          [coordsI[0], coordsK[0]],\n          [coordsI[1], coordsK[1]],\n        ])\n        matriceInverse = matrice.inverse()\n      } while (matrice == null || matriceInverse == null)\n      const pointI = point(coordsI[0], coordsI[1], labelI, 'below')\n      const pointK = point(coordsK[0], coordsK[1], labelK, 'left')\n      const traceRep = tracePoint(pointO, pointI, pointK)\n      traceRep.style = '.'\n      traceRep.epaisseur = 1\n      const IPrime = homothetie(pointI, pointO, 4)\n      const KPrime = homothetie(pointK, pointO, 3)\n      const INeg = rotation(IPrime, pointO, 180)\n      const KNeg = rotation(KPrime, pointO, 180)\n      const OI = segment(INeg, homothetie(IPrime, pointO, 1.05))\n      OI.epaisseur = 1.5\n      OI.styleExtremites = '->'\n      const OK = segment(KNeg, homothetie(KPrime, pointO, 1.1))\n      OK.epaisseur = 1.5\n      OK.styleExtremites = '->'\n      const grid: (Point | Segment)[] = []\n      /*\n      Construire la grille\n      */\n      let denX: number = 1\n      let denY: number = 1\n      if (this.sup2) {\n        denX = choice([1, 2, 3])\n        denY = choice([1, 2, 3], [denX])\n      }\n      for (let xx = -4; xx < 4 + 1 / denX; xx += 1 / denX) {\n        if (this.sup4) {\n          const pointL = point(\n            ...((matrice.multiply([\n              xx,\n              -3,\n            ]) as unknown as Matrix)!.toArray() as [number, number]),\n          )\n          const pointH = point(\n            ...((matrice.multiply([xx, 3]) as unknown as Matrix)!.toArray() as [\n              number,\n              number,\n            ]),\n          )\n          if (Math.abs(xx) > 0.01) grid.push(segment(pointL, pointH))\n        }\n        for (let yy = -3; yy < 3 + 1 / denY; yy += 1 / denY) {\n          if (this.sup4 && xx === -4) {\n            const pointL = point(\n              ...((matrice.multiply([\n                -4,\n                yy,\n              ]) as unknown as Matrix)!.toArray() as [number, number]),\n            )\n            const pointH = point(\n              ...((matrice.multiply([\n                4,\n                yy,\n              ]) as unknown as Matrix)!.toArray() as [number, number]),\n            )\n            if (Math.abs(yy) > 0.01) grid.push(segment(pointL, pointH))\n          }\n          if (!this.sup4) {\n            // Si pas de grille, on fait des points et on ajoute des ticks sur les axes.\n            if (Math.abs(xx) > 0.1 && Math.abs(yy) > 0.1) {\n              grid.push(\n                point(\n                  ...((matrice.multiply([\n                    xx,\n                    yy,\n                  ]) as unknown as Matrix)!.toArray() as [number, number]),\n                ),\n              )\n            } else {\n              const [x, y] = (matrice.multiply([\n                xx,\n                yy,\n              ]) as unknown as Matrix)!.toArray() as [number, number]\n              if (Math.abs(x) < 0.1) {\n                // On est sur l'axe des ordonnées\n                const s = segment(x - 0.1, y, x + 0.1, y)\n                s.epaisseur = 1.5\n                if (Math.abs(y) > 0.1) grid.push(s)\n              }\n              if (Math.abs(y) < 0.1) {\n                // On est sur l'axe des abscisses\n                const s = segment(x, y - 0.1, x, y + 0.1)\n                s.epaisseur = 1.5\n                if (Math.abs(x) > 0.1) grid.push(s)\n              }\n            }\n          }\n        }\n      }\n      const dots = this.sup4\n        ? grid\n        : tracePoint(...grid.filter((el) => el instanceof Point))\n      const ticks = this.sup4 ? [] : grid.filter((el) => el instanceof Segment)\n      if (this.sup4) {\n        for (const el of dots as Segment[]) {\n          el.styleExtremites = '-'\n          el.epaisseur = 0.5\n          el.color = colorToLatexOrHTML('gray')\n          el.opacite = 0.6\n        }\n      } else {\n        ;(dots as TracePoint).style = '.'\n        ;(dots as TracePoint).epaisseur = 0.4\n        ;(dots as TracePoint).opacite = 0.6\n        ;(dots as TracePoint).color = colorToLatexOrHTML('gray')\n      }\n\n      for (let k = 0; k < this.sup3; k++) {\n        do {\n          x[i][k] = fraction(randint(-3 * denX, 3 * denX), denX)\n          y[i][k] = fraction(randint(-2 * denY, 2 * denY), denY)\n        } while (\n          (x[i][k].isEqual(0) && y[i][k].isEqual(1)) ||\n          (x[i][k].isEqual(1) && y[i][k].isEqual(0)) ||\n          (x[i][k].isEqual(0) && y[i][k].isEqual(0)) ||\n          (x[i]\n            .slice(0, k)\n            .map((el) => el.num)\n            .includes(x[i][k].num) &&\n            y[i]\n              .slice(0, k)\n              .map((el) => el.num)\n              .includes(y[i][k].num))\n        )\n        const [mdx, mdy] = (\n          matrice.multiply([\n            x[i][k].valeurDecimale,\n            y[i][k].valeurDecimale,\n          ]) as unknown as Matrix\n        ).toArray() as [number, number]\n        X[i][k] = mdx\n        Y[i][k] = mdy\n        points[i][k] = point(\n          mdx,\n          mdy,\n          listeNoms[3 + k],\n          `${\n            x[i][k].valeurDecimale < 0\n              ? y[i][k].valeurDecimale < 0\n                ? 'below left'\n                : 'above left'\n              : y[i][k].valeurDecimale\n                ? 'below right'\n                : 'above right'\n          }`,\n        )\n      }\n      const traces = tracePoint(...points[i])\n      traces.style = 'x'\n      traces.epaisseur = 2\n      traces.color = colorToLatexOrHTML('black')\n      const labels = labelPoint(pointO, pointI, pointK, ...points[i])\n      const objets = [traces, traceRep, labels, OI, OK, dots, ticks]\n      let question = mathalea2d(\n        Object.assign({ scale: 0.5 }, fixeBordures(objets)),\n        objets,\n      )\n\n      question += `Quelles sont les coordonnées des points $${noms[i].join('$, $')}$ dans le repère $(${labelO},${labelI},${labelK})$ ?<br>`\n      if (this.interactif) {\n        question += noms[i]\n          .map(\n            (el, k) =>\n              `Coordonnées de $${el}$ : ${ajouteQuestionMathlive({\n                exercice: this,\n                question: i * this.sup3 + k,\n                typeInteractivite: 'fillInTheBlank',\n                // objetReponse: { champ1: { value: x[i][k].texFractionSimplifiee, options: { nombreDecimalSeulement: true } }, champ2: { value: y[i][k].texFractionSimplifiee, options: { nombreDecimalSeulement: true } }, bareme: (listePoints: number[]) => [Math.min(...listePoints), 1] },\n                objetReponse: {\n                  champ1: { value: x[i][k].texFractionSimplifiee },\n                  champ2: { value: y[i][k].texFractionSimplifiee },\n                  bareme: (listePoints: number[]) => [\n                    Math.min(...listePoints),\n                    1,\n                  ],\n                },\n                content: '(%{champ1}~~;~~%{champ2})',\n              })}`,\n          )\n          .join('<br>')\n      } else {\n        question += noms[i]\n          .map((el) => `Coordonnées de $${el}$ : $(\\\\ldots~~;~~\\\\ldots)$`)\n          .join('<br>')\n      }\n      const reponse = `Dans le repère $(${labelO},${labelI},${labelK})$ sont :<br>\n            $${points[i].map((p, k) => `${listeNoms[k + 3]}(${x[i][k].texFractionSimplifiee};${y[i][k].texFractionSimplifiee})`).join(', ')}$`\n      if (\n        this.questionJamaisPosee(i, ...X[i], ...Y[i], ...coordsI, ...coordsK)\n      ) {\n        this.listeQuestions[i] = question\n        this.listeCorrections[i] = reponse\n        i++\n      }\n    }\n  }\n}\n"],"names":["interactifReady","interactifType","uuid","titre","refs","Reperage2e","Exercice","listeTypeDeReperes","gestionnaireFormulaireTexte","x","y","X","Y","noms","points","i","coordsI","coordsK","matrice","matriceInverse","listeNoms","choisitLettresDifferentes","labelI","labelK","labelO","pointO","point","choice","I","similitude","randint","K","Matrice","pointI","pointK","traceRep","tracePoint","IPrime","homothetie","KPrime","INeg","rotation","KNeg","OI","segment","OK","grid","denX","denY","xx","pointL","pointH","yy","s","dots","el","Point","ticks","Segment","colorToLatexOrHTML","k","fraction","mdx","mdy","traces","labels","labelPoint","objets","question","mathalea2d","fixeBordures","ajouteQuestionMathlive","listePoints","reponse","p"],"mappings":"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"}
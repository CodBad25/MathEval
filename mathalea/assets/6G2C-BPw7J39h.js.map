{"version":3,"file":"6G2C-BPw7J39h.js","sources":["../../src/exercices/6e/6G2C.ts"],"sourcesContent":["import { angleOriente } from '../../lib/2d/angles'\nimport { Arc, arc, cercle } from '../../lib/2d/cercle'\nimport { afficheCoteSegment, placeLatexSurSegment } from '../../lib/2d/codages'\nimport { droite } from '../../lib/2d/droites'\nimport {\n  Point,\n  point,\n  pointIntersectionCC,\n  pointIntersectionDD,\n  pointIntersectionLC,\n  pointSurSegment,\n  tracePoint,\n} from '../../lib/2d/points'\nimport { pointAbstrait } from '../../lib/2d/points-abstraits'\nimport { BoiteBuilder, polygone } from '../../lib/2d/polygones'\nimport { cordelette, longueur, segment } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint, texteParPosition } from '../../lib/2d/textes'\nimport { homothetie, rotation } from '../../lib/2d/transformations'\nimport { numAlpha } from '../../lib/outils/outilString'\nimport {\n  colorToLatexOrHTML,\n  fixeBordures,\n  mathalea2d,\n} from '../../modules/2dGeneralites'\nimport { context } from '../../modules/context'\nimport { gestionnaireFormulaireTexte, randint } from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const titre =\n  'Résoudre des problèmes mettant en jeu des distances à un point'\nexport const interactifReady = false\n\nexport const dateDePublication = '03/08/2025'\n\n/**\n * Exercice tiré des documents officiels : un classique de la géométrie plane\n * @author Jean-Claude Lhote\n\n*/\nexport const uuid = '29c3c'\n\nexport const refs = {\n  'fr-fr': ['6G2C'],\n  'fr-2016': ['6G54'],\n  'fr-ch': ['9ES4-15'],\n}\nexport default class ProblemeDeLaChevreDansSonEnclos extends Exercice {\n  constructor() {\n    super()\n    this.comment =\n      \"Cet exercice n'est pas interactif, il s'agit d'un problème de géométrie plane classique à faire sur papier.\"\n    this.nbQuestions = 1\n    this.besoinFormulaireTexte = [\n      'Types de question',\n      \"Nombres séparés par des tirets :\\n1 : Cabane au coin de l'enclos\\n2 : Cabane sur un côté de l'enclos\\n3 : Cabane sans contact avec l'enclos\\n4 : Mélange\",\n    ]\n    this.sup = '1'\n  }\n\n  nouvelleVersion() {\n    const listeTypesDeQuestions = gestionnaireFormulaireTexte({\n      saisie: this.sup,\n      nbQuestions: this.nbQuestions,\n      min: 1,\n      max: 3,\n      defaut: 1,\n      melange: 4,\n    }).map(Number)\n    for (let i = 0, cpt = 0; i < this.nbQuestions && cpt < 50; ) {\n      const longueurEnclos = randint(12, 16)\n      const largeurEnclos = randint(10, longueurEnclos - 1)\n      const longueurCabane = randint(4, Math.ceil(longueurEnclos / 3))\n      const largeurCabane = randint(\n        3,\n        Math.min(Math.ceil(largeurEnclos / 3), longueurCabane - 1),\n      )\n      const offsetPointP = randint(1, longueurCabane - 1)\n      // La corde n'intercepte jamais le bord gauche quand la cabane est collée au bord droit... Mais attention à la cabane au centre !\n      const longueurCordelette = randint(\n        Math.max(offsetPointP, longueurCabane - offsetPointP + 1),\n        largeurEnclos - largeurCabane,\n      )\n\n      const objetsEnonce = []\n      const objetsCorrection = []\n      let texte = ''\n      let texteCorr = ''\n      const A = point(0, 0)\n      const B = point(longueurEnclos, 0)\n      const C = point(longueurEnclos, largeurEnclos)\n      const D = point(0, largeurEnclos)\n      // Les bords de l'enclos pour les intersections\n      const AB = droite(A, B)\n      const BC = droite(B, C)\n      const CD = droite(C, D)\n      const DA = droite(D, A)\n      let cabA: Point\n      let cabB: Point\n      let cabC: Point\n      let cabD: Point\n      let P: Point\n      const enclos = polygone(A, B, C, D)\n\n      switch (listeTypesDeQuestions[i]) {\n        /*********************************/\n        // cabane sur le côté droit\n        /*********************************/\n        case 2:\n          {\n            cabA = point(\n              longueurEnclos,\n              randint(3, largeurEnclos - largeurCabane - 1),\n            )\n            cabB = point(longueurEnclos, cabA.y + largeurCabane)\n            cabD = point(cabA.x - longueurCabane, cabA.y)\n            cabC = point(cabD.x, cabB.y)\n            P = point(cabA.x - offsetPointP, cabA.y, 'P', 'above')\n            // longueur additionnelle énoncé\n            const hSousCabane = afficheCoteSegment(\n              segment(cabA, B),\n              `${cabA.y}\\\\,\\\\text{m}`,\n              0.2,\n              'black',\n              1,\n              1,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            objetsEnonce.push(hSousCabane)\n            // On s'occupe d'abord de ce qu'il y a sous la cabane\n            let I: Point\n            const J = homothetie(\n              P,\n              cabA,\n              (offsetPointP + longueurCordelette) / offsetPointP,\n            )\n            const c1 = cercle(P, longueurCordelette)\n            if (cabA.y >= longueurCordelette) {\n              if (longueurCordelette < offsetPointP) {\n                // On a un demi-cercle de centre P\n                I = pointIntersectionLC(droite(cabA, cabD), c1, '', 2) as Point\n                const a1 = arc(\n                  I,\n                  P,\n                  -Math.abs(angleOriente(I, P, J)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a1.couleurDesHachures = colorToLatexOrHTML('black')\n                a1.hachures = 'north east lines'\n                a1.opacite = 0.2\n                objetsCorrection.push(a1)\n              } else {\n                // la corde intercepte le coté droit et comme longueurCordelette<=cabA.y, ça se trouve dans l'enclos et l'arc n'est pas intercepté par le bord de l'enclos\n                I = pointIntersectionLC(droite(cabA, B), c1, '', 2) as Point\n                const a1 = arc(\n                  I,\n                  P,\n                  -Math.abs(angleOriente(I, P, J)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a1.couleurDesHachures = colorToLatexOrHTML('black')\n                a1.hachures = 'north east lines'\n                a1.opacite = 0.2\n\n                const t1 = polygone(I, cabA, P)\n                t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t1.opaciteDeRemplissage = 0.4\n                t1.couleurDesHachures = colorToLatexOrHTML('black')\n                t1.hachures = 'north east lines'\n                t1.opacite = 0.2\n                objetsCorrection.push(a1, t1)\n              }\n            } else {\n              /* --------------------------------- */\n              // la corde intercepte le bord bas\n              /* --------------------------------- */\n              if (longueurCordelette < offsetPointP) {\n                // La corde d'intercepte pas le bord droit\n                // On a un demi-cercle de centre P itercepté par le bord bas de l'enclos\n                // On va faire : 1 triangle PMN et deux arcs IM et NJ de centre P\n                I = pointIntersectionLC(droite(cabA, cabD), c1, '', 2) as Point\n                const M = pointIntersectionLC(AB, c1, '', 2) as Point\n                const N = pointIntersectionLC(AB, c1, '', 1) as Point\n                const a1 = arc(\n                  I,\n                  P,\n                  -Math.abs(angleOriente(I, P, M)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a1.couleurDesHachures = colorToLatexOrHTML('black')\n                a1.hachures = 'north east lines'\n                a1.opacite = 0.2\n\n                const t1 = polygone(P, M, N)\n                t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t1.opaciteDeRemplissage = 0.4\n                t1.couleurDesHachures = colorToLatexOrHTML('black')\n                t1.hachures = 'north east lines'\n                t1.opacite = 0.2\n                const a2 = arc(\n                  N,\n                  P,\n                  -Math.abs(angleOriente(N, P, J)),\n                  true,\n                  'pink',\n                  'black',\n                  0.4,\n                )\n                a2.couleurDesHachures = colorToLatexOrHTML('black')\n                a2.hachures = 'north east lines'\n                a2.opacite = 0.2\n                objetsCorrection.push(a1, t1, a2)\n              } else {\n                // la corde intercepte le coté droit et intercepte aussi le bord bas.\n                // on va faire : t1, a1, t2, a2 ou, si le coin est à portée de cordelette, un trapèze et un arc.\n                if (\n                  longueurCordelette ** 2 >=\n                  offsetPointP ** 2 + cabA.y ** 2\n                ) {\n                  // On couvre tout le coin en bas à droite par un trapèze jusqu'au point de départ de l'arc\n                  // on s'occupe déja du trapèze\n                  const N = pointIntersectionLC(AB, c1, '', 1) as Point\n                  I = N\n                  const t1 = polygone(P, cabA, B, N)\n                  t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t1.opaciteDeRemplissage = 0.4\n                  t1.couleurDesHachures = colorToLatexOrHTML('black')\n                  t1.hachures = 'north east lines'\n                  t1.opacite = 0.2\n                  const a2 = arc(\n                    N,\n                    P,\n                    -Math.abs(angleOriente(N, P, J)),\n                    true,\n                    'pink',\n                    'black',\n                    0.4,\n                  )\n                  a2.couleurDesHachures = colorToLatexOrHTML('black')\n                  a2.hachures = 'north east lines'\n                  a2.opacite = 0.2\n                  objetsCorrection.push(t1, a2)\n                } else {\n                  I = pointIntersectionLC(droite(cabA, B), c1, '', 2) as Point\n                  const M = pointIntersectionLC(AB, c1, '', 2) as Point\n                  const N = pointIntersectionLC(AB, c1, '', 1) as Point\n                  if (I.y !== cabA.y) {\n                    // On peut avoir un arc tangent au bord droit, dans ce cas, pas besoin de triangle.\n                    const t1 = polygone(P, cabA, I)\n                    t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                    t1.opaciteDeRemplissage = 0.4\n                    t1.couleurDesHachures = colorToLatexOrHTML('black')\n                    t1.hachures = 'north east lines'\n                    t1.opacite = 0.2\n                    objetsCorrection.push(t1)\n                  }\n                  const a1 = arc(\n                    I,\n                    P,\n                    -Math.abs(angleOriente(I, P, M)),\n                    true,\n                    'pink',\n                    'black',\n                    0.4,\n                  )\n                  a1.couleurDesHachures = colorToLatexOrHTML('black')\n                  a1.hachures = 'north east lines'\n                  a1.opacite = 0.2\n                  const t2 = polygone(P, M, N)\n                  t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t2.opaciteDeRemplissage = 0.4\n                  t2.couleurDesHachures = colorToLatexOrHTML('black')\n                  t2.hachures = 'north east lines'\n                  t2.opacite = 0.2\n                  const a2 = arc(\n                    N,\n                    P,\n                    -Math.abs(angleOriente(N, P, J)),\n                    true,\n                    'pink',\n                    'black',\n                    0.4,\n                  )\n                  a2.couleurDesHachures = colorToLatexOrHTML('black')\n                  a2.hachures = 'north east lines'\n                  a2.opacite = 0.2\n                  objetsCorrection.push(a1, t2, a2)\n                }\n              }\n            }\n            const r1Mes = afficheCoteSegment(\n              segment(P, I),\n              `${longueurCordelette}\\\\,\\\\text{m}`,\n              0,\n              'black',\n              0.5,\n              0.5,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            // const r1Mes = placeLatexSurSegment(`${longueurCordelette}\\\\text{ m}`, P, I, { distance: 0.3 })\n            objetsCorrection.push(r1Mes)\n            /* --------------------------------------------------- */\n            // fin de la partie 'sous-cabane' on attaque la partie commençant à J qui ne peut pas intercepter le bord gauche (ouf !)\n            /* --------------------------------------------------- */\n            const longueurRestante1 =\n              longueurCordelette - (longueurCabane - offsetPointP)\n            const diff = afficheCoteSegment(\n              segment(P, cabD),\n              `${longueurCabane - offsetPointP}\\\\,\\\\text{m}`,\n              0.5,\n              'black',\n              1,\n              0.5,\n              'black',\n            )\n            if (longueurRestante1 + cabA.y > largeurEnclos) {\n              /* ------------------------------------ */\n              // Le quart de cercle intercepte le bord haut de l'enclos : on a arc puis triangle puis arc\n              /* ------------------------------------ */\n              const c2 = cercle(cabD, longueurRestante1)\n              const M = pointIntersectionLC(CD, c2, '', 1) as Point\n              const l1 = afficheCoteSegment(\n                segment(cabD, M),\n                `${longueurRestante1}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const a1 = arc(\n                J,\n                cabD,\n                angleOriente(J, cabD, M),\n                true,\n                'pink',\n                'black',\n                0.3,\n              )\n              a1.couleurDesHachures = colorToLatexOrHTML('black')\n              a1.hachures = 'north east lines'\n              a1.opacite = 0.2\n\n              const K = pointIntersectionDD(droite(cabC, cabD), CD) as Point\n              const t1 = polygone(M, cabD, K)\n              t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t1.opaciteDeRemplissage = 0.3\n              t1.couleurDesHachures = colorToLatexOrHTML('black')\n              t1.hachures = 'north east lines'\n              t1.opacite = 0.2\n              const longueurRestante2 = longueurRestante1 - largeurCabane\n              if (\n                longueurRestante2 ** 2 >=\n                longueurCabane ** 2 + (largeurEnclos - cabB.y) ** 2\n              ) {\n                // La corde permet d'aller jusqu'au coin haut droit de l'enclos\n                // on dessine un rectangle\n                const r1 = polygone(K, C, cabB, cabC)\n                r1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                r1.opaciteDeRemplissage = 0.2\n                r1.couleurDesHachures = colorToLatexOrHTML('black')\n                r1.hachures = 'north east lines'\n                r1.opacite = 0.2\n                objetsCorrection.push(r1)\n              } else {\n                // on n'atteint pas le coin, mais peut-être le bord droit !\n                // tout d'abord le triangle\n                const c2 = cercle(cabC, longueurRestante2)\n                const N = pointIntersectionLC(CD, c2, '', 2) as Point\n                const t3 = polygone(K, N, cabC)\n                const X = homothetie(\n                  rotation(K, cabC, -45),\n                  cabC,\n                  longueurRestante2 / longueur(cabC, K),\n                )\n                const l2 = afficheCoteSegment(\n                  segment(cabC, X),\n                  `${longueurRestante2}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  1,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t3.opaciteDeRemplissage = 0.2\n                t3.couleurDesHachures = colorToLatexOrHTML('black')\n                t3.hachures = 'north east lines'\n                t3.opacite = 0.2\n                objetsCorrection.push(t3, l2)\n                if (longueurRestante2 > longueurCabane) {\n                  // Le bord droit bloque : triangle + arc + triangle\n                  const X = pointIntersectionLC(BC, c2, '', 1) as Point\n                  const a3 = arc(\n                    N,\n                    cabC,\n                    angleOriente(N, cabC, X),\n                    true,\n                    'pink',\n                    'black',\n                    0.2,\n                  )\n                  a3.couleurDesHachures = colorToLatexOrHTML('black')\n                  a3.hachures = 'north east lines'\n                  a3.opacite = 0.2\n                  const t4 = polygone(X, cabC, cabB)\n                  t4.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t4.opaciteDeRemplissage = 0.2\n                  t4.couleurDesHachures = colorToLatexOrHTML('black')\n                  t4.hachures = 'north east lines'\n                  t4.opacite = 0.2\n                  objetsCorrection.push(a3, t4)\n                } else {\n                  // On n'atteint pas le bord droit : triangle + arc\n                  const a3 = arc(\n                    N,\n                    cabC,\n                    angleOriente(N, cabC, cabB),\n                    true,\n                    'pink',\n                    'black',\n                    0.2,\n                  )\n                  a3.couleurDesHachures = colorToLatexOrHTML('black')\n                  a3.hachures = 'north east lines'\n                  a3.opacite = 0.2\n                  objetsCorrection.push(a3)\n                }\n              }\n              objetsCorrection.push(a1, t1, l1)\n            } else {\n              // Pas de contact avec bord haut, le quart de cercle est complet et ensuite on a un autre quart de cercle\n              const quartDeC2 = arc(J, cabD, -90, true, 'pink', 'black', 0.3)\n              quartDeC2.hachures = 'north east lines'\n              quartDeC2.couleurDesHachures = colorToLatexOrHTML('black')\n              quartDeC2.opacite = 0.2\n              const Z = rotation(J, cabD, -45)\n              const r2 = afficheCoteSegment(\n                segment(cabD, Z),\n                `${longueurRestante1}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              objetsCorrection.push(quartDeC2, r2, diff)\n              if (longueurRestante1 > largeurCabane) {\n                const longueurRestante2 = longueurRestante1 - largeurCabane\n                const K = rotation(J, cabD, -90)\n                const quartDeC3 = arc(K, cabC, -90, true, 'pink', 'black', 0.2)\n                quartDeC3.hachures = 'north east lines'\n                quartDeC3.couleurDesHachures = colorToLatexOrHTML('black')\n                quartDeC3.opacite = 0.2\n                const W = rotation(K, cabC, -45)\n                const r3 = afficheCoteSegment(\n                  segment(cabC, W),\n                  `${longueurRestante2}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                objetsCorrection.push(quartDeC3, r3)\n              }\n            }\n          }\n          break\n        case 3:\n          /*********************************/\n          // cabane au centre\n          /*********************************/\n          {\n            cabA = point(\n              randint(\n                Math.ceil(longueurEnclos / 3) + longueurCabane,\n                longueurEnclos - 2,\n              ),\n              randint(\n                Math.max(2, Math.floor(largeurEnclos / 2 - largeurCabane / 2)),\n                Math.min(\n                  largeurEnclos - largeurCabane - 2,\n                  Math.floor(largeurEnclos / 2 + largeurCabane / 2),\n                ),\n              ),\n            )\n            cabB = point(cabA.x, cabA.y + largeurCabane)\n            cabD = point(cabA.x - longueurCabane, cabA.y)\n            cabC = point(cabD.x, cabB.y)\n            P = point(cabA.x - offsetPointP, cabA.y, 'P', 'above')\n            const hSousCabane = afficheCoteSegment(\n              segment(cabA, pointAbstrait(cabA.x, 0)),\n              `${cabA.y}\\\\,\\\\text{m}`,\n              0.2,\n              'darkgray',\n              1,\n              1,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            const offsetCabane = afficheCoteSegment(\n              segment(pointAbstrait(0, cabC.y), cabC),\n              `${cabC.x}\\\\,\\\\text{m}`,\n              0.2,\n              'darkgray',\n              1,\n              1,\n              context.isHtml ? 'gray' : 'darkgray',\n              true,\n            )\n            objetsEnonce.push(hSousCabane, offsetCabane)\n            // On détermine s'il y a des intersections\n            const longueurRestanteDroite = longueurCordelette - offsetPointP\n            const longueurRestanteGauche =\n              longueurCordelette - (longueurCabane - offsetPointP)\n            const longueurRestanteHautDroite =\n              longueurRestanteDroite - largeurCabane\n            const longueurRestanteHautGauche =\n              longueurRestanteGauche - largeurCabane\n\n            const isTouchAB = longueurCordelette > cabA.y\n            const isTouchCDByLeft =\n              cabD.y + longueurRestanteGauche > largeurEnclos\n            const isTouchCDByRight =\n              cabA.y + longueurRestanteDroite > largeurEnclos\n            // On commence par le dessous de la cabane\n            let M: Point\n            let N: Point\n            let I: Point\n            let J: Point\n            const c1 = cercle(P, longueurCordelette)\n            if (isTouchAB) {\n              // On commence par ajouter le triangle bas\n              M = pointIntersectionLC(AB, c1, '', 1) as Point\n              if (M.x < 0) M = A\n              N = pointIntersectionLC(AB, c1, '', 2) as Point\n              if (N.x > longueurEnclos) N = B\n              const t1 = polygone(P, M, N)\n              t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t1.opaciteDeRemplissage = 0.4\n              t1.couleurDesHachures = colorToLatexOrHTML('black')\n              t1.hachures = 'north east lines'\n              const r1 = afficheCoteSegment(\n                segment(P, M),\n                `${longueurCordelette}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const r2 = afficheCoteSegment(\n                segment(P, N),\n                `${longueurCordelette}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              objetsCorrection.push(t1, r1, r2)\n              // arc gauche\n              const X = point(0, cabA.y)\n              if (P.x - longueurCordelette < 0 && M.x > 0) {\n                // contact à gauche\n                J = pointIntersectionLC(DA, c1, '', 2) as Point\n              } else {\n                J = X\n              }\n              const a1 =\n                Math.abs(M.x) < 0.01\n                  ? polygone(M, P, J)\n                  : arc(M, P, angleOriente(M, P, J), true)\n              a1.opaciteDeRemplissage = 0.4\n              a1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              a1.couleurDesHachures = colorToLatexOrHTML('black')\n              a1.hachures = 'north east lines'\n              a1.opacite = 0.2\n              if (J.y < cabA.y) {\n                // On a dessiné un arc, mais il reste un triangle à faire\n                const t2 = polygone(P, J, X)\n                t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t2.opaciteDeRemplissage = 0.4\n                t2.couleurDesHachures = colorToLatexOrHTML('black')\n                t2.hachures = 'north east lines'\n                t2.opacite = 0.2\n                const r2 = afficheCoteSegment(\n                  segment(cabD, X),\n                  `${cabD.x}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                objetsCorrection.push(t2, r2)\n              }\n              // arc droit\n              if (\n                P.x + longueurCordelette > longueurEnclos &&\n                N.x < longueurEnclos\n              ) {\n                // il y a contact avec la droite\n                I = pointIntersectionLC(BC, c1, '', 2) as Point\n              } else {\n                I = point(\n                  Math.min(longueurEnclos, P.x + longueurCordelette),\n                  cabA.y,\n                )\n              }\n              const a2 =\n                N.x === longueurEnclos\n                  ? polygone(N, P, I)\n                  : arc(N, P, angleOriente(N, P, I), true)\n              a2.opaciteDeRemplissage = 0.4\n              a2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              a2.couleurDesHachures = colorToLatexOrHTML('black')\n              a2.hachures = 'north east lines'\n              a2.opacite = 0.2\n              objetsCorrection.push(a1, a2)\n            } else {\n              // On ne touche pas le fond, on dessine un arc\n              const X = point(P.x, P.y - longueurCordelette)\n              if (P.x + longueurCordelette >= longueurEnclos) {\n                // il y a contact avec la droite\n                I = pointIntersectionLC(BC, c1, '', 2) as Point\n              } else {\n                I = point(P.x + longueurCordelette, cabA.y)\n              }\n              if (P.x - longueurCordelette < 0) {\n                // il y a contact avec la gauche\n                J = pointIntersectionLC(DA, c1, '', 2) as Point\n              } else {\n                J = point(P.x - longueurCordelette, cabA.y)\n              }\n              const r1 = afficheCoteSegment(\n                segment(P, X),\n                `${longueurCordelette}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const r2 = afficheCoteSegment(\n                segment(cabA, I),\n                `${longueurRestanteDroite}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                -0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n\n              const r3 = afficheCoteSegment(\n                segment(cabD, J),\n                `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              const a1 = arc(\n                I,\n                P,\n                -Math.abs(angleOriente(I, P, J)),\n                true,\n                'pink',\n                'black',\n                0.4,\n              )\n              a1.couleurDesHachures = colorToLatexOrHTML('black')\n              a1.hachures = 'north east lines'\n              a1.opacite = 0.2\n              objetsCorrection.push(a1, r1, r2, r3)\n            }\n            if (I.y < cabA.y) {\n              // on a dessiné un arc jusqu'au bord droit mais il reste un triangle à faire\n              const t2 = polygone(I, P, point(longueurEnclos, cabA.y))\n              t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t2.opaciteDeRemplissage = 0.4\n              t2.couleurDesHachures = colorToLatexOrHTML('black')\n              t2.hachures = 'north east lines'\n              t2.opacite = 0.2\n              objetsCorrection.push(t2)\n            }\n            // **********************************************\n            // On s'occupe de la partie à droite de la cabane\n            const c2 = cercle(cabA, longueurRestanteDroite)\n            const SDroit = pointIntersectionLC(\n              droite(cabA, cabB),\n              c2,\n              '',\n              1,\n            ) as Point\n            let TDroit: Point\n            let a2: Arc\n\n            if (!isTouchCDByRight) {\n              // On ne touche pas le haut, on peut tracer un arc jusqu'à la veticale du bord droit de la cabane\n              TDroit = cabB // C'est juste pour éviter de faire des tests de nullité, il ne sera pas utilisé si on ne touche pas le haut\n              if (P.x + longueurCordelette <= longueurEnclos) {\n                const extremiteDroite = point(P.x + longueurCordelette, cabA.y)\n                a2 = arc(\n                  extremiteDroite,\n                  cabA,\n                  angleOriente(extremiteDroite, cabA, SDroit),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n              } else {\n                let T = pointIntersectionLC(BC, c2, '', 1) as Point\n                if (T.y > largeurEnclos) T = C // ça ne devrait pas arriver vu qu'on n'est pas censé toucher le bord haut\n                const t2 = polygone(point(longueurEnclos, cabA.y), cabA, T)\n                t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t2.opaciteDeRemplissage = 0.3\n                t2.couleurDesHachures = colorToLatexOrHTML('black')\n                t2.hachures = 'north east lines'\n                t2.opacite = 0.2\n                objetsCorrection.push(t2)\n                const r1 = afficheCoteSegment(\n                  segment(cabA, pointAbstrait(longueurEnclos, cabA.y)),\n                  `${longueurEnclos - cabA.x}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  -0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                const r2 = afficheCoteSegment(\n                  segment(cabA, T),\n                  `${longueurRestanteDroite}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  -0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                a2 = arc(\n                  T,\n                  cabA,\n                  angleOriente(T, cabA, SDroit),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                if (longueurRestanteHautDroite > 0) {\n                  const r3 = afficheCoteSegment(\n                    segment(\n                      cabB,\n                      pointAbstrait(\n                        cabB.x,\n                        cabC.y + longueurRestanteHautDroite,\n                      ),\n                    ),\n                    `${longueurRestanteHautDroite}\\\\,\\\\text{m}`,\n                    0,\n                    'black',\n                    0.5,\n                    -0.7,\n                    context.isHtml ? 'gray' : 'darkgray',\n                    true,\n                  )\n                  objetsCorrection.push(r3)\n                }\n                objetsCorrection.push(r1, r2)\n              }\n              a2.couleurDesHachures = colorToLatexOrHTML('black')\n              a2.hachures = 'north east lines'\n              a2.opacite = 0.2\n\n              objetsCorrection.push(a2)\n            } else {\n              // Là on va toucher en haut on doit donc s'arrêter avant de depasser le bord haut de l'enclos\n              const U = pointIntersectionLC(CD, c2, '', 2) as Point\n              TDroit = point(cabA.x, largeurEnclos)\n              const r1 = afficheCoteSegment(\n                segment(cabA, pointAbstrait(longueurEnclos, cabA.y)),\n                `${longueurEnclos - cabA.x}\\\\,\\\\text{m}`,\n                0,\n                'black',\n                0.5,\n                -0.5,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              if (U.x - longueurEnclos >= 0) {\n                // le contact a lieu à droite de l'enclos on doit donc tracer un trapèze\n                const t3 = polygone(\n                  cabA,\n                  point(longueurEnclos, cabA.y),\n                  C,\n                  TDroit,\n                )\n                t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t3.opaciteDeRemplissage = 0.3\n                t3.couleurDesHachures = colorToLatexOrHTML('black')\n                t3.hachures = 'north east lines'\n                t3.opacite = 0.2\n                objetsCorrection.push(t3)\n              } else {\n                // contact haut et droite, le coin C est inaccessible on trace un arc entre 2 triangles\n                if (P.x + longueurCordelette > longueurEnclos) {\n                  let T = pointIntersectionLC(BC, c2, '', 1) as Point\n                  if (T.y > largeurEnclos) T = C // ça ne devrait pas arriver\n                  const t3 = polygone(cabA, point(longueurEnclos, cabA.y), T)\n                  const t4 = polygone(cabA, U, TDroit)\n                  a2 = arc(\n                    T,\n                    cabA,\n                    angleOriente(T, cabA, U),\n                    true,\n                    'pink',\n                    'black',\n                    0.3,\n                  )\n                  ;[t3, a2, t4].forEach((obj) => {\n                    obj.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                    obj.opaciteDeRemplissage = 0.3\n                    obj.couleurDesHachures = colorToLatexOrHTML('black')\n                    obj.hachures = 'north east lines'\n                    obj.opacite = 0.2\n                  })\n                  objetsCorrection.push(t3, a2, t4)\n                }\n              }\n              objetsCorrection.push(r1)\n            }\n            // **********************************************\n            // On s'occupe de la partie à gauche de la cabane\n            const c3 = cercle(cabD, longueurRestanteGauche)\n            const SGauche = pointIntersectionLC(\n              droite(cabC, cabD),\n              c3,\n              '',\n              1,\n            ) as Point\n            let TGauche: Point\n            let a3: Arc\n            if (!isTouchCDByLeft) {\n              // On ne touche pas le haut, on peut tracer un arc jusqu'à la veticale du bord gauche de la cabane\n              TGauche = cabD // C'est juste pour éviter de faire des tests de nullité, il ne sera pas utilisé si on ne touche pas le haut\n              if (P.x - longueurCordelette >= 0) {\n                const extremiteGauche = point(P.x - longueurCordelette, cabA.y)\n                a3 = arc(\n                  extremiteGauche,\n                  cabD,\n                  angleOriente(extremiteGauche, cabD, SGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                const r1 = afficheCoteSegment(\n                  segment(cabD, extremiteGauche),\n                  `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                objetsCorrection.push(r1)\n              } else {\n                let T = pointIntersectionLC(DA, c3, '', 1) as Point\n                const r1 = afficheCoteSegment(\n                  segment(cabD, T),\n                  `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  -0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                const r2 = afficheCoteSegment(\n                  segment(\n                    cabC,\n                    pointAbstrait(cabC.x, cabD.y + longueurRestanteGauche),\n                  ),\n                  `${longueurRestanteHautGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                if (T.y > largeurEnclos) T = D // ça ne devrait pas arriver vu qu'on n'est pas censé toucher le bord haut\n                const t2 = polygone(point(0, cabA.y), cabD, T)\n                t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t2.opaciteDeRemplissage = 0.3\n                t2.couleurDesHachures = colorToLatexOrHTML('black')\n                t2.hachures = 'north east lines'\n                t2.opacite = 0.2\n                objetsCorrection.push(t2, r1, r2)\n                a3 = arc(\n                  T,\n                  cabD,\n                  angleOriente(T, cabD, SGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n              }\n              a3.couleurDesHachures = colorToLatexOrHTML('black')\n              a3.hachures = 'north east lines'\n              a3.opacite = 0.2\n\n              objetsCorrection.push(a3)\n            } else {\n              // Là on va toucher en haut on doit donc s'arrêter avant de depasser le bord haut de l'enclos\n              const U = pointIntersectionLC(CD, c3, '', 1) as Point\n              TGauche = point(cabD.x, largeurEnclos)\n              const r2 = afficheCoteSegment(\n                segment(TGauche, cabC),\n                `${largeurEnclos - cabC.y}\\\\,\\\\text{m}`,\n                -0.2,\n                'black',\n                0.5,\n                -0.7,\n                context.isHtml ? 'gray' : 'darkgray',\n                true,\n              )\n              objetsCorrection.push(r2)\n              if (U.x <= 0) {\n                // le contact a lieu à gauche de l'enclos on doit donc tracer un trapèze\n                const t3 = polygone(\n                  cabD,\n                  point(0, cabA.y),\n                  D,\n                  point(cabD.x, largeurEnclos),\n                )\n                t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                t3.opaciteDeRemplissage = 0.3\n                t3.couleurDesHachures = colorToLatexOrHTML('black')\n                t3.hachures = 'north east lines'\n                t3.opacite = 0.2\n                objetsCorrection.push(t3)\n              } else {\n                // contact haut avec le coin inaccessible : on cherche on trace un arc entre 2 triangles\n                let T: Point\n                if (P.x - longueurCordelette <= 0) {\n                  // On touche à gauche\n                  T = pointIntersectionLC(DA, c3, '', 1) as Point\n                  if (T.y > largeurEnclos) T = D // ça ne devrait pas arriver vu qu'on n'est pas censé toucher le bord haut\n                  if (T.y > cabD.y) {\n                    const t3 = polygone(cabD, point(0, cabA.y), T)\n                    t3.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                    t3.opaciteDeRemplissage = 0.3\n                    t3.couleurDesHachures = colorToLatexOrHTML('black')\n                    t3.hachures = 'north east lines'\n                    t3.opacite = 0.2\n                    objetsCorrection.push(t3)\n                  }\n                } else {\n                  // On ne touche pas à gauche}\n                  T = point(cabD.x - longueurRestanteGauche, cabD.y)\n                }\n                const t4 = polygone(cabD, U, TGauche)\n                const r2 = afficheCoteSegment(\n                  segment(cabD, U),\n                  `${longueurRestanteGauche}\\\\,\\\\text{m}`,\n                  0,\n                  'black',\n                  0.5,\n                  0.5,\n                  context.isHtml ? 'gray' : 'darkgray',\n                  true,\n                )\n                a3 = arc(\n                  T,\n                  cabD,\n                  angleOriente(T, cabD, U),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                ;[a3, t4].forEach((obj) => {\n                  obj.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  obj.opaciteDeRemplissage = 0.3\n                  obj.couleurDesHachures = colorToLatexOrHTML('black')\n                  obj.hachures = 'north east lines'\n                  obj.opacite = 0.2\n                })\n                objetsCorrection.push(a3, t4, r2)\n              }\n            }\n            // **********************************************\n            // On s'occupe de la partie au-dessus de la cabane\n            if (\n              longueurRestanteHautDroite <= 0 &&\n              longueurRestanteHautGauche <= 0\n            )\n              break // Il n'y a pas de cordelette au dessus de la cabane\n            const c5 = cercle(cabB, Math.max(longueurRestanteHautDroite, 0))\n            const c6 = cercle(cabC, Math.max(longueurRestanteHautGauche, 0))\n            const contact = pointIntersectionCC(c5, c6, '', 1) as Point | null\n\n            let VGauche: Point | undefined\n            let VDroite: Point | undefined\n            if (isTouchCDByRight) {\n              VDroite = pointIntersectionLC(CD, c5, '', 1) as Point\n            } else {\n              VDroite = SDroit\n            }\n            if (isTouchCDByLeft) {\n              VGauche = pointIntersectionLC(CD, c6, '', 2) as Point\n            } else {\n              VGauche = SGauche\n            }\n\n            if (contact && contact.y < largeurEnclos) {\n              if (contact.y >= cabB.y) {\n                // Point de contact en dessous du bord haut de l'enclos et au dessus de la cabane\n                if (TDroit.y === largeurEnclos && TDroit.x !== VDroite.x) {\n                  const t6 = polygone(cabB, TDroit, VDroite)\n                  t6.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t6.opaciteDeRemplissage = 0.3\n                  t6.couleurDesHachures = colorToLatexOrHTML('black')\n                  t6.hachures = 'north east lines'\n                  t6.opacite = 0.3\n                  objetsCorrection.push(t6)\n                }\n                if (TGauche.y === largeurEnclos && TGauche.x !== VGauche.x) {\n                  const t7 = polygone(cabC, TGauche, VGauche)\n                  t7.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t7.opaciteDeRemplissage = 0.3\n                  t7.couleurDesHachures = colorToLatexOrHTML('black')\n                  t7.hachures = 'north east lines'\n                  t7.opacite = 0.3\n                  objetsCorrection.push(t7)\n                }\n                if (contact.y > cabB.y) {\n                  const t7 = polygone(cabB, cabC, contact)\n                  t7.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                  t7.opaciteDeRemplissage = 0.3\n                  t7.couleurDesHachures = colorToLatexOrHTML('black')\n                  t7.hachures = 'north east lines'\n                  t7.opacite = 0.2\n                  objetsCorrection.push(t7)\n                }\n                const a4 = arc(\n                  contact,\n                  cabB,\n                  angleOriente(contact, cabB, VDroite),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a4.couleurDesHachures = colorToLatexOrHTML('black')\n                a4.hachures = 'north east lines'\n                a4.opacite = 0.3\n                const a5 = arc(\n                  contact,\n                  cabC,\n                  angleOriente(contact, cabC, VGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a5.couleurDesHachures = colorToLatexOrHTML('black')\n                a5.hachures = 'north east lines'\n                a5.opacite = 0.3\n                objetsCorrection.push(a5, a4)\n              }\n            } else if (!contact) {\n              // la cordelette ne permet pas de faire se toucher les deux arcs\n              if (\n                longueurRestanteHautDroite <= 0 &&\n                longueurRestanteHautGauche <= 0\n              )\n                break // Il n'y a pas de cordelette au dessus de la cabane\n              // on trace séparément les deux arcs, parce qu'ils peuvent potentiellement ne pas exister\n              if (longueurRestanteHautDroite > 0) {\n                const finDroite = pointIntersectionLC(\n                  droite(cabB, cabC),\n                  c5,\n                  '',\n                  1,\n                ) as Point\n                const a4 = arc(\n                  VDroite,\n                  cabB,\n                  angleOriente(VDroite, cabB, finDroite),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a4.couleurDesHachures = colorToLatexOrHTML('black')\n                a4.hachures = 'north east lines'\n                a4.opacite = 0.2\n                const a6 = polygone(cabB, VDroite, point(cabB.x, largeurEnclos))\n                a6.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                a6.opaciteDeRemplissage = 0.3\n                a6.couleurDesHachures = colorToLatexOrHTML('black')\n                a6.hachures = 'north east lines'\n                a6.opacite = 0.3\n                objetsCorrection.push(a4, a6)\n              }\n              if (longueurRestanteHautGauche > 0) {\n                const finGauche = pointIntersectionLC(\n                  droite(cabB, cabC),\n                  c6,\n                  '',\n                  2,\n                ) as Point\n                const a5 = arc(\n                  VGauche,\n                  cabC,\n                  angleOriente(VGauche, cabC, finGauche),\n                  true,\n                  'pink',\n                  'black',\n                  0.3,\n                )\n                a5.couleurDesHachures = colorToLatexOrHTML('black')\n                a5.hachures = 'north east lines'\n                a5.opacite = 0.2\n                const a7 = polygone(cabC, VGauche, point(cabC.x, largeurEnclos))\n                a7.couleurDeRemplissage = colorToLatexOrHTML('pink')\n                a7.opaciteDeRemplissage = 0.3\n                a7.couleurDesHachures = colorToLatexOrHTML('black')\n                a7.hachures = 'north east lines'\n                a7.opacite = 0.3\n                objetsCorrection.push(a5, a7)\n              }\n            } else {\n              // On trace un rectangle car les deux arcs se croisent au dessus de l'enclos\n              const t8 = polygone(\n                cabB,\n                pointAbstrait(cabB.x, largeurEnclos),\n                pointAbstrait(cabC.x, largeurEnclos),\n                cabC,\n              )\n              t8.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t8.opaciteDeRemplissage = 0.2\n              t8.couleurDesHachures = colorToLatexOrHTML('black')\n              t8.hachures = 'north east lines'\n              t8.opacite = 0.2\n              objetsCorrection.push(t8)\n            }\n          }\n          break\n        case 1:\n        default:\n          /*********************************/\n          // cabane en haut à droite\n          /*********************************/\n          {\n            // éléments communs énoncé et correction\n            cabA = point(longueurEnclos, largeurEnclos - largeurCabane)\n            cabB = C\n            cabC = point(longueurEnclos - longueurCabane, largeurEnclos)\n            cabD = point(\n              longueurEnclos - longueurCabane,\n              largeurEnclos - largeurCabane,\n            )\n            P = point(\n              longueurEnclos - offsetPointP,\n              largeurEnclos - largeurCabane,\n              'P',\n              'above',\n            )\n\n            // éléments correction\n            const c1 = cercle(P, longueurCordelette)\n            const I = pointIntersectionLC(droite(B, C), c1, '', 2) as Point\n            const r1Mes = placeLatexSurSegment(\n              `${longueurCordelette}\\\\text{ m}`,\n              P,\n              I,\n              { distance: -0.7, horizontal: true, letterSize: 'normalsize' },\n            )\n            const J = homothetie(\n              P,\n              cabA,\n              (offsetPointP + longueurCordelette) / offsetPointP,\n            )\n            const t1 = polygone(I, cabA, P)\n            t1.couleurDeRemplissage = colorToLatexOrHTML('pink')\n            t1.opaciteDeRemplissage = 0.4\n            t1.couleurDesHachures = colorToLatexOrHTML('black')\n            t1.hachures = 'north east lines'\n            const a1 = arc(\n              I,\n              P,\n              -Math.abs(angleOriente(I, P, J)),\n              true,\n              'pink',\n              'black',\n              0.4,\n            )\n            a1.couleurDesHachures = colorToLatexOrHTML('black')\n            a1.hachures = 'north east lines'\n\n            const diff = afficheCoteSegment(\n              segment(P, cabD),\n              `${longueurCabane - offsetPointP}\\\\,\\\\text{m}`,\n              0.5,\n              'black',\n              1,\n              0.5,\n              'black',\n            )\n            const longRestante =\n              longueurCordelette - (longueurCabane - offsetPointP)\n            if (longRestante < largeurCabane) {\n              const quartDeC2 = arc(J, cabD, -90, true, 'pink', 'black', 0.2)\n              quartDeC2.hachures = 'north east lines'\n              quartDeC2.couleurDesHachures = colorToLatexOrHTML('black')\n              quartDeC2.opacite = 0.2\n              const r2 = placeLatexSurSegment(\n                `${longRestante}\\\\,\\\\text{m}`,\n                cabD,\n                rotation(J, cabD, -90),\n                { distance: 0.7, horizontal: true, letterSize: 'normalsize' },\n              )\n              objetsCorrection.push(quartDeC2, r2, diff)\n            } else {\n              const c2 = cercle(cabD, longRestante)\n              const K = pointIntersectionLC(droite(C, D), c2, '', 1) as Point\n              const a2 = arc(\n                J,\n                cabD,\n                -Math.abs(angleOriente(J, cabD, K)),\n                true,\n                'pink',\n                'black',\n                0.2,\n              )\n              a2.couleurDesHachures = colorToLatexOrHTML('black')\n              a2.hachures = 'north east lines'\n              const t2 = polygone(cabD, cabC, K)\n              t2.couleurDeRemplissage = colorToLatexOrHTML('pink')\n              t2.opaciteDeRemplissage = 0.2\n              t2.couleurDesHachures = colorToLatexOrHTML('black')\n              t2.hachures = 'north east lines'\n              const r2 = placeLatexSurSegment(\n                `${longRestante}\\\\,\\\\text{m}`,\n                cabD,\n                K,\n                { distance: 0.7, horizontal: true, letterSize: 'normalsize' },\n              )\n              t2.opacite = 0.2\n              a2.opacite = 0.2\n              objetsCorrection.push(a2, t2, r2, diff)\n            }\n            a1.opacite = 0.2\n            t1.opacite = 0.2\n            objetsCorrection.push(a1, r1Mes, t1)\n          }\n          break\n      }\n      // objets communs à tous les types de questions\n      const indicEnclos = new BoiteBuilder({\n        xMin: 1,\n        xMax: 4,\n        yMin: largeurEnclos,\n        yMax: largeurEnclos + 1.2,\n      })\n      indicEnclos.addColor({\n        colorBackground: 'darkgray',\n        color: 'black',\n        opacity: 1,\n        backgroudOpacity: 0.2,\n      })\n      indicEnclos.addTextIn({\n        textIn: 'Enclos',\n        color: 'black',\n        opacity: 0.8,\n        size: 1,\n      })\n      const cabane = polygone(cabA, cabB, cabC, cabD)\n      const indicCabane = new BoiteBuilder({\n        xMin: (cabA.x + cabD.x) / 2 - 1.5,\n        xMax: (cabA.x + cabD.x) / 2 + 1.5,\n        yMin: (cabA.y + cabB.y) / 2 - 0.6,\n        yMax: (cabA.y + cabB.y) / 2 + 0.6,\n      })\n      indicCabane.addTextIn({\n        textIn: 'Cabane',\n        color: 'black',\n        opacity: 0.8,\n        size: 1,\n      })\n      indicCabane.addColor({\n        colorBackground: 'darkgray',\n        color: 'none',\n        opacity: 0,\n        backgroudOpacity: 0.2,\n      })\n      const longCab = afficheCoteSegment(\n        segment(cabC, cabB),\n        `${longueurCabane}\\\\text{ m}`,\n        0.2,\n        'black',\n        0.5,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const largCab = afficheCoteSegment(\n        segment(cabB, cabA),\n        `${largeurCabane}\\\\text{ m}`,\n        0.2,\n        'black',\n        0.5,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const distP = afficheCoteSegment(\n        segment(cabA, P),\n        `${offsetPointP}\\\\text{ m}`,\n        0.2,\n        'black',\n        0.5,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const longEnclos = afficheCoteSegment(\n        segment(B, A),\n        `${longueurEnclos}\\\\text{ m}`,\n        0.2,\n        'black',\n        1,\n        0.7,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const largEnclos = afficheCoteSegment(\n        segment(A, D),\n        `${largeurEnclos}\\\\text{ m}`,\n        0.2,\n        'black',\n        1,\n        1,\n        context.isHtml ? 'gray' : 'darkgray',\n        true,\n      )\n      const ch = pointSurSegment(\n        P,\n        A,\n        longueurCordelette * 0.85,\n        '$\\\\text{chèvre}$',\n        'below left',\n      )\n      const chLablel = texteParPosition(\n        'chèvre',\n        ch.x - 0.6,\n        ch.y - 0.5,\n        0,\n        context.isHtml ? 'gray' : 'darkgray',\n        1,\n        'milieu',\n        false,\n        1,\n      )\n      const longe = cordelette(P, ch)\n      const longCord = texteParPosition(\n        'Corde',\n        (P.x + ch.x) / 2 + 0.5,\n        (P.y + ch.y) / 2 - 0.5,\n        0,\n        context.isHtml ? 'gray' : 'darkgray',\n        1,\n        'milieu',\n      )\n      const PetCh = tracePoint(P, ch)\n      PetCh.style = 'o'\n\n      objetsEnonce.push(\n        tracePoint(A),\n        enclos,\n        cabane,\n        indicCabane.render(),\n        indicEnclos.render(),\n        longCab,\n        largCab,\n        distP,\n        longEnclos,\n        largEnclos,\n        PetCh,\n        labelPoint(P),\n        chLablel,\n        longe,\n        longCord,\n      )\n      objetsCorrection.push(\n        enclos,\n        cabane,\n        indicCabane.render(),\n        indicEnclos.render(),\n        tracePoint(P),\n        labelPoint(P),\n        distP,\n        longCab,\n        largCab,\n      )\n\n      texte +=\n        \"Dans l'enclos rectangulaire représenté ci-dessous, on a attaché une chèvre à un piquet $(P)$ situé sur le mur d'une cabane rectangulaire, elle aussi.<br>\"\n      texte += `La corde qui limite les déplacements de la chèvre mesure $${longueurCordelette}\\\\,\\\\text{m}$.<br>`\n      texte += `${numAlpha(0)} Représenter le schéma de l'enclos en utilisant comme échelle : $1\\\\,\\\\text{cm}$ pour $1\\\\,\\\\text{m}$.<br>`\n      texte += `${numAlpha(1)} Délimiter et hachurer la zone de l'enclos dans laquelle peut brouter la chèvre.<br><br>`\n\n      texte += mathalea2d(\n        Object.assign({ scale: 0.5 }, fixeBordures(objetsEnonce)),\n        objetsEnonce,\n      )\n      texteCorr += mathalea2d(\n        Object.assign({}, fixeBordures(objetsCorrection)),\n        objetsCorrection,\n      )\n      if (\n        this.questionJamaisPosee(\n          i,\n          longueurEnclos,\n          largeurEnclos,\n          longueurCabane,\n          largeurCabane,\n          longueurCordelette,\n          offsetPointP,\n        )\n      ) {\n        this.listeQuestions.push(texte)\n        this.listeCorrections.push(texteCorr)\n        i++\n      }\n      cpt++\n    }\n  }\n}\n"],"names":["titre","interactifReady","dateDePublication","uuid","refs","ProblemeDeLaChevreDansSonEnclos","Exercice","listeTypesDeQuestions","gestionnaireFormulaireTexte","i","cpt","longueurEnclos","randint","largeurEnclos","longueurCabane","largeurCabane","offsetPointP","longueurCordelette","objetsEnonce","objetsCorrection","texte","texteCorr","A","point","B","C","D","AB","droite","BC","CD","DA","cabA","cabB","cabC","cabD","P","enclos","polygone","hSousCabane","afficheCoteSegment","segment","context","I","J","homothetie","c1","cercle","pointIntersectionLC","a1","arc","angleOriente","colorToLatexOrHTML","t1","M","N","a2","t2","r1Mes","longueurRestante1","diff","c2","l1","K","pointIntersectionDD","longueurRestante2","r1","t3","X","rotation","longueur","l2","a3","t4","quartDeC2","Z","r2","quartDeC3","W","r3","pointAbstrait","offsetCabane","longueurRestanteDroite","longueurRestanteGauche","longueurRestanteHautDroite","longueurRestanteHautGauche","isTouchAB","isTouchCDByLeft","isTouchCDByRight","SDroit","TDroit","U","T","obj","extremiteDroite","c3","SGauche","TGauche","extremiteGauche","c5","c6","contact","pointIntersectionCC","VGauche","VDroite","t6","t7","a4","a5","t8","finDroite","a6","finGauche","a7","placeLatexSurSegment","longRestante","indicEnclos","BoiteBuilder","cabane","indicCabane","longCab","largCab","distP","longEnclos","largEnclos","ch","pointSurSegment","chLablel","texteParPosition","longe","cordelette","longCord","PetCh","tracePoint","labelPoint","numAlpha","mathalea2d","fixeBordures"],"mappings":"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"}
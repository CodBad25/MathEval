{"version":3,"file":"courbes-CWIdhhqo.js","sources":["../../src/lib/2d/courbes.ts"],"sourcesContent":["import {\n  colorToLatexOrHTML,\n  fixeBordures,\n  ObjetMathalea2D,\n  xSVG,\n  ySVG,\n} from '../../modules/2dGeneralites'\nimport { context } from '../../modules/context'\nimport { estentier, inferieurouegal } from '../../modules/outils'\nimport type { Spline } from '../mathFonctions/Spline'\nimport { tousDeMemeSigne } from '../outils/nombres'\nimport { arc } from './cercle'\nimport { Point, point, tracePoint } from './points'\nimport {\n  elimineBinomesXYIntermediairesAlignes,\n  motifs,\n  Polygone,\n  polygone,\n  polyline,\n} from './polygones'\nimport { Repere } from './reperes'\nimport { segment } from './segmentsVecteurs'\nimport { texteParPosition } from './textes'\n\nexport class LectureImage extends ObjetMathalea2D {\n  x: number\n  y: number\n  xscale: number\n  yscale: number\n  textAbs: string\n  textOrd: string\n  stringColor: string\n  constructor(\n    x: number,\n    y: number,\n    xscale = 1,\n    yscale = 1,\n    color = 'red',\n    textAbs = '',\n    textOrd = '',\n  ) {\n    super()\n    this.x = x\n    this.y = y\n    this.xscale = xscale\n    this.yscale = yscale\n    // if (textAbs === '') textAbs = x.toString()\n    // if (textOrd === '') textOrd = y.toString()\n    this.textAbs = textAbs\n    this.textOrd = textOrd\n    this.stringColor = color\n  }\n\n  svg(coeff: number) {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(x0, y0)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(X, M, this.stringColor)\n    const Sy = segment(M, Y, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.svg(coeff) +\n      '\\t\\n' +\n      Sy.svg(coeff) +\n      '\\t\\n' +\n      (this.textAbs != null\n        ? texteParPosition(\n            this.textAbs,\n            x0,\n            (-1 * 20) / coeff,\n            0,\n            this.stringColor,\n          ).svg(coeff)\n        : '') +\n      '\\t\\n' +\n      (this.textOrd != null\n        ? texteParPosition(\n            this.textOrd,\n            (-1 * 20) / coeff,\n            y0,\n            0,\n            this.stringColor,\n          ).svg(coeff)\n        : '')\n    )\n  }\n\n  tikz() {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(x0, y0)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(X, M, this.stringColor)\n    const Sy = segment(M, Y, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.tikz() +\n      '\\t\\n' +\n      Sy.tikz() +\n      '\\t\\n' +\n      texteParPosition(\n        this.textAbs,\n        x0,\n        -1 / context.scale,\n        0,\n        this.stringColor,\n      ).tikz() +\n      '\\t\\n' +\n      texteParPosition(\n        this.textOrd,\n        -1 / context.scale,\n        y0,\n        0,\n        this.stringColor,\n      ).tikz()\n    )\n  }\n\n  svgml(coeff: number, amp: number) {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(this.x, this.y)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(X, M, this.stringColor)\n    const Sy = segment(M, Y, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.svgml(coeff, amp) +\n      '\\t\\n' +\n      Sy.svgml(coeff, amp) +\n      '\\t\\n' +\n      texteParPosition(\n        this.textAbs,\n        x0,\n        (-1 * 20) / coeff,\n        0,\n        this.stringColor,\n      ).svg(coeff) +\n      '\\t\\n' +\n      texteParPosition(\n        this.textOrd,\n        (-1 * 20) / coeff,\n        y0,\n        0,\n        this.stringColor,\n      ).svg(coeff)\n    )\n  }\n\n  tikzml(amp: number) {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(this.x, this.y)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(X, M, this.stringColor)\n    const Sy = segment(M, Y, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.tikzml(amp) +\n      '\\t\\n' +\n      Sy.tikzml(amp) +\n      '\\t\\n' +\n      texteParPosition(\n        this.textAbs,\n        x0,\n        -1 / context.scale,\n        0,\n        this.stringColor,\n      ).tikz() +\n      '\\t\\n' +\n      texteParPosition(\n        this.textOrd,\n        -1 / context.scale,\n        y0,\n        0,\n        this.stringColor,\n      ).tikz()\n    )\n  }\n}\n/**\n */\nexport function lectureImage(\n  x: number,\n  y: number,\n  xscale = 1,\n  yscale = 1,\n  color = 'red',\n  textAbs = '',\n  textOrd = '',\n): LectureImage {\n  return new LectureImage(x, y, xscale, yscale, color, textAbs, textOrd)\n}\n\nexport class LectureAntecedent extends ObjetMathalea2D {\n  x: number\n  y: number\n  xscale: number\n  yscale: number\n  textAbs: string\n  textOrd: string\n  stringColor: string\n  constructor(\n    x: number,\n    y: number,\n    xscale: number,\n    yscale: number,\n    color = 'black',\n    textOrd: string,\n    textAbs: string,\n  ) {\n    super()\n    //\n    this.x = x\n    this.y = y\n    this.xscale = xscale\n    this.yscale = yscale\n    // if (textAbs == null) textAbs = this.x.toString().replace('.', ',')\n    // if (textOrd == null) textOrd = this.y.toString().replace('.', ',')\n    this.textAbs = textAbs\n    this.textOrd = textOrd\n    this.stringColor = color\n    this.bordures = [-2, -1.5, x + 2, y > 0 ? y + 1 : 0]\n  }\n\n  svg(coeff: number) {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(x0, y0)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(M, X, this.stringColor)\n    const Sy = segment(Y, M, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.svg(coeff) +\n      '\\t\\n' +\n      Sy.svg(coeff) +\n      '\\t\\n' +\n      (this.textAbs != null\n        ? texteParPosition(\n            this.textAbs,\n            x0,\n            (-1 * 20) / coeff,\n            0,\n            this.stringColor,\n          ).svg(coeff)\n        : '') +\n      '\\t\\n' +\n      (this.textOrd != null\n        ? texteParPosition(\n            this.textOrd,\n            (-1 * 20) / coeff,\n            y0,\n            0,\n            this.stringColor,\n          ).svg(coeff)\n        : '')\n    )\n  }\n\n  tikz() {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(x0, y0)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(M, X, this.stringColor)\n    const Sy = segment(Y, M, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.tikz() +\n      '\\t\\n' +\n      Sy.tikz() +\n      '\\t\\n' +\n      texteParPosition(\n        this.textAbs,\n        x0,\n        -1 / context.scale,\n        0,\n        this.stringColor,\n      ).tikz() +\n      '\\t\\n' +\n      texteParPosition(\n        this.textOrd,\n        -1 / context.scale,\n        y0,\n        0,\n        this.stringColor,\n      ).tikz()\n    )\n  }\n\n  svgml(coeff: number, amp: number) {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(x0, y0)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(M, X, this.stringColor)\n    const Sy = segment(Y, M, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.svgml(coeff, amp) +\n      '\\t\\n' +\n      Sy.svgml(coeff, amp) +\n      '\\t\\n' +\n      texteParPosition(\n        this.textAbs,\n        x0,\n        (-1 * 20) / coeff,\n        0,\n        this.stringColor,\n      ).svg(coeff) +\n      '\\t\\n' +\n      texteParPosition(\n        this.textOrd,\n        (-1 * 20) / coeff,\n        y0,\n        0,\n        this.stringColor,\n      ).svg(coeff)\n    )\n  }\n\n  tikzml(amp: number) {\n    const x0 = this.x / this.xscale\n    const y0 = this.y / this.yscale\n    const M = point(x0, y0)\n    const X = point(x0, 0)\n    const Y = point(0, y0)\n    const Sx = segment(M, X, this.stringColor)\n    const Sy = segment(Y, M, this.stringColor)\n    Sx.styleExtremites = '->'\n    Sy.styleExtremites = '->'\n    Sx.pointilles = 5\n    Sy.pointilles = 5\n    return (\n      '\\t\\n' +\n      Sx.tikzml(amp) +\n      '\\t\\n' +\n      Sy.tikzml(amp) +\n      '\\t\\n' +\n      texteParPosition(\n        this.textAbs,\n        x0,\n        -1 / context.scale,\n        0,\n        this.stringColor,\n      ).tikz() +\n      '\\t\\n' +\n      texteParPosition(\n        this.textOrd,\n        -1 / context.scale,\n        y0,\n        0,\n        this.stringColor,\n      ).tikz()\n    )\n  }\n}\n\nexport function lectureAntecedent(\n  x: number,\n  y: number,\n  xscale: number,\n  yscale: number,\n  color = 'black',\n  textOrd: string,\n  textAbs: string,\n): LectureAntecedent {\n  return new LectureAntecedent(x, y, xscale, yscale, color, textOrd, textAbs)\n}\n\n/**\n * Trace la courbe d'une fonction dans un repère\n * @param {function} f fonction à tracer comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}]  Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.yMin]  Ordonnée minimale du tracé de la courbe\n * @param {number} [parametres.yMax]  Ordonnée maximale du tracé de la courbe\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses du tracé de la fonction est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.xUnite = 1]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.yUnite = 1]  Abscisse maximale du tracé de la courbe\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur du tracé de la courbe. À associer obligatoirement à colorToLatexOrHTML().\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Aout 2022\nexport class Courbe extends ObjetMathalea2D {\n  stringColor: string\n  f?: (x: number) => number\n  usePgfplots: boolean\n  xmin: number\n  xmax: number\n  ymin: number\n  ymax: number\n  samples: number = 100\n  xunite: number\n  yunite: number\n  epaisseur: number\n  fLatex?: string\n  constructor(\n    f: (x: number) => number,\n    {\n      repere,\n      color = 'black',\n      epaisseur = 2,\n      step = false,\n      xMin,\n      xMax,\n      yMin,\n      yMax,\n      xUnite = 1,\n      yUnite = 1,\n      usePgfplots = false,\n      fLatex,\n    }: {\n      repere?: Repere\n      color?: string\n      epaisseur?: number\n      step?: boolean | number\n      xMin?: number\n      xMax?: number\n      yMin?: number\n      yMax?: number\n      xUnite?: number\n      yUnite?: number\n      usePgfplots?: boolean\n      fLatex?: string\n    } = {},\n  ) {\n    super()\n    this.objets = []\n    this.usePgfplots = usePgfplots\n    this.epaisseur = epaisseur\n    this.fLatex = fLatex\n\n    if (repere == null) {\n      window.notify(\n        'Erreur dans Courbe : Il faut préciser le repère dans lequel tracer la courbe',\n        { repere },\n      )\n      repere = new Repere({ xMin: -10, xMax: 10, yMin: -10, yMax: 10 })\n    }\n    const xmin = xMin == null ? (xMin = repere.xMin ?? 0) : xMin\n    const xmax = xMax == null ? (xMax = repere.xMax ?? 0) : xMax\n    const ymin = yMin == null ? (yMin = repere.yMin ?? 0) : yMin\n    const ymax = yMax == null ? (yMax = repere.yMax ?? 0) : yMax\n\n    this.xmin = xmin\n    this.xmax = xmax\n    this.ymin = ymin\n    this.ymax = ymax\n\n    this.bordures = (repere?.bordures ?? [0, 0, 0, 0]) as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n\n    this.stringColor = color\n    let xunite, yunite // Tout en minuscule pour les différencier des paramètres de la fonction\n    xunite = repere.xUnite\n    yunite = repere.yUnite\n\n    if (isNaN(xunite)) {\n      xunite = xUnite\n    }\n\n    if (isNaN(yunite)) {\n      yunite = yUnite\n    }\n\n    this.xunite = xunite\n    this.yunite = yunite\n\n    let points = []\n    let pas: number\n    let p\n    if (!step) {\n      pas = 0.2 / xUnite\n    } else {\n      pas = Number(step)\n    }\n    for (let x = xmin; inferieurouegal(x, xMax ?? 10); x += pas) {\n      if (x > xmax) x = xmax // normalement x<xmax... mais inférieurouegal ne compare qu'à 0.0000001 près, on peut donc avoir xmax+epsilon qui sort de l'intervalle de déf\n      const y = Number(f(x))\n      if (isFinite(y)) {\n        if (f(x) < ymax + 1 && f(x) > ymin - 1) {\n          points.push(point(x * xunite, f(x) * yunite))\n        } else {\n          if (points.length > 1) {\n            p = polyline([...points], color)\n            p.epaisseur = epaisseur\n            this.objets.push(p)\n            points = []\n          }\n        }\n      } else {\n        x += 0.05\n      }\n    }\n    if (points.length > 1) {\n      p = polyline([...points], color)\n      p.epaisseur = epaisseur\n      this.objets.push(p)\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz(axisYMin?: number, axisYMax?: number) {\n    if (this.usePgfplots && this.fLatex) {\n      // Use pgfplots with function expression\n      let colorLatex = colorToLatexOrHTML(this.stringColor)[1] || 'black'\n      // Remove braces from color if present\n      colorLatex = colorLatex.replace(/[{}]/g, '')\n      const domainMin = (this.xmin * this.xunite).toFixed(3)\n      const domainMax = (this.xmax * this.xunite).toFixed(3)\n\n      // Use axis bounds if provided, otherwise use curve's ymin/ymax\n      const yDomainMin = (\n        axisYMin !== undefined ? axisYMin * 20 : this.ymin * this.yunite * 20\n      ).toFixed(3)\n      const yDomainMax = (\n        axisYMax !== undefined ? axisYMax * 20 : this.ymax * this.yunite * 20\n      ).toFixed(3)\n\n      let code = `\\\\addplot[color=${colorLatex},line width=${this.epaisseur / 2}pt,domain=${domainMin}:${domainMax},restrict y to domain=${\n        yDomainMin\n      }:${yDomainMax},samples=${this.samples}] {${this.fLatex}};\\n`\n\n      return code\n    } else {\n      // Legacy behavior: use polylines\n      let code = ''\n      if (this.objets == null) return code\n      for (const objet of this.objets) {\n        code += '\\n\\t' + objet.tikz()\n      }\n      return code\n    }\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.svgml === 'undefined') code += '\\n\\t' + objet.svg(coeff)\n      else code += '\\n\\t' + objet.svgml(coeff, amp)\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.tikzml === 'undefined') code += '\\n\\t' + objet.tikz()\n      else code += '\\n\\t' + objet.tikzml(amp)\n    }\n    return code\n  }\n}\n\n/**\n * Trace la courbe d'une fonction dans un repère\n * @param {function} f Fonction à tracer comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere = {}] Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin = repere.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax = repere.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.yMin = repere.yMin]  Ordonnée minimale du tracé de la courbe\n * @param {number} [parametres.yMax = repere.yMax]  Ordonnée maximale du tracé de la courbe\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses du tracé de la fonction est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.xUnite = 1]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.yUnite = 1]  Abscisse maximale du tracé de la courbe\n * @param {boolean} [parametres.usePgfplots = false] Si true, utilise pgfplots pour la sortie LaTeX au lieu de tracés polylignes\n * @param {string} [parametres.fLatex] Expression LaTeX de la fonction (requis si usePgfplots = true)\n * @example courbe(g, {repere: r})\n * // Trace, en noir avec une épaisseur de 2, la courbe g dans le repère r, tous deux précédemment définis.\n * @example courbe(g, {repere: r, epaisseur: 5, color: 'blue'})\n * // Trace la courbe g dans le repère r, tous deux précédemment définis, en bleu, avec une épaisseur de 5.\n * @example courbe(g, {repere: r, usePgfplots: true, fLatex: 'x^2 - 2*x + 1'})\n * // Trace la courbe g dans le repère r en utilisant pgfplots (sortie LaTeX plus compacte).\n * @author Rémi Angot\n * @return {Courbe}\n */\n// JSDOC Validee par EE Aout 2022\nexport function courbe(\n  f: (x: number) => number,\n  {\n    repere,\n    color = 'black',\n    epaisseur = 2,\n    step = false,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    xUnite = 1,\n    yUnite = 1,\n    usePgfplots = false,\n    fLatex,\n  }: {\n    repere?: Repere\n    color?: string\n    epaisseur?: number\n    step?: boolean | number\n    xMin?: number\n    xMax?: number\n    yMin?: number\n    yMax?: number\n    xUnite?: number\n    yUnite?: number\n    usePgfplots?: boolean\n    fLatex?: string\n  } = {},\n) {\n  return new Courbe(f, {\n    repere,\n    color,\n    epaisseur,\n    step,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    xUnite,\n    yUnite,\n    usePgfplots,\n    fLatex,\n  })\n}\n\n/**\n * Trace l'aire entre la courbe d'une fonction et l'axe des abscisses\n * @param {function} f fonction dont on veut tracer l'aire entre sa courbe et l'axe des abscisses comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}]  Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du contour de l'aire : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du contour de l'aire\n * @param {string} [parametres.couleurDeRemplissage = 'blue']  Couleur de l'intérieur de l'aire : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.opacite = 0.5] Taux d'opacité du remplissage entre 0 et 1\n * @param {number} [parametres.hachures = 0] Style des hachures dans cette aire (entier entre 0 et 10).\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses pour tracer l'aire est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.a = 0]  Abscisse minimale du tracé de la courbe avec a < b\n * @param {number} [parametres.b = 1]  Abscisse maximale du tracé de la courbe avec a < b\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} svgml Sortie, à main levée, au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} tikzml Sortie, à main levée, au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur du contour de l'aire. À associer obligatoirement à colorToLatexOrHTML().\n * @property {string} couleurDeRemplissage Couleur de l'intérieur de l'aire. À associer obligatoirement à colorToLatexOrHTML().\n * @property {number} xUnite Unité des abscisses du repère\n * @property {number} yUnite Unité des ordonnées du repère\n * @property {number} ymin Ordonnée minimale du repère\n * @property {number} ymax Ordonnée maximale du repère\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Juin 2022\nexport class Integrale extends ObjetMathalea2D {\n  constructor(\n    f: (x: number) => number,\n    {\n      repere,\n      color = 'black',\n      couleurDeRemplissage = 'blue',\n      epaisseur = 2,\n      step = false,\n      a = 0,\n      b = 1,\n      opacite = 0.5,\n      hachures = 0,\n    }: {\n      repere?: Repere\n      color?: string\n      epaisseur?: number\n      couleurDeRemplissage?: string\n      step?: boolean | number\n      a?: number\n      b?: number\n      opacite?: number\n      hachures?: number\n    } = {},\n  ) {\n    super()\n    this.objets = []\n    const ymin = repere?.yMin ?? -10\n    const ymax = repere?.yMax ?? 10\n    const xunite = repere?.xUnite ?? 1\n    const yunite = repere?.yUnite ?? 1\n\n    const objets = []\n    const points = []\n    let pas: number\n    if (!step) {\n      pas = 0.2 / xunite\n    } else {\n      pas = Number(step)\n    }\n    for (let x = a; inferieurouegal(x, b); x += pas) {\n      if (x > b) x = b // normalement x<xMax... mais inférieurouegal ne compare qu'à 0.0000001 près, on peut donc avoir xMax+epsilon qui sort de l'intervalle de déf\n      if (isFinite(f(x))) {\n        if (f(x) < ymax + 1 && f(x) > ymin - 1) {\n          points.push(point(x * xunite, f(x) * yunite))\n        } else {\n          window.notify(\n            \"Erreur dans Integrale : Il semble que la fonction ne soit pas continue sur l'intervalle\",\n            {\n              f,\n              a,\n              b,\n            },\n          )\n        }\n      } else {\n        x += 0.05\n      }\n    }\n    points.push(\n      point(b * xunite, f(b) * yunite),\n      point(b * xunite, 0),\n      point(a * xunite, 0),\n    )\n    const p = polygone([...points], color)\n    p.epaisseur = epaisseur\n    p.couleurDeRemplissage = colorToLatexOrHTML(couleurDeRemplissage)\n    p.opaciteDeRemplissage = opacite\n    p.hachures = hachures !== -1 ? motifs(hachures) : false\n    this.bordures = repere?.bordures as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n    objets.push(p)\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.svgml === 'undefined') code += '\\n\\t' + objet.svg(coeff)\n      else code += '\\n\\t' + objet.svgml(coeff, amp)\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.tikzml === 'undefined') code += '\\n\\t' + objet.tikz()\n      else code += '\\n\\t' + objet.tikzml(amp)\n    }\n    return code\n  }\n}\n\n/**\n * Trace l'aire entre la courbe d'une fonction et l'axe des abscisses\n * @param {function} f fonction dont on veut tracer l'aire entre sa courbe et l'axe des abscisses comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}]  Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du contour de l'aire : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du contour de l'aire\n * @param {string} [parametres.couleurDeRemplissage = 'blue']  Couleur de l'intérieur de l'aire : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.opacite = 0.5] Taux d'opacité du remplissage entre 0 et 1\n * @param {number} [parametres.hachures = 0] Style des hachures dans cette aire (entier entre 0 et 10).\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses pour tracer l'aire est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.a = 0]  Abscisse minimale du tracé de la courbe avec a < b\n * @param {number} [parametres.b = 1]  Abscisse maximale du tracé de la courbe avec a < b\n * @example integrale(g, {repere: r})\n * // Trace avec une épaisseur de 2, l'aire entre la courbe de la fonction g et l'axe des abscisses dans le repère r, tous deux précédemment définis.\n * @example integrale(g,  {repere: r, epaisseur: 5, color: 'blue', couleurDeRemplissage: 'red'})\n * // Trace avec une épaisseur de 5, l'aire entre la courbe de la fonction g et l'axe des abscisses dans le repère r, tous deux précédemment définis. L'aire est entourée de bleu et remplie de rouge.\n * @author Rémi Angot\n * @return {Integrale}\n */\n// JSDOC Validee par EE Juin 2022\nexport function integrale(\n  f: (x: number) => number,\n  {\n    repere,\n    color = 'black',\n    couleurDeRemplissage = 'blue',\n    epaisseur = 2,\n    step = false,\n    a = 0,\n    b = 1,\n    opacite = 0.5,\n    hachures = 0,\n  }: {\n    repere?: Repere\n    color?: string\n    epaisseur?: number\n    couleurDeRemplissage?: string\n    step?: boolean | number\n    a?: number\n    b?: number\n    opacite?: number\n    hachures?: number\n  } = {},\n) {\n  return new Integrale(f, {\n    repere,\n    color,\n    couleurDeRemplissage,\n    epaisseur,\n    step,\n    a,\n    b,\n    opacite,\n    hachures,\n  })\n}\n/**\n * Trace l'aire entre la courbe d'une fonction et l'axe des abscisses\n * @param {function} f fonction dont on veut tracer l'aire entre sa courbe et l'axe des abscisses comme par exemple : const f = x => a * x ** 2 + b * x + c\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}]  Repère dans lequel le tracé de la fonction se fait\n * @param {number} [parametres.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.pas = 1]  Pas entre deux abscisses pour tracer l'aire\n * @param {boolean} [parametres.sup = false] Si true, l'aire est arrondie par le haut, sinon par le bas\n * @param {string} [parametres.colorPositif = 'red']  Couleur de l'aire positive\n * @param {string} [parametres.colorNegatif = 'blue']  Couleur de l'aire négative\n * @example integraleComptable(g, {repere: r})\n * // Trace l'aire entre la courbe de la fonction g et l'axe des abscisses dans le repère r, tous deux précédemment définis.\n * @example integraleComptable(g, {repere: r, pas: 0.1, sup: true, colorPositif: 'green', colorNegatif: 'orange'})\n * // Trace l'aire entre la courbe de la fonction g et l'axe des abscisses dans le repère r, tous deux précédemment définis. L'aire est arrondie par le haut, le pas entre deux abscisses est de 0.1, l'aire positive est verte et l'aire négative est orange.\n * @author Jean-Claude Lhote\n */\nexport class IntegraleComptable extends ObjetMathalea2D {\n  aire: { negative: number; positive: number }\n  constructor(\n    f: (x: number) => number,\n    {\n      xMin,\n      xMax,\n      pas = 1,\n      sup = false,\n      colorPositif = 'red',\n      colorNegatif = 'blue',\n    }: {\n      xMin: number\n      xMax: number\n      pas?: number\n      sup?: boolean\n      colorPositif?: string\n      colorNegatif?: string\n    },\n  ) {\n    super()\n    this.objets = []\n    const rectangles: Polygone[] = []\n    const echantillonnage: number[][] = []\n    for (let k = 0; k < (xMax - xMin) / pas; k++) {\n      echantillonnage[k] = []\n      for (let j = 0; j < 5; j++) {\n        const x = xMin + k * pas + (j * pas) / 5\n        if (estentier(f(x) / pas, 0.05)) {\n          echantillonnage[k].push(Math.round(f(x) / pas) * pas)\n        } else {\n          echantillonnage[k].push(\n            sup ? Math.ceil(f(x) / pas) * pas : Math.floor(f(x) / pas) * pas,\n          )\n        }\n      }\n    }\n    for (let k = 0; k < echantillonnage.length - 1; k++) {\n      echantillonnage[k].push(echantillonnage[k + 1][0])\n    }\n    if (estentier(f(xMax) / pas, 0.05)) {\n      echantillonnage[echantillonnage.length - 1].push(\n        Math.round(f(xMax) / pas) * pas,\n      )\n    } else {\n      echantillonnage[echantillonnage.length - 1].push(\n        sup ? Math.ceil(f(xMax) / pas) * pas : Math.floor(f(xMax) / pas) * pas,\n      )\n    }\n\n    for (let k = 0; k < echantillonnage.length; k++) {\n      const xk = xMin + k * pas\n      const yk = sup\n        ? Math.max(...echantillonnage[k])\n        : Math.min(...echantillonnage[k])\n      if (tousDeMemeSigne(echantillonnage[k])) {\n        const p = polygone(\n          [\n            point(xk, 0),\n            point(xk, yk),\n            point(xk + pas, yk),\n            point(xk + pas, 0),\n          ],\n          yk > 0 ? colorPositif : colorNegatif,\n        )\n        p.couleurDeRemplissage = colorToLatexOrHTML(\n          yk > 0 ? colorPositif : colorNegatif,\n        )\n        rectangles.push(p)\n      } else {\n        const couleur = sup ? colorPositif : colorNegatif\n        const p = polygone(\n          [\n            point(xk, 0),\n            point(xk, yk),\n            point(xk + pas, yk),\n            point(xk + pas, 0),\n          ],\n          couleur,\n        )\n        p.couleurDeRemplissage = colorToLatexOrHTML(couleur)\n        rectangles.push(p)\n      }\n    }\n    // On joint les rectangles adjacents de même couleur\n    let color: string[] = []\n    let sommetFinal: Point = point(0, 0)\n    while (rectangles.length > 0) {\n      const sommets = [\n        rectangles[0].listePoints[0],\n        rectangles[0].listePoints[1],\n        rectangles[0].listePoints[2],\n      ]\n      color = rectangles[0].color.slice()\n      const pol = rectangles.shift()\n      if (pol != null) {\n        sommetFinal = pol.listePoints[3]\n      }\n      while (\n        rectangles.length > 0 &&\n        rectangles[0].couleurDeRemplissage[0] === color[0]\n      ) {\n        sommets.push(rectangles[0].listePoints[1], rectangles[0].listePoints[2])\n        const pol = rectangles.shift()\n        if (pol != null) {\n          sommetFinal = pol.listePoints[3]\n        }\n      }\n      // Il n'y a plus de rectangle, on ferme le polygone\n      if (rectangles.length === 0) {\n        sommets.push(sommetFinal)\n        const binomesXY = elimineBinomesXYIntermediairesAlignes(sommets)\n        const p = polygone(binomesXY.map((el) => point(el.x, el.y)))\n        p.color =\n          p.bordures[1] < 0 && p.bordures[3] === 0\n            ? colorToLatexOrHTML(colorNegatif)\n            : colorToLatexOrHTML(colorPositif)\n        p.couleurDeRemplissage = p.color\n        this.objets.push(p)\n        break\n      }\n      // on a encore des rectangles, donc on change de couleur et on ferme le précédent polygone\n      // s'il reste qu'un seul rectangle alors on le pousse dans la liste des objets\n      sommets.push(sommetFinal)\n      const binomesXY = elimineBinomesXYIntermediairesAlignes(sommets)\n      const p = polygone(binomesXY.map((el) => point(el.x, el.y)))\n      p.color =\n        p.bordures[1] < 0 && p.bordures[3] === 0\n          ? colorToLatexOrHTML(colorNegatif)\n          : colorToLatexOrHTML(colorPositif)\n      p.couleurDeRemplissage = p.color\n      this.objets.push(p)\n      if (rectangles.length === 1) {\n        this.objets.push(rectangles[0])\n        rectangles.length = 0\n        break\n      } // sinon on contine en initialisant le nouveau polygone au début de la boucle\n    }\n\n    const { xmin, xmax, ymin, ymax } = fixeBordures(this.objets, {\n      rxmax: 0,\n      rxmin: 0,\n      rymax: 0,\n      rymin: 0,\n    })\n    this.bordures = [xmin, xmax, ymin, ymax] as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n    this.aire = { negative: 0, positive: 0 }\n    for (const objet of this.objets) {\n      if (objet.bordures[1] < 0 && objet.bordures[3] === 0) {\n        this.aire.negative += objet.aire\n      } else {\n        this.aire.positive += objet.aire\n      }\n    }\n  }\n}\nexport class BezierPath extends ObjetMathalea2D {\n  xStart: number\n  yStart: number\n  listeOfTriplets: [number, number][][]\n  constructor({\n    xStart = 0,\n    yStart = 0,\n    listeOfTriplets = [\n      [\n        [1, 1],\n        [-1, -1],\n        [1, 1],\n      ],\n    ] as [number, number][][],\n    color = 'black',\n    epaisseur = 2,\n    opacite = 1,\n  }) {\n    super()\n    this.color = colorToLatexOrHTML(color)\n    this.opacite = opacite\n    this.epaisseur = epaisseur\n    this.xStart = xStart\n    this.yStart = yStart\n    this.listeOfTriplets = listeOfTriplets\n  }\n\n  svg(coeff: number) {\n    //\n    let path = `<path fill=\"none\" stroke=\"${this.color[0]}\" stroke-width=${this.epaisseur} d=\"M${xSVG(this.xStart, coeff)},${ySVG(this.yStart, coeff)} c`\n    for (const triplet of this.listeOfTriplets) {\n      path += `${xSVG(triplet[0][0], coeff)},${ySVG(triplet[0][1], coeff)} ${xSVG(triplet[1][0], coeff)},${ySVG(triplet[1][1], coeff)} ${xSVG(triplet[2][0], coeff)},${ySVG(triplet[2][1], coeff)} `\n    }\n    path += '\" />\\n'\n    return path\n  }\n\n  tikz() {\n    let path = `\\n\\t\\\\draw[color = ${this.color[1]},line width = ${this.epaisseur}, opacity = ${this.opacite}](${this.xStart},${this.yStart})`\n    // Pour tikz, les coordonnées du point initial et final doivent être en coordonnées absolues, seules les points de contrôles peuvent-être en relatif à leur noeud respectif\n    let x0 = this.xStart\n    let y0 = this.yStart\n    for (const triplet of this.listeOfTriplets) {\n      const x3 = x0 + triplet[2][0]\n      const y3 = y0 + triplet[2][1]\n      const dX2X3 = triplet[1][0] - triplet[2][0] // tikz prend comme origine le point final pour calculer les coordonnées relatives du point de contrôle 2 !\n      const dY2Y3 = triplet[1][1] - triplet[2][1]\n      path += ` .. controls +(${triplet[0][0].toFixed(2)},${triplet[0][1].toFixed(2)}) and +(${dX2X3.toFixed(2)},${dY2Y3.toFixed(2)})  .. (${x3.toFixed(2)},${y3.toFixed(2)})\\n`\n      x0 = x3 // Le nouveau point de départ est le point d'arrivée du tronçon précédent !\n      y0 = y3\n    }\n    path += ';\\n'\n    return path\n  }\n}\n\n/**\n * Trace la courbe d'une fonction, précédemment définie comme Spline, dans un repère\n * @param {Spline} f fonction à tracer défine, au préalable, avec splineCatmullRom()\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}] Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin = repere.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax = repere.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.yMin = repere.yMin]  Ordonnée minimale du tracé de la courbe\n * @param {number} [parametres.yMax = repere.yMax]  Ordonnée maximale du tracé de la courbe\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses du tracé de la fonction est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.xUnite = 1]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.yUnite = 1]  Abscisse maximale du tracé de la courbe\n * @param {boolean} [parametres.traceNoeuds = true]  Place (ou non) les points définis dans le paramètre f.\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {string} color Couleur du tracé de la courbe. À associer obligatoirement à colorToLatexOrHTML().\n * @author Jean-Claude Lhote\n * @class\n */\n// JSDOC Validee par EE Juin 2022\nexport class CourbeSpline extends ObjetMathalea2D {\n  constructor(\n    f: Spline,\n    {\n      repere,\n      color = 'black',\n      epaisseur = 2,\n      step = false,\n      xMin,\n      xMax,\n      yMin,\n      yMax,\n      xUnite = 1,\n      yUnite = 1,\n      traceNoeuds = true,\n    }: {\n      repere?: Repere\n      color?: string\n      epaisseur?: number\n      step?: boolean | number\n      xMin?: number\n      xMax?: number\n      yMin?: number\n      yMax?: number\n      xUnite?: number\n      yUnite?: number\n      traceNoeuds?: boolean\n    } = {},\n  ) {\n    super()\n    this.objets = []\n\n    const noeuds = []\n    let points = []\n    let xunite, yunite // Tout en minuscule pour les différencier des paramètres de la fonction\n    xunite = repere?.xUnite ?? 1\n    yunite = repere?.yUnite ?? 1\n    const xmin = xMin == null ? (xMin = repere?.xMin ?? 0) : xMin\n    const xmax = xMax == null ? (xMax = repere?.xMax ?? 0) : xMax\n    const ymin = yMin == null ? (yMin = repere?.yMin ?? 0) : yMin\n    const ymax = yMax == null ? (yMax = repere?.yMax ?? 0) : yMax\n\n    if (isNaN(xunite)) {\n      xunite = xUnite\n    }\n\n    if (isNaN(yunite)) {\n      yunite = yUnite\n    }\n    if (f.x == null || f.y == null) {\n      window.notify(\n        \"On ne peut pas tracer la courbe de cette spline : elle n'a pas de noeuds\",\n        { spline: JSON.stringify(f) },\n      )\n      return\n    }\n    if (traceNoeuds) {\n      for (let i = 0; i < f.x.length; i++) {\n        noeuds[i] = tracePoint(point(f.x[i], f.y[i]), 'black')\n        noeuds[i].taille = 3\n        noeuds[i].style = '+'\n        noeuds[i].epaisseur = 2\n        noeuds[i].opacite = 0.5\n        this.objets.push(noeuds[i])\n      }\n    }\n    let pas: number\n    let p, y\n    if (!step) {\n      pas = 0.2 / xUnite\n    } else {\n      pas = Number(step)\n    }\n    for (let x = xmin; inferieurouegal(x, xmax); x = x + pas) {\n      if (x > xmax) x = xmax // normalement x<xMax... mais inférieurouegal ne compare qu'à 0.0000001 près, on peut donc avoir xMax+epsilon qui sort de l'intervalle de déf\n      y = f.image(x)\n      if (!isNaN(y)) {\n        if (y < ymax + 1 && y > ymin - 1) {\n          points.push(point(x * xunite, y * yunite))\n        } else if (points.length > 0) {\n          p = polyline([...points], color)\n          p.epaisseur = epaisseur\n          p.opacite = 0.7\n          this.objets.push(p)\n          points = []\n        }\n      } else {\n        x += 0.05\n      }\n    }\n    p = polyline([...points], color)\n    p.epaisseur = epaisseur\n    p.opacite = 0.7\n    this.objets.push(p)\n    this.bordures = repere?.bordures as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**\n * Trace la courbe d'une fonction, précédemment définie comme Spline, dans un repère\n * @param {function} f fonction à tracer défine, au préalable, avec splineCatmullRom()\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}] Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin = repere.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax = repere.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number} [parametres.yMin = repere.yMin]  Ordonnée minimale du tracé de la courbe\n * @param {number} [parametres.yMax = repere.yMax]  Ordonnée maximale du tracé de la courbe\n * @param {boolean|number} [parametres.step = false] Si false, le pas entre deux abscisses du tracé de la fonction est 0.2/xUnite. Sinon, ce pas vaut la valeur indiquée.\n * @param {number} [parametres.xUnite = 1]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.yUnite = 1]  Abscisse maximale du tracé de la courbe\n * @param {boolean} [parametres.traceNoeuds = true]  Place (ou non) les points définis dans le paramètre f.\n * @example courbeSpline(g, {repere: r})\n * // Trace, en noir avec une épaisseur de 2, la courbe spline g dans le repère r, tous deux précédemment définis.\n * @example courbeSpline(g, {repere: r, epaisseur: 5, color: 'blue'})\n * // Trace la courbe spline g dans le repère r, tous deux précédemment définis, en bleu, avec une épaisseur de 5.\n * @author Jean-Claude Lhote\n * @return {CourbeSpline}\n */\n// JSDOC Validee par EE Juin 2022\nexport function courbeSpline(\n  f: Spline,\n  {\n    repere,\n    color = 'black',\n    epaisseur = 2,\n    step = false,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    xUnite = 1,\n    yUnite = 1,\n    traceNoeuds = true,\n  }: {\n    repere?: Repere\n    color?: string\n    epaisseur?: number\n    step?: boolean | number\n    xMin?: number\n    xMax?: number\n    yMin?: number\n    yMax?: number\n    xUnite?: number\n    yUnite?: number\n    traceNoeuds?: boolean\n  } = {},\n) {\n  return new CourbeSpline(f, {\n    repere,\n    color,\n    epaisseur,\n    step,\n    xMin,\n    xMax,\n    yMin,\n    yMax,\n    xUnite,\n    yUnite,\n    traceNoeuds,\n  })\n}\n\n/**\n * @see : https://gist.github.com/ericelliott/80905b159e1f3b28634ce0a690682957\n * @private\n */\n// y1: start value\n// y2: end value\n// mu: the current frame of the interpolation,\n//     in a linear range from 0-1.\nconst cosineInterpolate = (y1: number, y2: number, mu: number) => {\n  const mu2 = (1 - Math.cos(mu * Math.PI)) / 2\n  return y1 * (1 - mu2) + y2 * mu2\n}\n\n/**\n * Trace la courbe d'une fonction interpolée, linéaire par parties, dans un repère\n * @param {Array.number[]} tableau Ce tableau de tableaux contient les coordonnées des points à rejoindre comme par exemple : [[-5,2],[-1,-7],[2,5],[3,-1]]\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = { xMin: -1, yMin: 1 }] Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin = repere.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax = repere.xMax]  Abscisse maximale du tracé de la courbe\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @author Rémi Angot\n * @class\n */\n// JSDOC Validee par EE Juin 2022\nexport class CourbeInterpolee extends ObjetMathalea2D {\n  courbes: Courbe[]\n  constructor(\n    tableau: number[][],\n    {\n      color = 'black',\n      epaisseur = 2,\n      repere,\n      xMin,\n      xMax,\n      step = 0.2,\n    }: {\n      color?: string\n      epaisseur?: number\n      repere?: Repere\n      xMin?: number\n      xMax?: number\n      step?: number\n    } = {},\n  ) {\n    super()\n    this.courbes = []\n    const xmin = xMin != null ? xMin : (repere?.xMin ?? -1)\n    const xmax = xMax != null ? xMax : (repere?.xMax ?? 1)\n    for (let i = 0; i < tableau.length - 1; i++) {\n      const x0 = tableau[i][0]\n      const y0 = tableau[i][1]\n      const x1 = tableau[i + 1][0]\n      const y1 = tableau[i + 1][1]\n      const f = (x: number) => cosineInterpolate(y0, y1, (x - x0) / (x1 - x0))\n      let depart, fin\n      xmin > x0 ? (depart = xMin) : (depart = x0)\n      xmax < x1 ? (fin = xMax) : (fin = x1)\n      const c = courbe(f, {\n        repere,\n        xMin: depart,\n        xMax: fin,\n        color,\n        epaisseur,\n        step,\n      })\n      this.courbes.push(c)\n    }\n    const lesY = tableau.map((el) => el[1])\n    const lesX = tableau.map((el) => el[0])\n    this.bordures = [\n      Math.min(...lesX),\n      Math.min(...lesY),\n      Math.max(...lesX),\n      Math.max(...lesY),\n    ]\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.courbes == null) return code\n    for (const objet of this.courbes) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.courbes == null) return code\n    for (const objet of this.courbes) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**\n * Trace la courbe d'une fonction interpolée, linéaire par parties, dans un repère\n * @param {Array.number[]} tableau Ce tableau de tableaux contient les coordonnées des points à rejoindre comme par exemple : [[-5,2],[-1,-7],[2,5],[3,-1]]\n * @param {Object} parametres À saisir entre accolades\n * @param {Repere} [parametres.repere  = {}]  Repère dans lequel le tracé de la fonction se fait\n * @param {string} [parametres.color = 'black']  Couleur du tracé de la courbe : du type 'blue' ou du type '#f15929'\n * @param {number} [parametres.epaisseur = 2]  Epaisseur du tracé de la courbe\n * @param {number} [parametres.xMin = repere.xMin]  Abscisse minimale du tracé de la courbe\n * @param {number} [parametres.xMax = repere.xMax]  Abscisse maximale du tracé de la courbe\n * @param {number|false} [parametres.step] Le step pour le tracé de la courbe\n * @example courbeInterpolee(tab, {repere: r})\n * // Trace, en noir avec une épaisseur de 2, la courbe de la fonction interpolée sur les intervalles définis dans tab, dans le repère r, tous deux précédemment définis.\n * @example courbeInterpolee(tab, {repere: r, epaisseur: 5, color: 'blue'})\n * // Trace la courbe de la fonction interpolée sur les intervalles définis dans tab, dans le repère r, tous deux précédemment définis, en bleu avec une épaisseur de 5.\n * @author Rémi Angot\n * @return {CourbeInterpolee}\n */\n// JSDOC Validee par EE Juin 2022\nexport function courbeInterpolee(\n  tableau: number[][],\n  {\n    color = 'black',\n    epaisseur = 1,\n    repere,\n    xMin = -10,\n    xMax = 10,\n    step = 0.2,\n  }: {\n    color?: string\n    epaisseur?: number\n    repere?: Repere\n    xMin?: number\n    xMax?: number\n    step?: number\n  } = {},\n) {\n  return new CourbeInterpolee(tableau, {\n    color,\n    epaisseur,\n    repere,\n    xMin,\n    xMax,\n    step,\n  })\n}\n\nexport class GraphiqueInterpole extends ObjetMathalea2D {\n  courbes: Courbe[]\n  constructor(\n    tableau: number[][],\n    {\n      color = 'black',\n      epaisseur = 1,\n      repere, // repère par défaut : le laisser...\n      step = 0.2,\n    }: {\n      color?: string\n      epaisseur?: number\n      repere?: Repere\n      step?: number\n    } = {},\n  ) {\n    super()\n    this.courbes = []\n    const xmin = repere?.xMin ?? tableau[0][0]\n    const xmax = repere?.xMax ?? tableau[tableau.length - 1][0]\n    const ymin = repere?.yMin ?? Math.min(...tableau.map((el) => el[0]))\n    const ymax = repere?.yMax ?? Math.max(...tableau.map((el) => el[1]))\n    for (let i = 0; i < tableau.length - 1; i++) {\n      const x0 = tableau[i][0]\n      const y0 = tableau[i][1]\n      const x1 = tableau[i + 1][0]\n      const y1 = tableau[i + 1][1]\n      const f = (x: number) => cosineInterpolate(y0, y1, (x - x0) / (x1 - x0))\n      let depart, fin\n      xmin > x0 ? (depart = xmin) : (depart = x0)\n      xmax < x1 ? (fin = xmax) : (fin = x1)\n      const c = courbe(f, {\n        repere,\n        step,\n        xMin: depart,\n        xMax: fin,\n        color,\n        epaisseur,\n        xUnite: repere?.xUnite ?? 1,\n        yUnite: repere?.yUnite ?? 1,\n        yMin: ymin,\n        yMax: ymax,\n      })\n      this.courbes.push(c)\n    }\n    this.bordures = repere?.bordures as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    for (const objet of this.courbes) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    for (const objet of this.courbes) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/**\n *\n *\n * @author Rémi Angot\n */\nexport function graphiqueInterpole(\n  tableau: number[][],\n  {\n    color = 'black',\n    epaisseur = 1,\n    repere, // repère par défaut : le laisser...\n    step = 0.2,\n  }: {\n    color?: string\n    epaisseur?: number\n    repere?: Repere\n    step?: number\n  } = {},\n) {\n  return new GraphiqueInterpole(tableau, { color, epaisseur, repere, step })\n}\n\nexport function imageInterpolee(tableau: number[][], antecedent: number) {\n  const x0 = tableau[0][0]\n  const y0 = tableau[0][1]\n  const x1 = tableau[1][0]\n  const y1 = tableau[1][1]\n  const f = (x: number) => cosineInterpolate(y0, y1, (x - x0) / (x1 - x0))\n  return f(antecedent)\n}\n\nexport function antecedentInterpole(tableau: number[][], image: number) {\n  const x0 = tableau[0][0]\n  const y0 = tableau[0][1]\n  const x1 = tableau[1][0]\n  const y1 = tableau[1][1]\n  const f = (x: number) => cosineInterpolate(y0, y1, (x - x0) / (x1 - x0))\n  return antecedentParDichotomie(x0, x1, f, image, 0.01)\n}\n\nexport function antecedentParDichotomie(\n  xmin: number,\n  xmax: number,\n  f: (x: number) => number,\n  y: number,\n  precision = 0.01,\n) {\n  // On arrondit à 1E-6 parce que sinon, on passe à côté de valeur qui devraient être nulle mais le sont pas à 1E-15 !\n  const ymax = Number(Math.max(f(xmax), f(xmin)).toFixed(6))\n  const ymin = Number(Math.min(f(xmax), f(xmin)).toFixed(6))\n  if (y > ymax || y < ymin) return false // y n'est pas entre les deux extrêmes, la méthode ne fonctionne pas.\n  let xmoy, ymoy\n  if (xmin > xmax) {\n    xmoy = xmin\n    xmin = xmax\n    xmax = xmoy\n  }\n  xmoy = (xmax + xmin) / 2\n  ymoy = f(xmoy)\n  let cpt = 0\n  while (Math.abs(ymoy - y) > precision && cpt < 1000) {\n    if (f(xmin) < f(xmax)) {\n      if (ymoy > y) {\n        xmax = xmoy\n      } else {\n        xmin = xmoy\n      }\n    } else if (ymoy > y) {\n      xmin = xmoy\n    } else {\n      xmax = xmoy\n    }\n    xmoy = (xmin + xmax) / 2\n    ymoy = f(xmoy)\n    cpt++\n  }\n  if (cpt > 1000) return false\n  return xmoy\n}\n\n/**\n * crée un petit demi-cercle en x,y pour marquer une courbe sur un intervalle ouvert\n * @param {number} x\n * @param {number} y\n * @param {'gauche'|'droite'} sens 'gauche' par défaut\n * @param {number} rayon\n * @param {string} couleur\n * @returns {Arc}\n */\nexport function croche(\n  x: number,\n  y: number,\n  sens = 'gauche',\n  rayon = 0.1,\n  couleur = 'black',\n) {\n  const centre = point(x + (sens === 'gauche' ? -rayon : rayon), y)\n  const dessous = point(x + (sens === 'gauche' ? -rayon : rayon), y - rayon)\n  const dessus = point(x + (sens === 'gauche' ? -rayon : rayon), y + rayon)\n  const croche =\n    sens === 'gauche'\n      ? arc(dessous, centre, dessus)\n      : arc(dessus, centre, dessous)\n  croche.color = colorToLatexOrHTML(couleur)\n  return croche\n}\n"],"names":["LectureImage","ObjetMathalea2D","x","y","xscale","yscale","color","textAbs","textOrd","__publicField","coeff","x0","y0","M","point","X","Y","Sx","segment","Sy","texteParPosition","context","amp","lectureImage","LectureAntecedent","lectureAntecedent","Courbe","f","repere","epaisseur","step","xMin","xMax","yMin","yMax","xUnite","yUnite","usePgfplots","fLatex","Repere","xmin","xmax","ymin","ymax","xunite","yunite","points","pas","p","inferieurouegal","polyline","code","objet","axisYMin","axisYMax","colorLatex","colorToLatexOrHTML","domainMin","domainMax","yDomainMin","yDomainMax","courbe","Integrale","couleurDeRemplissage","a","b","opacite","hachures","polygone","motifs","integrale","IntegraleComptable","sup","colorPositif","colorNegatif","rectangles","echantillonnage","k","j","estentier","xk","yk","tousDeMemeSigne","couleur","sommetFinal","sommets","pol","binomesXY","elimineBinomesXYIntermediairesAlignes","el","fixeBordures","BezierPath","xStart","yStart","listeOfTriplets","path","xSVG","ySVG","triplet","x3","y3","dX2X3","dY2Y3","cosineInterpolate","y1","y2","mu","mu2","CourbeInterpolee","tableau","i","x1","depart","fin","c","lesY","lesX","courbeInterpolee","GraphiqueInterpole","graphiqueInterpole","imageInterpolee","antecedent","antecedentInterpole","image","antecedentParDichotomie","precision","xmoy","ymoy","cpt","croche","sens","rayon","centre","dessous","dessus","arc"],"mappings":"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"}
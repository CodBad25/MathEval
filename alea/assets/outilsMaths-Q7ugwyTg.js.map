{"version":3,"file":"outilsMaths-Q7ugwyTg.js","sources":["../../src/lib/mathFonctions/outilsMaths.ts"],"sourcesContent":["import { randint } from '../../modules/outils'\nimport { ecritureAlgebrique } from '../outils/ecritures'\nimport { matrice } from './Matrice'\nimport { Polynome } from './Polynome'\nimport { miseEnEvidence } from '../outils/embellissements'\nimport engine, { generateCleaner } from '../interactif/comparisonFunctions'\n\n/**\n * delta(true) retourne dans un tableau des valeurs de a, b, c telles que b*b-4*a*c >0\n * delta(false) retourne dans un tableau des valeurs de a, b, c telles que b*b-4*a*c <0\n * @author Jean-Claude Lhote\n */\nexport function choisiDelta(positif) {\n  let d, a, b, c\n  do {\n    a = randint(-5, 5, 0)\n    b = randint(-5, 5, 0)\n    c = randint(-5, 5, 0)\n    d = b * b - 4 * a * c\n  } while (positif ? d <= 0 : d >= 0)\n  return [a, b, c]\n}\n\n/**\n * fonction qui retourne un polynome du second degré correctement écrit.\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @returns {string}\n */\nexport function expTrinome(a, b, c) {\n  let expr = ''\n  if (typeof a === 'number') {\n    switch (a) {\n      case 0:\n        break\n      case -1:\n        expr += '-x^2'\n        break\n      case 1:\n        expr += 'x^2'\n        break\n      default:\n        expr += `${a}x^2`\n        break\n    }\n  } else {\n    expr += `${a}x^2`\n  }\n  if (typeof b === 'number') {\n    switch (b) {\n      case 0:\n        break\n      case -1:\n        expr += '-x'\n        break\n      case 1:\n        expr += '+x'\n        break\n      default:\n        if (a === 0) {\n          expr += `${b}`\n        } else expr += `${ecritureAlgebrique(b)}x`\n        break\n    }\n  } else {\n    if (a === 0) {\n      expr += `${b}x`\n    } else {\n      expr += `+${b}x`\n    }\n  }\n  if (typeof c === 'number') {\n    if (a === 0 && b === 0) {\n      expr += `${c}`\n    } else {\n      if (c !== 0) {\n        expr += `${ecritureAlgebrique(c)}`\n      }\n    }\n  } else {\n    expr += `+${c}`\n  }\n  return expr\n}\n\n/**\n * Une fonction qui retourrne le polynome de Lagrange passant par une liste de points\n * @param {{x:number,y:number}[]} listePoints\n * @return {Polynome}\n */\nexport function interpolationDeLagrange(\n  listePoints: { x: number; y: number }[],\n): Polynome {\n  // tout d'abord vérifier qu'il n'y a pas de doublons en x !\n  const listeOrdonnee = listePoints.sort((el1, el2) => el1.x - el2.x)\n  const setPoints = []\n  for (let i = 1; i < listeOrdonnee.length; i++) {\n    // si deux points qui se suivent dans la liste ordonnée ont des abscisses différentes, alors on peut stocker le plus petit\n    if (listeOrdonnee[i - 1].x !== listeOrdonnee[i].x)\n      setPoints.push(listeOrdonnee[i - 1])\n  }\n  // comme on n'a pas stocké le dernier, on le fait\n  setPoints.push(listeOrdonnee[listeOrdonnee.length - 1])\n  if (setPoints.length < 2)\n    throw Error(\n      \"Pour une interpolation de Lagrange, il faut au moins deux points d'abscisses différentes\",\n    )\n  const n = setPoints.length - 1\n  // On initialise à zéro\n  let result: Polynome = new Polynome({ coeffs: [0] })\n  for (let j = 0; j <= n; j++) {\n    // pour un produit on initialise à 1\n    let prod: number | Polynome = new Polynome({ coeffs: [1] })\n    for (let i = 0; i <= n; i++) {\n      if (j !== i) {\n        const den = setPoints[j].x - setPoints[i].x\n        prod = new Polynome({\n          coeffs: [-setPoints[i].x / den, 1 / den],\n        }).multiply(prod)\n      }\n    }\n    prod = (prod as Polynome).multiply(setPoints[j].y)\n    result = prod.add(result)\n  }\n  return result\n}\n\n/**\n * Fonction qui retourne les coefficients a et b de f(x)=ax²+bx+c à partir des données de x1,x2,f(x1),f(x2) et c.\n *@param {number} x1\n *@param {number} x2\n * @param {number} y1\n * @param {number} y1\n * @param {number} c\n * @return {[[number,number],[number,number]]}\n * @author Jean-Claude Lhote\n */\nexport function resolutionSystemeLineaire2x2(x1, x2, fx1, fx2, c) {\n  const maMatrice = matrice([\n    [x1 ** 2, x1],\n    [x2 ** 2, x2],\n  ])\n  if (maMatrice.determinant() === 0) return [0, 0]\n  const [a, b] = maMatrice\n    .inverse()\n    .multiply([fx1 - c, fx2 - c])\n    .toArray()\n  return [a, b]\n}\n\n/**\n * Fonction qui retourne les coefficients a, b et c de f(x)=ax^3 + bx² + cx + d à partir des données de x1,x2,x3,f(x1),f(x2),f(x3) et d (entiers !)\n * sous forme de fraction irréductible. Si pas de solution (déterminant nul) alors retourne [[0,0],[0,0],[0,0]]\n * @author Jean-Claude Lhote\n */\nexport function resolutionSystemeLineaire3x3(\n  x1: number,\n  x2: number,\n  x3: number,\n  fx1: number,\n  fx2: number,\n  fx3: number,\n  d: number,\n): [Number, Number, number] {\n  const maMatrice = matrice([\n    [x1 ** 3, x1 ** 2, x1],\n    [x2 ** 3, x2 ** 2, x2],\n    [x3 ** 3, x3 ** 2, x3],\n  ])\n  const y1 = fx1 - d\n  const y2 = fx2 - d\n  const y3 = fx3 - d\n  if (maMatrice && maMatrice.determinant() === 0) {\n    return [0, 0, 0]\n  }\n  const [a, b, c] = maMatrice.inverse().multiply([y1, y2, y3]).toArray()\n  return [a, b, c]\n}\n\n/**\n * Une fonction utilisée dans les 3 fonctions qui suivent (suppressionParentheses, regroupeTermesMemeDegre et developpe afin de colorier ou pas les termes\n * @param str\n * @param color\n * @param isColored\n * @return {string|*}\n */\nconst miseEnForme = (str, color, isColored) =>\n  isColored ? miseEnEvidence(str, color) : str\nfunction neg(expr) {\n  if (expr.head !== 'Add') return engine.function('Multiply', [expr, '-1'])\n  return engine.function('Add', expr.ops.map(neg), { canonical: false })\n}\n\n/**\n * Une fonction pour supprimer les parenthèses et aplatir l'expression (un Add avec une série de termes)\n * @param expr\n * @return {*|BoxedExpression}\n */\nfunction flattenAdd(expr) {\n  if (expr.head === 'Negate') {\n    const oppose = neg(expr.op1)\n    const newExpr = engine.function('Add', [oppose], { canonical: false })\n    return newExpr\n  }\n  if (expr.head === 'Subtract') {\n    const oppose = neg(expr.op2)\n    const newExpr = engine.function('Add', [expr.op1, oppose], {\n      canonical: false,\n    })\n    return flattenAdd(newExpr)\n  }\n\n  if (expr.head !== 'Add') return expr\n\n  const ops = []\n  for (let op of expr.ops) {\n    op = flattenAdd(op)\n    if (op.head === 'Add' || op.head === 'Delimiter')\n      ops.push(...op.ops.map(flattenAdd))\n    else ops.push(op)\n  }\n  return engine.function('Add', ops, { canonical: false })\n}\n\n/**\n * Supprime les parenthèses dans une somme du type (5x+3)-(2x^2-3x+4)+(4x+7-3x^3)\n * @param {string} exp\n * @param {{color: boolean}} options\n */\nexport function suppressionParentheses(exp, options) {\n  const couleurs = options.couleurs ?? [\n    'red',\n    'blue',\n    'green',\n    'black',\n    'red',\n    'blue',\n    'green',\n    'black',\n  ]\n  const isColored = options?.isColored\n  const clean = generateCleaner([\n    'parentheses',\n    'espaces',\n    'virgules',\n    'fractions',\n  ])\n  exp = clean(exp)\n  const arbre = engine.parse(exp, { canonical: false })\n  const sp = flattenAdd(flattenAdd(arbre))\n  const parts = sp.ops\n  let expressionFinale = ''\n  for (let index = 0; index < parts.length; index++) {\n    const latex = parts[index].latex.startsWith('-')\n      ? parts[index].latex\n      : index === 0\n        ? parts[index].latex\n        : `+${parts[index].latex}`\n    const hereIsPower = parts[index].getSubexpressions('Power')[0]\n    let deg = 0\n    if (hereIsPower != null) {\n      deg = hereIsPower.op2.value\n    } else {\n      if (parts[index].head === 'Square') {\n        deg = 2\n      } else if (parts[index].head === 'Negate') {\n        if (parts[index].op1.isConstant) {\n          deg = 0\n        } else {\n          deg = 1\n        }\n      } else if (parts[index].isConstant) {\n        deg = 0\n      } else {\n        deg = 1\n      }\n    }\n\n    expressionFinale += miseEnForme(\n      latex,\n      couleurs[Math.max(0, 2 - deg)],\n      isColored,\n    )\n  }\n  return expressionFinale\n}\n\n/**\n * une fonction pour trier les termes d'une somme algébrique selon l'exposant de la puissance\n * @param {string} exp\n */\nexport function regroupeTermesMemeDegre(exp, options) {\n  const couleurs = options.couleurs ?? [\n    'red',\n    'blue',\n    'green',\n    'black',\n    'red',\n    'blue',\n    'green',\n    'black',\n  ]\n  const isColored = options?.isColored\n  const clean = generateCleaner([\n    'parentheses',\n    'espaces',\n    'virgules',\n    'fractions',\n  ])\n  exp = clean(exp)\n  if (exp.length === 0) return ''\n  const arbre = engine.parse(exp, { canonical: false })\n  const parts = flattenAdd(arbre).ops\n  const allTheTerms = []\n  for (let index = 0; index < parts.length; index++) {\n    let deg = 0\n    const terme = parts[index]\n    if (terme.getSubexpressions('Power')[0] != null) {\n      deg = terme.getSubexpressions('Power')[0].op2.numericValue\n    } else if (terme.head === 'Square') {\n      deg = 2\n    } else if (terme.head === 'Negate') {\n      if (terme.op1.isConstant) {\n        deg = 0\n      } else {\n        deg = 1\n      }\n    } else if (terme.isConstant) {\n      deg = 0\n    } else {\n      deg = 1\n    }\n\n    const latex = parts[index].latex.startsWith('-')\n      ? parts[index].latex\n      : index === 0\n        ? parts[index].latex\n        : `+${parts[index].latex}`\n    if (allTheTerms[deg] == null) allTheTerms[deg] = []\n    allTheTerms[deg].push(latex)\n  }\n  const expressionFinale = []\n  for (let i = allTheTerms.length; i > 0; i--) {\n    const listOfTerm = allTheTerms[i - 1]\n    if (listOfTerm != null && listOfTerm.length > 0) {\n      let parcel = ''\n      for (let term of listOfTerm) {\n        if (term.startsWith('+') && parcel === '') term = term.substring(1)\n        parcel += term\n      }\n      expressionFinale.push(\n        `(${miseEnForme(parcel, couleurs[Math.max(0, 2 - (i - 1))], isColored)})`,\n      )\n    }\n  }\n  return expressionFinale.join('+')\n}\n\n/**\n *\n * @param expr\n * @param {{isColored: boolean, colorOffset: number, level: 0|1}} options\n * @return {string}\n */\nexport function developpe(\n  expr: string,\n  options: { isColored: boolean; colorOffset?: number; level?: 0 | 1 | 2 },\n): string {\n  const isColored = options?.isColored\n  const colorOffset = options.colorOffset ?? 0\n  const level = options?.level ?? 0\n  const clean = generateCleaner(['parentheses', 'fractions'])\n  const couleurs = options.isColored ?? [\n    'red',\n    'blue',\n    'green',\n    'black',\n    'red',\n    'blue',\n    'green',\n    'black',\n  ]\n  expr = clean(expr)\n  const arbre = engine.parse(expr)\n  if (!['Square', 'Multiply', 'Power'].includes(arbre.head)) {\n    // On ne développe que les produits où les carrés ici\n    return expr.replaceAll('\\\\frac', '\\\\dfrac')\n  }\n  if (arbre.head === 'Square' || arbre.head === 'Power') {\n    // on est sans doute en présence d'une égalité remarquable ?\n    if (arbre.op2.numericValue !== 2)\n      return expr.replaceAll('\\\\frac', '\\\\dfrac')\n    const interior = arbre.op1\n    const somme = interior.head === 'Add'\n    const terme1 = interior.op1\n    const terme2 = interior.op2\n    const carre1 = terme1.isAlgebraic\n      ? terme1.latex.startsWith('-')\n        ? `\\\\left( ${terme1.latex}\\\\right) ^2`\n        : `${terme1.latex}^2`\n      : `\\\\left( ${terme1.latex}\\\\right) ^2`\n    const carre2 = terme2.isAlgebraic\n      ? terme2.latex.startsWith('-')\n        ? `\\\\left( ${terme2.latex}\\\\right) ^2`\n        : `${terme2.latex}^2`\n      : `\\\\left( ${terme2.latex}\\\\right) ^2`\n    const dbleProd = `2\\\\times ${\n      terme1.isConstant\n        ? terme1.latex.startsWith('-')\n          ? `\\\\left( ${terme1.latex}\\\\right) `\n          : `${terme1.latex}`\n        : `\\\\left( ${terme1.latex}\\\\right) `\n    }\\\\times ${\n      terme2.isConstant\n        ? terme2.latex.startsWith('-')\n          ? `\\\\left( ${terme2.latex}\\\\right) `\n          : `${terme2.latex}`\n        : `${terme2.latex}`\n    }`\n    if (level === 2) {\n      return `${miseEnForme(carre1, couleurs[colorOffset], isColored)}${somme ? '+' : '-'}${miseEnForme(dbleProd, couleurs[colorOffset + 1], isColored)}+${miseEnForme(carre2, couleurs[colorOffset + 2], isColored)}`.replaceAll(\n        '\\\\frac',\n        '\\\\dfrac',\n      )\n    } else {\n      const dp = engine.parse(dbleProd).simplify().latex\n      const c1 = engine.box(['Multiply', terme1, terme1]).evaluate().latex\n      const c2 = engine.box(['Multiply', terme2, terme2]).evaluate().latex\n      return `${miseEnForme(c1, couleurs[colorOffset], isColored)}${somme ? '+' : '-'}${miseEnForme(dp, couleurs[colorOffset + 1], isColored)}+${miseEnForme(c2, couleurs[colorOffset + 2], isColored)}`.replaceAll(\n        '\\\\frac',\n        '\\\\dfrac',\n      )\n    }\n  } else {\n    // Ici c'est un produit classique.\n    const facteur1 = arbre.op1\n    const facteur2 = arbre.op2\n    const terme1 = facteur1.op1\n    const terme2 = facteur1.op2\n    const somme1 = facteur1.head === 'Add'\n    const terme3 = facteur2.op1\n    const terme4 = facteur2.op2\n    const somme2 = facteur2.head === 'Add'\n    const t1 = terme1.latex.startsWith('-')\n      ? `\\\\left( ${terme1.latex}\\\\right) `\n      : terme1.latex\n    const t2 = terme2.latex.startsWith('-')\n      ? `\\\\left( ${terme2.latex}\\\\right) `\n      : terme2.latex\n\n    const t3 = terme3.latex.startsWith('-')\n      ? `\\\\left( ${terme3.latex}\\\\right) `\n      : terme3.latex\n    const t4 = terme4.latex.startsWith('-')\n      ? `\\\\left( ${terme4.latex}\\\\right) `\n      : terme4.latex\n    if (level === 2) {\n      return `${miseEnForme(t1, couleurs[colorOffset], isColored)}\\\\times ${miseEnForme(t3, couleurs[colorOffset], isColored)}\n    ${somme2 ? '+' : '-'}${miseEnForme(t1, couleurs[colorOffset + 1], isColored)}\\\\times ${miseEnForme(t4, couleurs[colorOffset + 1], isColored)}\n    ${somme1 ? '+' : '-'}${miseEnForme(t2, couleurs[colorOffset + 1], isColored)}\\\\times ${miseEnForme(t3, couleurs[colorOffset + 1], isColored)}\n    ${somme1 === somme2 ? '+' : '-'}${miseEnForme(t2, couleurs[colorOffset + 2], isColored)}\\\\times ${miseEnForme(t4, couleurs[colorOffset + 2], isColored)}`.replaceAll(\n        '\\\\frac',\n        '\\\\dfrac',\n      )\n    } else {\n      const prod1 = engine\n        .box(['Multiply', terme1, terme3])\n        .evaluate()\n        .simplify().latex\n      const prod2 = engine\n        .box(['Multiply', terme1, terme4])\n        .evaluate()\n        .simplify().latex\n      const prod3 = engine\n        .box(['Multiply', terme2, terme3])\n        .evaluate()\n        .simplify().latex\n      const prod4 = engine\n        .box(['Multiply', terme2, terme4])\n        .evaluate()\n        .simplify().latex\n      if (level === 1) {\n        const p2 = prod2.startsWith('-') ? `\\\\left( ${prod2}\\\\right)` : prod2\n        const p3 = prod3.startsWith('-') ? `\\\\left( ${prod3}\\\\right)` : prod3\n        const p4 = prod4.startsWith('-') ? `\\\\left( ${prod4}\\\\right)` : prod4\n        return `${miseEnForme(prod1, couleurs[colorOffset], isColored)}\n        ${somme2 ? '+' : '-'}${miseEnForme(p2, couleurs[colorOffset + 1], isColored)}\n        ${somme1 ? '+' : '-'}${miseEnForme(p3, couleurs[colorOffset + 1], isColored)}\n        ${somme1 === somme2 ? '+' : '-'}${miseEnForme(p4, couleurs[colorOffset + 1], isColored)}`.replaceAll(\n          '\\\\frac',\n          '\\\\dfrac',\n        )\n      } else {\n        const p2 = prod2.startsWith('-')\n          ? somme2\n            ? prod2\n            : `+${prod2.substring(1)}`\n          : somme2\n            ? `+${prod2}`\n            : `-${prod2}`\n        const p3 = prod3.startsWith('-')\n          ? somme1\n            ? prod3\n            : `+${prod3.substring(1)}`\n          : somme1\n            ? `+${prod3}`\n            : `-${prod3}`\n        const p4 = prod4.startsWith('-')\n          ? somme1 === somme2\n            ? prod4\n            : `+${prod4.substring(1)}`\n          : somme1 === somme2\n            ? `+${prod4}`\n            : `-${prod4}`\n\n        return `${miseEnForme(prod1, couleurs[colorOffset], isColored)}\n        ${miseEnForme(p2, couleurs[colorOffset + 1], isColored)}\n        ${miseEnForme(p3, couleurs[colorOffset + 2], isColored)}\n        ${miseEnForme(p4, couleurs[colorOffset + 3], isColored)}`.replaceAll(\n          '\\\\frac',\n          '\\\\dfrac',\n        )\n      }\n    }\n  }\n}\n"],"names":["choisiDelta","positif","d","a","b","c","randint","interpolationDeLagrange","listePoints","listeOrdonnee","el1","el2","setPoints","i","n","result","Polynome","j","prod","den","resolutionSystemeLineaire2x2","x1","x2","fx1","fx2","maMatrice","matrice","resolutionSystemeLineaire3x3","x3","fx3","y1","y2","y3","miseEnForme","str","color","isColored","miseEnEvidence","neg","expr","engine","flattenAdd","oppose","newExpr","ops","op","suppressionParentheses","exp","options","couleurs","generateCleaner","arbre","parts","expressionFinale","index","latex","hereIsPower","deg","regroupeTermesMemeDegre","allTheTerms","terme","listOfTerm","parcel","term","developpe","colorOffset","level","clean","interior","somme","terme1","terme2","carre1","carre2","dbleProd","dp","c1","c2","facteur1","facteur2","somme1","terme3","terme4","somme2","t1","t2","t3","t4","prod1","prod2","prod3","prod4","p2","p3","p4"],"mappings":"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"}
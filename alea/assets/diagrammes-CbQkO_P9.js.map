{"version":3,"file":"diagrammes-CbQkO_P9.js","sources":["../../src/lib/2d/diagrammes.ts"],"sourcesContent":["import { max } from 'mathjs'\nimport {\n  colorToLatexOrHTML,\n  fixeBordures,\n  ObjetMathalea2D,\n  Vide2d,\n  vide2d,\n} from '../../modules/2dGeneralites'\nimport { texcolors } from '../format/style'\nimport { combinaisonListes } from '../outils/arrayOutils'\nimport { numberFormat, texNombre } from '../outils/texNombre'\nimport { arc, cercle } from './cercle'\nimport { point, tracePoint } from './points'\nimport type { PointAbstrait } from './points-abstraits'\nimport { carre, motifs, Polygone, polygone, polyline } from './polygones'\nimport { axeY, labelY, pointDansRepere, Repere } from './reperes'\nimport { segment, vecteur } from './segmentsVecteurs'\nimport {\n  latexParPoint,\n  TexteParPoint,\n  texteParPoint,\n  texteParPosition,\n} from './textes'\nimport { rotation, similitude, translation } from './transformations'\n\n/**\n * Trace un graphique cartésien dans un repère\n *\n *\n * @param {array} data\n * @param {object} repere\n * @author Rémi Angot\n */\nexport class TraceGraphiqueCartesien extends ObjetMathalea2D {\n  constructor(\n    data: number[][],\n    repere: Repere,\n    {\n      couleurDesPoints = 'red',\n      couleurDuTrait = 'blue',\n      styleDuTrait = '', // plein par défaut\n      epaisseurDuTrait = 2,\n      styleDesPoints = 'x', // croix par défaut\n      tailleDesPoints = 3,\n    }: {\n      couleurDesPoints?: string\n      couleurDuTrait?: string\n      styleDuTrait?: string\n      epaisseurDuTrait?: number\n      styleDesPoints?: string\n      tailleDesPoints?: number\n    },\n  ) {\n    super()\n    this.objets = []\n    const listePoints: PointAbstrait[] = []\n    for (const [x, y] of data) {\n      const M = pointDansRepere(x, y, repere)\n      listePoints.push(M)\n      const t = tracePoint(M, couleurDesPoints)\n      t.style = styleDesPoints\n      t.taille = tailleDesPoints\n      this.objets.push(t)\n    }\n    const l = polyline(...listePoints)\n    l.epaisseur = epaisseurDuTrait\n    l.color = colorToLatexOrHTML(couleurDuTrait)\n    if (styleDuTrait === 'pointilles') {\n      l.pointilles = 5\n    }\n    this.objets.push(l)\n    this.bordures = repere.bordures as unknown as [\n      number,\n      number,\n      number,\n      number,\n    ]\n  }\n\n  // LES SORTIES TiKZ et SVG\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n\n  svgml(coeff: number, amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.svgml === 'undefined') code += '\\n\\t' + objet.svg(coeff)\n      else code += '\\n\\t' + objet.svgml(coeff, amp)\n    }\n    return code\n  }\n\n  tikzml(amp: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      if (typeof objet.tikzml === 'undefined') code += '\\n\\t' + objet.tikz()\n      else code += '\\n\\t' + objet.tikzml(amp)\n    }\n    return code\n  }\n}\n\nexport function traceGraphiqueCartesien(\n  data: number[][],\n  repere: Repere,\n  {\n    couleurDesPoints = 'red',\n    couleurDuTrait = 'blue',\n    styleDuTrait = '', // plein par défaut\n    epaisseurDuTrait = 2,\n    styleDesPoints = 'x', // croix par défaut\n    tailleDesPoints = 3,\n  }: {\n    couleurDesPoints?: string\n    couleurDuTrait?: string\n    styleDuTrait?: string\n    epaisseurDuTrait?: number\n    styleDesPoints?: string\n    tailleDesPoints?: number\n  },\n) {\n  return new TraceGraphiqueCartesien(data, repere, {\n    couleurDesPoints,\n    couleurDuTrait,\n    styleDuTrait,\n    epaisseurDuTrait,\n    styleDesPoints,\n    tailleDesPoints,\n  })\n}\n\n/**\n * Trace une barre pour un histogramme\n *\n * @param {number} x\n * @param {number} hauteur\n * @param {string} legende\n * @param {number} epaisseur\n * @param {string} couleur\n * @param {number} opaciteDeRemplissage\n * @param {number} angle\n * @author Rémi Angot\n */\nexport class TraceBarre extends ObjetMathalea2D {\n  p: Polygone | Vide2d\n  texte: TexteParPoint\n  constructor(\n    x: number,\n    hauteur: number,\n    legende = '',\n    {\n      epaisseur = 0.6,\n      couleurDeRemplissage = 'blue',\n      color = 'black',\n      opaciteDeRemplissage = 0.3,\n      angle = 66,\n      unite = 1,\n      hachures = false,\n    }: {\n      epaisseur?: number\n      couleurDeRemplissage?: string\n      color?: string\n      opaciteDeRemplissage?: number\n      angle?: number\n      unite?: number\n      hachures?: boolean | string\n    },\n  ) {\n    super()\n    this.p =\n      hauteur === 0\n        ? vide2d(x, 0)\n        : polygone([\n            point(x - epaisseur / 2, 0),\n            point(x - epaisseur / 2, hauteur * unite),\n            point(x + epaisseur / 2, hauteur * unite),\n            point(x + epaisseur / 2, 0),\n          ])\n    if (this.p instanceof Polygone) {\n      this.p.couleurDeRemplissage = colorToLatexOrHTML(couleurDeRemplissage)\n      this.p.opaciteDeRemplissage = opaciteDeRemplissage\n      this.p.color = colorToLatexOrHTML(color)\n      if (hachures) {\n        this.p.hachures = hachures\n      }\n    }\n    let bordures: { xmin: number; ymin: number; xmax: number; ymax: number }\n    this.texte = texteParPosition(\n      legende,\n      x,\n      -0.2,\n      angle,\n      'black',\n      1,\n      'gauche',\n    ) as TexteParPoint\n    if (this.p instanceof Polygone) {\n      bordures = fixeBordures([this.p, this.texte], {\n        rxmin: 0,\n        rxmax: 0,\n        rymin: 0,\n        rymax: 0,\n      })\n    } else {\n      bordures = fixeBordures([this.texte], {\n        rxmin: 0,\n        rxmax: 0,\n        rymin: 0,\n        rymax: 0,\n      })\n    }\n    this.bordures = [bordures.xmin, bordures.ymin, bordures.xmax, bordures.ymax]\n  }\n\n  tikz() {\n    return this.p.tikz() + '\\n' + this.texte.tikz()\n  }\n\n  svg(coeff: number) {\n    return this.p.svg(coeff) + '\\n' + this.texte.svg(coeff)\n  }\n}\n\nexport function traceBarre(\n  x: number,\n  hauteur: number,\n  legende = '',\n  {\n    epaisseur = 0.6,\n    couleurDeRemplissage = 'blue',\n    color = 'black',\n    opaciteDeRemplissage = 0.3,\n    angle = 66,\n    unite = 1,\n    hachures = false,\n  }: {\n    epaisseur?: number\n    couleurDeRemplissage?: string\n    color?: string\n    opaciteDeRemplissage?: number\n    angle?: number\n    unite?: number\n    hachures?: boolean | string\n  },\n) {\n  return new TraceBarre(x, hauteur, legende, {\n    epaisseur,\n    couleurDeRemplissage,\n    color,\n    opaciteDeRemplissage,\n    angle,\n    unite,\n    hachures,\n  })\n}\n\n/**\n * Trace une barre horizontale pour un histogramme\n *\n * @param {number} longueur\n * @param {number} y\n * @param {string} legende\n * @param {number} epaisseur\n * @param {string} couleur\n * @param {number} opaciteDeRemplissage\n * @param {number} angle\n * @author Rémi Angot\n */\nexport class TraceBarreHorizontale extends ObjetMathalea2D {\n  p: Polygone | Vide2d\n  texte: TexteParPoint\n  constructor(\n    longueur: number,\n    y: number,\n    legende = '',\n    {\n      epaisseur = 0.6,\n      couleurDeRemplissage = 'blue',\n      color = 'black',\n      opaciteDeRemplissage = 0.3,\n      unite = 1,\n      angle = 0,\n      hachures = false,\n    }: {\n      epaisseur?: number\n      couleurDeRemplissage?: string\n      color?: string\n      opaciteDeRemplissage?: number\n      unite?: number\n      angle?: number\n      hachures?: boolean\n    },\n  ) {\n    super()\n    this.p =\n      longueur === 0\n        ? vide2d(0, y)\n        : polygone([\n            point(0, y - epaisseur / 2),\n            point(0, y + epaisseur / 2),\n            point(unite * longueur, y + epaisseur / 2),\n            point(unite * longueur, y - epaisseur / 2),\n          ])\n    if (this.p instanceof Polygone) {\n      this.p.couleurDeRemplissage = colorToLatexOrHTML(couleurDeRemplissage)\n      this.p.opaciteDeRemplissage = opaciteDeRemplissage\n      this.p.color = colorToLatexOrHTML(color)\n      if (hachures) {\n        this.p.hachures = hachures\n      }\n    }\n    this.texte = texteParPosition(\n      legende,\n      -0.2,\n      y,\n      angle,\n      'black',\n      1,\n      'gauche',\n    ) as TexteParPoint\n  }\n\n  tikz() {\n    return this.p.tikz() + '\\n' + this.texte.tikz()\n  }\n\n  svg(coeff: number) {\n    return this.p.svg(coeff) + '\\n' + this.texte.svg(coeff)\n  }\n}\n\nexport function traceBarreHorizontale(\n  longueur: number,\n  y: number,\n  legende = '',\n  {\n    epaisseur = 0.6,\n    couleurDeRemplissage = 'blue',\n    color = 'black',\n    opaciteDeRemplissage = 0.3,\n    unite = 1,\n    angle = 0,\n    hachures = false,\n  }: {\n    epaisseur?: number\n    couleurDeRemplissage?: string\n    color?: string\n    opaciteDeRemplissage?: number\n    unite?: number\n    angle?: number\n    hachures?: boolean\n  },\n) {\n  return new TraceBarreHorizontale(longueur, y, legende, {\n    epaisseur,\n    couleurDeRemplissage,\n    color,\n    opaciteDeRemplissage,\n    unite,\n    angle,\n    hachures,\n  })\n}\n\n/** Trace un diagramme en barres\n * @param {number[]} hauteursBarres Tableau des effectifs\n * @param {string[]} etiquettes Tableau des labels pour chaque effectif\n * @param {Object} parametres À saisir entre accolades\n * @param {boolean} [parametres.reperageTraitPointille = false] Présence (ou non) du trait en pointillés, reliant le haut de chaque barre à l'axe des ordonnées\n * @param {string} [parametres.couleurDeRemplissage = 'blue'] Couleur de remplissage de toutes les barres : du type 'blue' ou du type '#f15929'.\n * @param {number} [parametres.titreAxeVertical = ''] Titre de l'axe des ordonnées\n * @param {boolean} [parametres.titre = ''] Titre du diagramme\n * @param {boolean} [parametres.hauteurDiagramme = 5] Hauteur du diagramme\n * @param {string[]} [parametres.coeff = 2] Largeur entre deux barres\n * @param {string} [parametres.axeVertical = true] Présence (ou non) de l'axe vertical\n * @param {boolean[]} [parametres.etiquetteValeur = true] Présence (ou non) de l'effectif sur chaque barre\n * @param {boolean[]} [parametres.labelAxeVert = true] Présence (ou non) des labels numériques sur l'axe vertical\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {number[]} bordures Coordonnées de la fenêtre d'affichage du genre [-2,-2,5,5]\n * @class\n */\nexport class DiagrammeBarres extends ObjetMathalea2D {\n  constructor(\n    hauteursBarres: number[],\n    etiquettes: string[],\n    {\n      reperageTraitPointille = false,\n      couleurDeRemplissage = 'blue',\n      titreAxeVertical = '',\n      titre = '',\n      hauteurDiagramme = 5,\n      coeff = 2,\n      axeVertical = false,\n      etiquetteValeur = true,\n      labelAxeVert = false,\n    }: {\n      reperageTraitPointille?: boolean\n      couleurDeRemplissage?: string\n      titreAxeVertical?: string\n      titre?: string\n      hauteurDiagramme?: number\n      coeff?: number\n      axeVertical?: boolean\n      etiquetteValeur?: boolean\n      labelAxeVert?: boolean\n    },\n  ) {\n    super()\n    this.objets = []\n    for (let j = 0; j < hauteursBarres.length; j++) {\n      const abscisseBarre = j * coeff\n      const hauteurBarre =\n        (hauteursBarres[j] * hauteurDiagramme) / max(hauteursBarres)\n      this.objets.push(\n        traceBarre(abscisseBarre, hauteurBarre, etiquettes[j], {\n          couleurDeRemplissage,\n        }),\n      )\n      if (reperageTraitPointille) {\n        const ligne = segment(-1, hauteurBarre, abscisseBarre, hauteurBarre)\n        ligne.pointilles = 5\n        ligne.epaisseur = 0.2\n        this.objets.push(ligne)\n      }\n      if (etiquetteValeur) {\n        if (hauteursBarres[j] !== 0) {\n          this.objets.push(\n            texteParPoint(\n              numberFormat(hauteursBarres[j]),\n              point(abscisseBarre, hauteurBarre + 0.5),\n            ),\n          ) // On écrit la valeur au dessus de la barre sauf pour une hauteur de 0\n        }\n      }\n      // Calculs permettant de graduer l'axe vertical et de placer des valeurs\n      const steps = [1, 2, 5, 10, 20]\n      const yticks = [1, 2, 5, 5, 5]\n      let istep = 1\n      let step = 1\n      let ytick = 1\n      while (max(hauteursBarres) / step > 5 && istep < 5) {\n        istep += 1\n        step = steps[istep - 1]\n        ytick = yticks[istep - 1]\n      }\n      if (istep === 5) istep = 2\n      while (max(hauteursBarres) / step > 5) {\n        istep = istep + 1\n        step = istep * 10\n        ytick = 5\n      }\n\n      if (labelAxeVert)\n        this.objets.push(\n          labelY(\n            0,\n            max(hauteursBarres),\n            (step * hauteurDiagramme) / Math.max(...hauteursBarres),\n            'black',\n            -3,\n            Math.max(...hauteursBarres) / hauteurDiagramme,\n          ),\n        )\n      if (axeVertical)\n        this.objets.push(\n          axeY(\n            0,\n            hauteurDiagramme + 1,\n            0.2,\n            (step * hauteurDiagramme) / Math.max(...hauteursBarres),\n            0.2,\n            'black',\n            ytick,\n            titreAxeVertical,\n          ),\n        )\n    }\n    if (titre !== '')\n      this.objets.push(\n        texteParPoint(\n          titre,\n          point(-3, hauteurDiagramme + 1),\n          0,\n          'black',\n          1,\n          'droite',\n          false,\n          1,\n        ),\n      )\n    this.bordures = [1000, 1000, -1000, -1000]\n    for (const objet of this.objets) {\n      if (objet.bordures !== undefined) {\n        this.bordures = [\n          Math.min(this.bordures[0], objet.bordures[0]),\n          Math.min(this.bordures[1], objet.bordures[1]),\n          Math.max(this.bordures[2], objet.bordures[2]),\n          Math.max(this.bordures[3], objet.bordures[3]),\n        ]\n      }\n    }\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  tikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/** Trace un diagramme en barres\n * @param {number[]} hauteursBarres Tableau des effectifs\n * @param {string[]} etiquettes Tableau des labels pour chaque effectif\n * @param {Object} parametres À saisir entre accolades\n * @param {boolean} [parametres.reperageTraitPointille = false] Présence (ou non) du trait en pointillés, reliant le haut de chaque barre à l'axe des ordonnées\n * @param {string} [parametres.couleurDeRemplissage = 'blue'] Couleur de remplissage de toutes les barres : du type 'blue' ou du type '#f15929'.\n * @param {number} [parametres.titreAxeVertical = ''] Titre de l'axe des ordonnées\n * @param {boolean} [parametres.titre = ''] Titre du diagramme\n * @param {boolean} [parametres.hauteurDiagramme = 5] Hauteur du diagramme\n * @param {string[]} [parametres.coeff = 2] Largeur entre deux barres\n * @param {string} [parametres.axeVertical = true] Présence (ou non) de l'axe vertical\n * @param {boolean[]} [parametres.etiquetteValeur = true] Présence (ou non) de l'effectif sur chaque barre\n * @param {boolean[]} [parametres.labelAxeVert = true] Présence (ou non) des labels numériques sur l'axe vertical\n * @example diagrammeBarres([15, 25, 30, 10, 20], ['Compas', 'Rapporteur', 'Règle', 'Crayon', 'Gomme'])\n * // Trace un diagramme en barres avec les options par défaut\n * @example diagrammeBarres([15, 25, 30, 10, 20], ['Compas', 'Rapporteur', 'Règle', 'Crayon', 'Gomme'],{\n * reperageTraitPointille: true, couleurDeRemplissage: 'red', titreAxeVertical: 'Nombre de réponses',\n * titre = 'Matériel mathématique dans sa trousse', * hauteurDiagramme: 10, coeff: 3, etiquetteValeur: false }})\n * // Trace un diagramme en barres avec modification de quelques options par défaut\n * @return {DiagrammeBarres}\n */\nexport function diagrammeBarres(\n  hauteursBarres: number[],\n  etiquettes: string[],\n  {\n    reperageTraitPointille = false,\n    couleurDeRemplissage = 'blue',\n    titreAxeVertical = '',\n    titre = '',\n    hauteurDiagramme = 5,\n    coeff = 2,\n    axeVertical = false,\n    etiquetteValeur = true,\n    labelAxeVert = false,\n  } = {},\n) {\n  return new DiagrammeBarres(hauteursBarres, etiquettes, {\n    reperageTraitPointille,\n    couleurDeRemplissage,\n    titreAxeVertical,\n    titre,\n    hauteurDiagramme,\n    coeff,\n    axeVertical,\n    etiquetteValeur,\n    labelAxeVert,\n  })\n}\n\n/** Trace un diagramme circulaire\n * @param {Object} parametres À saisir entre accolades\n * @param {number[]} parametres.effectifs Liste des effectifs à donner impérativement\n * @param {number} [parametres.x = 0] Abscisse du point en bas à gauche\n * @param {number} [parametres.y = 0] Ordonnée du point en bas à gauche\n * @param {number} [parametres.rayon = 4] Rayon du diagramme circulaire\n * @param {boolean} [parametres.semi = false] True pour un semi-circulaire, false pour un circulaire\n * @param {boolean} [parametres.legendeAffichage = true] Présence (ou non) de la légende (ensemble des labels)\n * @param {string[]} [parametres.labels = []] Labels associés aux effectifs respectifs. Tableau de même taille que effectifs.\n * @param {string} [parametres.legendePosition = 'droite'] Position de la légende à choisir parmi : 'droite', 'dessus' ou 'dessous'\n * @param {boolean[]} [parametres.mesures = []] Présence (ou non) de la mesure de chaque secteur. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.visibles = []] Découpe (ou non) du secteur (pour créer des diagrammes à compléter). Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.pourcents = []] Présence (ou non) du pourcentage de l'effectif total associé au secteur. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.valeurs = []] Présence (ou non) de des valeurs de l'effectif. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.hachures = []] Présence (ou non) de hachures dans le secteur associé. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.remplissage = []] Présence (ou non) d'une couleur de remplissage dans le secteur associé. Tableau de même taille que effectifs.\n * @property {string} svg Sortie au format vectoriel (SVG) que l’on peut afficher dans un navigateur\n * @property {string} tikz Sortie au format TikZ que l’on peut utiliser dans un fichier LaTeX\n * @property {number} x Abscisse du point en bas à gauche\n * @property {number} y Ordonnée du point en bas à gauche\n * @property {number[]} bordures Coordonnées de la fenêtre d'affichage du genre [-2,-2,5,5]\n * @class\n */\nexport class DiagrammeCirculaire extends ObjetMathalea2D {\n  x: number\n  y: number\n\n  constructor({\n    effectifs = [],\n    x = 0,\n    y = 0,\n    rayon = 4,\n    labels = [],\n    semi = false,\n    legendeAffichage = true,\n    legendePosition = 'droite',\n    mesures = [],\n    visibles = [],\n    pourcents = [],\n    valeurs = [],\n    hachures = [],\n    remplissage = [],\n  }: {\n    effectifs?: number[]\n    x?: number\n    y?: number\n    rayon?: number\n    labels?: string[]\n    semi?: boolean\n    legendeAffichage?: boolean\n    legendePosition?: string\n    mesures?: boolean[]\n    visibles?: boolean[]\n    pourcents?: boolean[]\n    valeurs?: boolean[]\n    hachures?: boolean[]\n    remplissage?: boolean[]\n  } = {}) {\n    super()\n    this.objets = []\n    const listeHachuresDisponibles = [0, 1, 3, 4, 5, 6, 7, 8, 9, 10]\n    const listeMotifs = combinaisonListes(\n      listeHachuresDisponibles,\n      effectifs.length,\n    )\n    this.bordures = [1000, 1000, -1000, -1000]\n    this.x = x\n    this.y = y\n    const centre = point(this.x + rayon, this.y + (semi ? 0 : rayon))\n    const depart = point(this.x + 2 * rayon, semi ? this.y : this.y + rayon)\n    const contour = semi\n      ? arc(\n          translation(centre, vecteur(rayon, 0)),\n          centre,\n          180,\n          true,\n          'white',\n          'black',\n        )\n      : cercle(centre, rayon, 'black')\n    let positionLegende // On prévoit l'emplacement de la légende si celle-ci est demandée\n    switch (legendePosition) {\n      case 'droite':\n        positionLegende = { x: this.x + 2 * rayon + 1, y: this.y }\n        break\n      case 'dessus':\n        positionLegende = {\n          x: this.x,\n          y: this.y + (semi ? rayon + 1 : 2 * rayon + 1),\n        }\n        break\n      case 'dessous':\n      default:\n        positionLegende = { x: this.x, y: this.y - 1.5 }\n        break\n    }\n    let T = point(positionLegende.x, positionLegende.y)\n    const angleTotal = semi ? 180 : 360\n    const effectifTotal = effectifs.reduce(\n      (somme: number, valeur: number) => somme + valeur,\n      0,\n    )\n    const secteurs = []\n    const legendes = []\n    const etiquettes = []\n    const etiquettes2 = []\n    const etiquettes3 = []\n    let alpha = 0 // alpha est l'angle à partir duquel démarre le secteur\n    let legendeMax = 0\n    for (\n      let i = 0, a, angle, legende, textelegende, hachure;\n      i < effectifs.length;\n      i++\n    ) {\n      // on crée les secteurs\n      angle = (angleTotal * effectifs[i]) / effectifTotal\n      a = arc(rotation(depart, centre, alpha), centre, angle, true)\n      if (hachures[i]) {\n        hachure = motifs(listeMotifs[i])\n        a.hachures = hachure\n        a.couleurDesHachures = colorToLatexOrHTML(texcolors(i + 1))\n        a.couleurDeRemplissage = colorToLatexOrHTML(texcolors(i + 2))\n      } else {\n        hachure = ''\n        a.hachures = ''\n      }\n      a.opaciteDeRemplissage = 0.7\n      if (remplissage[i])\n        a.couleurDeRemplissage = colorToLatexOrHTML(texcolors(i + 1))\n      if (visibles[i]) secteurs.push(a)\n      if (valeurs[i]) {\n        etiquettes.push(\n          latexParPoint(\n            texNombre(effectifs[i]),\n            similitude(depart, centre, alpha + (angle * 3) / 4, 0.8),\n            'black',\n            20,\n            12,\n            'yellow',\n            8,\n          ),\n        )\n      }\n      if (pourcents[i]) {\n        etiquettes2.push(\n          latexParPoint(\n            texNombre((100 * effectifs[i]) / effectifTotal, 0) + '\\\\%',\n            similitude(depart, centre, alpha + angle / 4, 0.8),\n            'black',\n            20,\n            12,\n            'yellow',\n            8,\n          ),\n        )\n      }\n      if (mesures[i]) {\n        etiquettes3.push(\n          latexParPoint(\n            texNombre(angle, 0) + '^\\\\circ',\n            similitude(depart, centre, alpha + angle / 2, 0.6),\n            'black',\n            20,\n            12,\n            'yellow',\n            8,\n          ),\n        )\n      }\n      alpha += angle\n\n      // on crée les légendes\n      switch (legendePosition) {\n        case 'droite':\n          legende = carre(\n            translation(T, vecteur(0, 1.5 * i)),\n            translation(T, vecteur(1, 1.5 * i)),\n            'black',\n          )\n          textelegende = texteParPoint(\n            labels[i],\n            translation(T, vecteur(1.2, i * 1.5 + 0.5)),\n            0,\n            'black',\n            1.5,\n            'gauche',\n            false,\n          )\n          legendeMax = Math.max(legendeMax, labels[i].length * 0.6)\n          break\n        default:\n          legende = carre(T, translation(T, vecteur(1, 0)), 'black')\n          textelegende = texteParPoint(\n            labels[i],\n            translation(T, vecteur(1.2, 0.5)),\n            0,\n            'black',\n            1.5,\n            'gauche',\n            false,\n          )\n          T = translation(T, vecteur(labels[i].length * 0.6 + 1, 0))\n          legendeMax = legendeMax + labels[i].length * 0.6 + 2.2\n          break\n      }\n\n      legende.couleurDeRemplissage = a.couleurDeRemplissage\n      legende.couleurDesHachures = a.couleurDesHachures\n      legende.hachures = hachure\n      legende.opaciteDeRemplissage = 0.7\n      legendes.push(legende, textelegende)\n    }\n    this.objets.push(contour)\n    this.objets.push(...secteurs)\n    if (legendeAffichage) this.objets.push(...legendes)\n    this.objets.push(...etiquettes, ...etiquettes2, ...etiquettes3)\n    // calcul des bordures\n    this.bordures[0] = this.x - 0.5\n    this.bordures[1] =\n      this.y -\n      0.5 -\n      (legendeAffichage ? (legendePosition === 'dessous' ? 2 : 0) : 0)\n    this.bordures[2] =\n      this.x +\n      rayon * 2 +\n      1 +\n      (legendeAffichage\n        ? legendePosition === 'droite'\n          ? legendeMax\n          : Math.max(legendeMax, this.x + rayon * 2 + 1) -\n            (this.x + rayon * 2 + 1)\n        : 0)\n    this.bordures[3] =\n      this.y +\n      (semi ? rayon : rayon * 2) +\n      (legendeAffichage\n        ? legendePosition === 'dessus'\n          ? 2\n          : legendePosition === 'droite'\n            ? Math.max(\n                this.y + (semi ? rayon : rayon * 2),\n                effectifs.length * 1.5,\n              ) -\n              (this.y + (semi ? rayon : rayon * 2))\n            : 0\n        : 0)\n  }\n\n  svg(coeff: number) {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.svg(coeff)\n    }\n    return code\n  }\n\n  ttikz() {\n    let code = ''\n    if (this.objets == null) return code\n    for (const objet of this.objets) {\n      code += '\\n\\t' + objet.tikz()\n    }\n    return code\n  }\n}\n\n/** Trace un diagramme circulaire\n * @param {Object} parametres À saisir entre accolades\n * @param {number[]} parametres.effectifs Liste des effectifs à donner impérativement\n * @param {number} [parametres.x = 0] Abscisse du point en bas à gauche\n * @param {number} [parametres.y = 0] Ordonnée du point en bas à gauche\n * @param {number} [parametres.rayon = 4] Rayon du diagramme circulaire\n * @param {boolean} [parametres.semi = false] True pour un semi-circulaire, false pour un circulaire\n * @param {boolean} [parametres.legendeAffichage = true] Présence (ou non) de la légende (ensemble des labels)\n * @param {string[]} [parametres.labels = []] Labels associés aux effectifs respectifs. Tableau de même taille que effectifs.\n * @param {string} [parametres.legendePosition = 'droite'] Position de la légende à choisir parmi : 'droite', 'dessus' ou 'dessous'\n * @param {boolean[]} [parametres.mesures = []] Présence (ou non) de la mesure de chaque secteur. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.visibles = []] Découpe (ou non) du secteur (pour créer des diagrammes à compléter). Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.pourcents = []] Présence (ou non) du pourcentage de l'effectif total associé au secteur. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.valeurs = []] Présence (ou non) de des valeurs de l'effectif. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.hachures = []] Présence (ou non) de hachures dans le secteur associé. Tableau de même taille que effectifs.\n * @param {boolean[]} [parametres.remplissage = []] Présence (ou non) d'une couleur de remplissage dans le secteur associé. Tableau de même taille que effectifs.\n * @example diagrammeCirculaire({ rayon: 7, semi: false, legendePosition: 'dessous',\n * effectifs: [15, 25, 30, 10, 20],\n * labels: ['Compas', 'Rapporteur', 'Règle', 'Crayon', 'Gomme'],\n * mesures: [true, true, true, false, true],\n * visibles: [true, false, true, true, true],\n * pourcents: [true, true, true, false, true],\n * valeurs: [true, false, true, true, false],\n * hachures: [true, true, true, false, true],\n * remplissage: [false, true, true, true, true] })\n * // Trace un diagramme semi-circulaire de rayon 7 avec différentes options\n * @return {DiagrammeCirculaire}\n */\nexport function diagrammeCirculaire({\n  effectifs,\n  x = 0,\n  y = 0,\n  rayon = 4,\n  labels = [],\n  semi = false,\n  legendeAffichage = true,\n  legendePosition = 'droite',\n  mesures = [],\n  visibles = [],\n  pourcents = [],\n  valeurs = [],\n  hachures = [],\n  remplissage = [],\n}: {\n  effectifs?: number[]\n  x?: number\n  y?: number\n  rayon?: number\n  labels?: string[]\n  semi?: boolean\n  legendeAffichage?: boolean\n  legendePosition?: string\n  mesures?: boolean[]\n  visibles?: boolean[]\n  pourcents?: boolean[]\n  valeurs?: boolean[]\n  hachures?: boolean[]\n  remplissage?: boolean[]\n} = {}) {\n  return new DiagrammeCirculaire({\n    effectifs,\n    x,\n    y,\n    rayon,\n    labels,\n    semi,\n    legendeAffichage,\n    legendePosition,\n    mesures,\n    visibles,\n    pourcents,\n    valeurs,\n    hachures,\n    remplissage,\n  })\n}\n"],"names":["TraceGraphiqueCartesien","ObjetMathalea2D","data","repere","couleurDesPoints","couleurDuTrait","styleDuTrait","epaisseurDuTrait","styleDesPoints","tailleDesPoints","listePoints","x","y","M","pointDansRepere","t","tracePoint","l","polyline","colorToLatexOrHTML","coeff","code","objet","amp","traceGraphiqueCartesien","TraceBarre","hauteur","legende","epaisseur","couleurDeRemplissage","color","opaciteDeRemplissage","angle","unite","hachures","__publicField","vide2d","polygone","point","Polygone","bordures","texteParPosition","fixeBordures","traceBarre","TraceBarreHorizontale","longueur","traceBarreHorizontale","DiagrammeBarres","hauteursBarres","etiquettes","reperageTraitPointille","titreAxeVertical","titre","hauteurDiagramme","axeVertical","etiquetteValeur","labelAxeVert","j","abscisseBarre","hauteurBarre","max","ligne","segment","texteParPoint","numberFormat","steps","yticks","istep","step","ytick","labelY","axeY","diagrammeBarres","DiagrammeCirculaire","effectifs","rayon","labels","semi","legendeAffichage","legendePosition","mesures","visibles","pourcents","valeurs","remplissage","listeMotifs","combinaisonListes","centre","depart","contour","arc","translation","vecteur","cercle","positionLegende","T","angleTotal","effectifTotal","somme","valeur","secteurs","legendes","etiquettes2","etiquettes3","alpha","legendeMax","i","a","textelegende","hachure","rotation","motifs","texcolors","latexParPoint","texNombre","similitude","carre","diagrammeCirculaire"],"mappings":"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"}
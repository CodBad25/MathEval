var ft=Object.defineProperty;var ht=(n,t,s)=>t in n?ft(n,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[t]=s;var P=(n,t,s)=>ht(n,typeof t!="symbol"?t+"":t,s);import{b as pt,d as mt,s as S,e as B,f as rt,i as I,a as O}from"./vitest_utils-CZP3wGXz.js";import{i as gt}from"./vitest_spy-CVeaWOS9.js";import{u as F}from"./chai-DTVZgaf2.js";const q=Symbol.for("matchers-object"),_=Symbol.for("$$jest-matchers-object"),L=Symbol.for("expect-global"),st=Symbol.for("asymmetric-matchers-object");if(!Object.prototype.hasOwnProperty.call(globalThis,q)){const n=new WeakMap,t=Object.create(null),s=[],a=Object.create(null);Object.defineProperty(globalThis,q,{get:()=>n}),Object.defineProperty(globalThis,_,{configurable:!0,get:()=>({state:n.get(globalThis[L]),matchers:t,customEqualityTesters:s})}),Object.defineProperty(globalThis,st,{get:()=>a})}function k(n){return globalThis[q].get(n)}function Bt(n,t){const s=globalThis[q],a=s.get(t)||{};Object.assign(a,n),s.set(t,a)}function ot(){const n=()=>rt(),t=n().green,s=n().red,a=n().inverse,u=n().bold,c=n().dim;function h(e,r="received",i="expected",o={}){const{comment:l="",isDirectExpectCall:f=!1,isNot:m=!1,promise:b="",secondArgument:w="",expectedColor:T=t,receivedColor:C=s,secondArgumentColor:M=t}=o;let x="",E="expect";return!f&&r!==""&&(x+=c(`${E}(`)+C(r),E=")"),b!==""&&(x+=c(`${E}.`)+b,E=""),m&&(x+=`${c(`${E}.`)}not`,E=""),e.includes(".")?E+=e:(x+=c(`${E}.`)+e,E=""),i===""?E+="()":(x+=c(`${E}(`)+T(i),w&&(x+=c(", ")+M(w)),E=")"),l!==""&&(E+=` // ${l}`),E!==""&&(x+=c(E)),x}const p="·",g=e=>e.replace(/\s+$/gm,r=>p.repeat(r.length));return{EXPECTED_COLOR:t,RECEIVED_COLOR:s,INVERTED_COLOR:a,BOLD_WEIGHT:u,DIM_COLOR:c,matcherHint:h,printReceived:e=>s(g(S(e))),printExpected:e=>t(g(S(e)))}}function qt(n){if(!Array.isArray(n))throw new TypeError(`expect.customEqualityTesters: Must be set to an array of Testers. Was given "${pt(n)}"`);globalThis[_].customEqualityTesters.push(...n)}function V(){return globalThis[_].customEqualityTesters}function y(n,t,s,a){return s=s||[],it(n,t,[],[],s,a?at:dt)}function H(n){return!!n&&typeof n=="object"&&"asymmetricMatch"in n&&v("Function",n.asymmetricMatch)}function yt(n,t){const s=H(n),a=H(t);if(!(s&&a)){if(s)return n.asymmetricMatch(t);if(a)return t.asymmetricMatch(n)}}function it(n,t,s,a,u,c){let h=!0;const p=yt(n,t);if(p!==void 0)return p;const g={equals:y};for(let o=0;o<u.length;o++){const l=u[o].call(g,n,t,u);if(l!==void 0)return l}if(n instanceof Error&&t instanceof Error)return n.message===t.message;if(typeof URL=="function"&&n instanceof URL&&t instanceof URL)return n.href===t.href;if(Object.is(n,t))return!0;if(n===null||t===null)return n===t;const d=Object.prototype.toString.call(n);if(d!==Object.prototype.toString.call(t))return!1;switch(d){case"[object Boolean]":case"[object String]":case"[object Number]":return typeof n!=typeof t?!1:typeof n!="object"&&typeof t!="object"?Object.is(n,t):Object.is(n.valueOf(),t.valueOf());case"[object Date]":{const o=+n,l=+t;return o===l||Number.isNaN(o)&&Number.isNaN(l)}case"[object RegExp]":return n.source===t.source&&n.flags===t.flags}if(typeof n!="object"||typeof t!="object")return!1;if(U(n)&&U(t))return n.isEqualNode(t);let $=s.length;for(;$--;){if(s[$]===n)return a[$]===t;if(a[$]===t)return!1}if(s.push(n),a.push(t),d==="[object Array]"&&n.length!==t.length)return!1;const e=Y(n,c);let r,i=e.length;if(Y(t,c).length!==i)return!1;for(;i--;)if(r=e[i],h=c(t,r)&&it(n[r],t[r],s,a,u,c),!h)return!1;return s.pop(),a.pop(),h}function Y(n,t){const s=[];for(const a in n)t(n,a)&&s.push(a);return s.concat(Object.getOwnPropertySymbols(n).filter(a=>Object.getOwnPropertyDescriptor(n,a).enumerable))}function dt(n,t){return at(n,t)&&n[t]!==void 0}function at(n,t){return Object.prototype.hasOwnProperty.call(n,t)}function v(n,t){return Object.prototype.toString.apply(t)===`[object ${n}]`}function U(n){return n!==null&&typeof n=="object"&&"nodeType"in n&&typeof n.nodeType=="number"&&"nodeName"in n&&typeof n.nodeName=="string"&&"isEqualNode"in n&&typeof n.isEqualNode=="function"}const bt="@@__IMMUTABLE_KEYED__@@",Et="@@__IMMUTABLE_SET__@@",ct="@@__IMMUTABLE_ORDERED__@@";function xt(n){return!!(n&&n[bt]&&!n[ct])}function wt(n){return!!(n&&n[Et]&&!n[ct])}const lt=Symbol.iterator;function J(n){return!!(n!=null&&n[lt])}function N(n,t,s=[],a=[],u=[]){if(typeof n!="object"||typeof t!="object"||Array.isArray(n)||Array.isArray(t)||!J(n)||!J(t))return;if(n.constructor!==t.constructor)return!1;let c=a.length;for(;c--;)if(a[c]===n)return u[c]===t;a.push(n),u.push(t);const h=[...s.filter(e=>e!==N),p];function p(e,r){return N(e,r,[...s],[...a],[...u])}if(n.size!==void 0){if(n.size!==t.size)return!1;if(v("Set",n)||wt(n)){let e=!0;for(const r of n)if(!t.has(r)){let i=!1;for(const o of t)y(r,o,h)===!0&&(i=!0);if(i===!1){e=!1;break}}return a.pop(),u.pop(),e}else if(v("Map",n)||xt(n)){let e=!0;for(const r of n)if(!t.has(r[0])||!y(r[1],t.get(r[0]),h)){let i=!1;for(const o of t){const l=y(r[0],o[0],h);let f=!1;l===!0&&(f=y(r[1],o[1],h)),f===!0&&(i=!0)}if(i===!1){e=!1;break}}return a.pop(),u.pop(),e}}const g=t[lt]();for(const e of n){const r=g.next();if(r.done||!y(e,r.value,h))return!1}if(!g.next().done)return!1;const d=Object.entries(n),$=Object.entries(t);return y(d,$)?(a.pop(),u.pop(),!0):!1}function W(n,t){return!n||typeof n!="object"||n===Object.prototype?!1:Object.prototype.hasOwnProperty.call(n,t)||W(Object.getPrototypeOf(n),t)}function $t(n){return I(n)&&!(n instanceof Error)&&!Array.isArray(n)&&!(n instanceof Date)}function A(n,t,s=[]){const a=s.filter(c=>c!==A),u=(c=new WeakMap)=>(h,p)=>{if($t(p))return Object.keys(p).every(g=>{if(p[g]!=null&&typeof p[g]=="object"){if(c.has(p[g]))return y(h[g],p[g],a);c.set(p[g],!0)}const d=h!=null&&W(h,g)&&y(h[g],p[g],[...a,u(c)]);return c.delete(p[g]),d})};return u()(n,t)}function G(n,t){if(!(n==null||t==null||n.constructor===t.constructor))return!1}function z(n,t){let s=n,a=t;if(!(n instanceof DataView&&t instanceof DataView)){if(!(n instanceof ArrayBuffer)||!(t instanceof ArrayBuffer))return;try{s=new DataView(n),a=new DataView(t)}catch{return}}if(s.byteLength!==a.byteLength)return!1;for(let u=0;u<s.byteLength;u++)if(s.getUint8(u)!==a.getUint8(u))return!1;return!0}function D(n,t,s=[]){if(!Array.isArray(n)||!Array.isArray(t))return;const a=Object.keys(n),u=Object.keys(t),c=s.filter(h=>h!==D);return y(n,t,c,!0)&&y(a,u)}function Tt(n,t="#{this}",s="#{exp}"){const a=`expected ${t} to be ${s} // Object.is equality`;return["toStrictEqual","toEqual"].includes(n)?`${a}

If it should pass with deep equality, replace "toBe" with "${n}"

Expected: ${t}
Received: serializes to the same string
`:a}function Nt(n,t){return`${t} ${n}${t===1?"":"s"}`}function R(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n).filter(t=>{var s;return(s=Object.getOwnPropertyDescriptor(n,t))==null?void 0:s.enumerable})]}function vt(n,t,s=[]){let a=0;const u=(c=new WeakMap)=>(h,p)=>{if(Array.isArray(h)){if(Array.isArray(p)&&p.length===h.length)return p.map((g,d)=>u(c)(h[d],g))}else{if(h instanceof Date)return h;if(I(h)&&I(p)){if(y(h,p,[...s,N,A]))return p;const g={};c.set(h,g);for(const d of R(h))W(p,d)?g[d]=c.has(h[d])?c.get(h[d]):u(c)(h[d],p[d]):c.has(h[d])||(a+=1,I(h[d])&&(a+=R(h[d]).length),u(c)(h[d],p[d]));if(R(g).length>0)return g}}return h};return{subset:u()(n,t),stripped:a}}class j{constructor(t,s=!1){P(this,"$$typeof",Symbol.for("jest.asymmetricMatcher"));this.sample=t,this.inverse=s}getMatcherContext(t){return{...k(t||globalThis[L]),equals:y,isNot:this.inverse,customTesters:V(),utils:{...ot(),diff:B,stringify:S,iterableEquality:N,subsetEquality:A}}}[Symbol.for("chai/inspect")](t){const s=S(this,t.depth,{min:!0});return s.length<=t.truncate?s:`${this.toString()}{…}`}}class K extends j{constructor(t,s=!1){if(!v("String",t))throw new Error("Expected is not a string");super(t,s)}asymmetricMatch(t){const s=v("String",t)&&t.includes(this.sample);return this.inverse?!s:s}toString(){return`String${this.inverse?"Not":""}Containing`}getExpectedType(){return"string"}}class Mt extends j{asymmetricMatch(t){return t!=null}toString(){return"Anything"}toAsymmetricMatcher(){return"Anything"}}class X extends j{constructor(t,s=!1){super(t,s)}getPrototype(t){return Object.getPrototypeOf?Object.getPrototypeOf(t):t.constructor.prototype===t?null:t.constructor.prototype}hasProperty(t,s){return t?Object.prototype.hasOwnProperty.call(t,s)?!0:this.hasProperty(this.getPrototype(t),s):!1}asymmetricMatch(t){if(typeof this.sample!="object")throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);let s=!0;const a=this.getMatcherContext();for(const u in this.sample)if(!this.hasProperty(t,u)||!y(this.sample[u],t[u],a.customTesters)){s=!1;break}return this.inverse?!s:s}toString(){return`Object${this.inverse?"Not":""}Containing`}getExpectedType(){return"object"}}class Q extends j{constructor(t,s=!1){super(t,s)}asymmetricMatch(t){if(!Array.isArray(this.sample))throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);const s=this.getMatcherContext(),a=this.sample.length===0||Array.isArray(t)&&this.sample.every(u=>t.some(c=>y(u,c,s.customTesters)));return this.inverse?!a:a}toString(){return`Array${this.inverse?"Not":""}Containing`}getExpectedType(){return"array"}}class Ot extends j{constructor(t){if(typeof t>"u")throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");super(t)}fnNameFor(t){if(t.name)return t.name;const a=Function.prototype.toString.call(t).match(/^(?:async)?\s*function\s*\*?\s*([\w$]+)\s*\(/);return a?a[1]:"<anonymous>"}asymmetricMatch(t){return this.sample===String?typeof t=="string"||t instanceof String:this.sample===Number?typeof t=="number"||t instanceof Number:this.sample===Function?typeof t=="function"||t instanceof Function:this.sample===Boolean?typeof t=="boolean"||t instanceof Boolean:this.sample===BigInt?typeof t=="bigint"||t instanceof BigInt:this.sample===Symbol?typeof t=="symbol"||t instanceof Symbol:this.sample===Object?typeof t=="object":t instanceof this.sample}toString(){return"Any"}getExpectedType(){return this.sample===String?"string":this.sample===Number?"number":this.sample===Function?"function":this.sample===Object?"object":this.sample===Boolean?"boolean":this.fnNameFor(this.sample)}toAsymmetricMatcher(){return`Any<${this.fnNameFor(this.sample)}>`}}class Z extends j{constructor(t,s=!1){if(!v("String",t)&&!v("RegExp",t))throw new Error("Expected is not a String or a RegExp");super(new RegExp(t),s)}asymmetricMatch(t){const s=v("String",t)&&this.sample.test(t);return this.inverse?!s:s}toString(){return`String${this.inverse?"Not":""}Matching`}getExpectedType(){return"string"}}class tt extends j{constructor(s,a=2,u=!1){if(!v("Number",s))throw new Error("Expected is not a Number");if(!v("Number",a))throw new Error("Precision is not a Number");super(s);P(this,"precision");this.inverse=u,this.precision=a}asymmetricMatch(s){if(!v("Number",s))return!1;let a=!1;return s===Number.POSITIVE_INFINITY&&this.sample===Number.POSITIVE_INFINITY||s===Number.NEGATIVE_INFINITY&&this.sample===Number.NEGATIVE_INFINITY?a=!0:a=Math.abs(this.sample-s)<10**-this.precision/2,this.inverse?!a:a}toString(){return`Number${this.inverse?"Not":""}CloseTo`}getExpectedType(){return"number"}toAsymmetricMatcher(){return[this.toString(),this.sample,`(${Nt("digit",this.precision)})`].join(" ")}}const Pt=(n,t)=>{t.addMethod(n.expect,"anything",()=>new Mt),t.addMethod(n.expect,"any",s=>new Ot(s)),t.addMethod(n.expect,"stringContaining",s=>new K(s)),t.addMethod(n.expect,"objectContaining",s=>new X(s)),t.addMethod(n.expect,"arrayContaining",s=>new Q(s)),t.addMethod(n.expect,"stringMatching",s=>new Z(s)),t.addMethod(n.expect,"closeTo",(s,a)=>new tt(s,a)),n.expect.not={stringContaining:s=>new K(s,!0),objectContaining:s=>new X(s,!0),arrayContaining:s=>new Q(s,!0),stringMatching:s=>new Z(s,!0),closeTo:(s,a)=>new tt(s,a,!0)}};function et(n,t){return n&&t instanceof Promise&&(t=t.finally(()=>{const s=n.promises.indexOf(t);s!==-1&&n.promises.splice(s,1)}),n.promises||(n.promises=[]),n.promises.push(t)),t}function ut(n,t){return function(...s){var a;const u=n.flag(this,"vitest-test");if(!(u!=null&&u.context._local?u.context.expect.getState():k(globalThis[L])).soft)return t.apply(this,s);if(!u)throw new Error("expect.soft() can only be used inside a test");try{return t.apply(this,s)}catch(h){u.result||(u.result={state:"fail"}),u.result.state="fail",(a=u.result).errors||(a.errors=[]),u.result.errors.push(mt(h))}}}const Rt=(n,t)=>{const{AssertionError:s}=n,a=()=>rt(),u=V();function c(e,r){const i=o=>{const l=ut(t,r);t.addMethod(n.Assertion.prototype,o,l),t.addMethod(globalThis[_].matchers,o,l)};Array.isArray(e)?e.forEach(o=>i(o)):i(e)}["throw","throws","Throw"].forEach(e=>{t.overwriteMethod(n.Assertion.prototype,e,r=>function(...i){const o=t.flag(this,"promise"),l=t.flag(this,"object"),f=t.flag(this,"negate");if(o==="rejects")t.flag(this,"object",()=>{throw l});else if(o==="resolves"&&typeof l!="function"){if(f)return;{const m=t.flag(this,"message")||"expected promise to throw an error, but it didn't",b={showDiff:!1};throw new s(m,b,t.flag(this,"ssfi"))}}r.apply(this,i)})}),c("withTest",function(e){return t.flag(this,"vitest-test",e),this}),c("toEqual",function(e){const r=t.flag(this,"object"),i=y(r,e,[...u,N]);return this.assert(i,"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",e,r)}),c("toStrictEqual",function(e){const r=t.flag(this,"object"),i=y(r,e,[...u,N,G,D,z],!0);return this.assert(i,"expected #{this} to strictly equal #{exp}","expected #{this} to not strictly equal #{exp}",e,r)}),c("toBe",function(e){const r=this._obj,i=Object.is(r,e);let o="";return i||(y(r,e,[...u,N,G,D,z],!0)?o="toStrictEqual":y(r,e,[...u,N])&&(o="toEqual")),this.assert(i,Tt(o),"expected #{this} not to be #{exp} // Object.is equality",e,r)}),c("toMatchObject",function(e){const r=this._obj,i=y(r,e,[...u,N,A]),o=t.flag(this,"negate"),{subset:l,stripped:f}=vt(r,e);if(i&&o||!i&&!o){const m=t.getMessage(this,[i,"expected #{this} to match object #{exp}","expected #{this} to not match object #{exp}",e,l,!1]),b=f===0?m:`${m}
(${f} matching ${f===1?"property":"properties"} omitted from actual)`;throw new s(b,{showDiff:!0,expected:e,actual:l})}}),c("toMatch",function(e){const r=this._obj;if(typeof r!="string")throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof r}`);return this.assert(typeof e=="string"?r.includes(e):r.match(e),"expected #{this} to match #{exp}","expected #{this} not to match #{exp}",e,r)}),c("toContain",function(e){const r=this._obj;if(typeof Node<"u"&&r instanceof Node){if(!(e instanceof Node))throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof e}`);return this.assert(r.contains(e),"expected #{this} to contain element #{exp}","expected #{this} not to contain element #{exp}",e,r)}if(typeof DOMTokenList<"u"&&r instanceof DOMTokenList){O(e,"class name",["string"]);const o=t.flag(this,"negate")?r.value.replace(e,"").trim():`${r.value} ${e}`;return this.assert(r.contains(e),`expected "${r.value}" to contain "${e}"`,`expected "${r.value}" not to contain "${e}"`,o,r.value)}return typeof r=="string"&&typeof e=="string"?this.assert(r.includes(e),"expected #{this} to contain #{exp}","expected #{this} not to contain #{exp}",e,r):(r!=null&&typeof r!="string"&&t.flag(this,"object",Array.from(r)),this.contain(e))}),c("toContainEqual",function(e){const r=t.flag(this,"object"),i=Array.from(r).findIndex(o=>y(o,e,u));this.assert(i!==-1,"expected #{this} to deep equally contain #{exp}","expected #{this} to not deep equally contain #{exp}",e)}),c("toBeTruthy",function(){const e=t.flag(this,"object");this.assert(!!e,"expected #{this} to be truthy","expected #{this} to not be truthy",e,!1)}),c("toBeFalsy",function(){const e=t.flag(this,"object");this.assert(!e,"expected #{this} to be falsy","expected #{this} to not be falsy",e,!1)}),c("toBeGreaterThan",function(e){const r=this._obj;return O(r,"actual",["number","bigint"]),O(e,"expected",["number","bigint"]),this.assert(r>e,`expected ${r} to be greater than ${e}`,`expected ${r} to be not greater than ${e}`,r,e,!1)}),c("toBeGreaterThanOrEqual",function(e){const r=this._obj;return O(r,"actual",["number","bigint"]),O(e,"expected",["number","bigint"]),this.assert(r>=e,`expected ${r} to be greater than or equal to ${e}`,`expected ${r} to be not greater than or equal to ${e}`,r,e,!1)}),c("toBeLessThan",function(e){const r=this._obj;return O(r,"actual",["number","bigint"]),O(e,"expected",["number","bigint"]),this.assert(r<e,`expected ${r} to be less than ${e}`,`expected ${r} to be not less than ${e}`,r,e,!1)}),c("toBeLessThanOrEqual",function(e){const r=this._obj;return O(r,"actual",["number","bigint"]),O(e,"expected",["number","bigint"]),this.assert(r<=e,`expected ${r} to be less than or equal to ${e}`,`expected ${r} to be not less than or equal to ${e}`,r,e,!1)}),c("toBeNaN",function(){return this.be.NaN}),c("toBeUndefined",function(){return this.be.undefined}),c("toBeNull",function(){return this.be.null}),c("toBeDefined",function(){const e=t.flag(this,"negate");return t.flag(this,"negate",!1),e?this.be.undefined:this.not.be.undefined}),c("toBeTypeOf",function(e){const r=typeof this._obj,i=e===r;return this.assert(i,"expected #{this} to be type of #{exp}","expected #{this} not to be type of #{exp}",e,r)}),c("toBeInstanceOf",function(e){return this.instanceOf(e)}),c("toHaveLength",function(e){return this.have.length(e)}),c("toHaveProperty",function(...e){Array.isArray(e[0])&&(e[0]=e[0].map(T=>String(T).replace(/([.[\]])/g,"\\$1")).join("."));const r=this._obj,[i,o]=e,l=()=>Object.prototype.hasOwnProperty.call(r,i)?{value:r[i],exists:!0}:t.getPathInfo(r,i),{value:f,exists:m}=l(),b=m&&(e.length===1||y(o,f,u)),w=e.length===1?"":` with value ${t.objDisplay(o)}`;return this.assert(b,`expected #{this} to have property "${i}"${w}`,`expected #{this} to not have property "${i}"${w}`,o,m?f:void 0)}),c("toBeCloseTo",function(e,r=2){const i=this._obj;let o=!1,l=0,f=0;return e===Number.POSITIVE_INFINITY&&i===Number.POSITIVE_INFINITY||e===Number.NEGATIVE_INFINITY&&i===Number.NEGATIVE_INFINITY?o=!0:(l=10**-r/2,f=Math.abs(i-e),o=f<l),this.assert(o,`expected #{this} to be close to #{exp}, received difference is ${f}, but expected ${l}`,`expected #{this} to not be close to #{exp}, received difference is ${f}, but expected ${l}`,e,i,!1)});const h=e=>{if(!gt(e._obj))throw new TypeError(`${t.inspect(e._obj)} is not a spy or a call to a spy!`)},p=e=>(h(e),e._obj),g=e=>{const r=e%10,i=e%100;return r===1&&i!==11?`${e}st`:r===2&&i!==12?`${e}nd`:r===3&&i!==13?`${e}rd`:`${e}th`},d=(e,r,i)=>(e.mock.calls&&(r+=a().gray(`

Received: 

${e.mock.calls.map((o,l)=>{let f=a().bold(`  ${g(l+1)} ${e.getMockName()} call:

`);return i?f+=B(i,o,{omitAnnotationLines:!0}):f+=S(o).split(`
`).map(m=>`    ${m}`).join(`
`),f+=`
`,f}).join(`
`)}`)),r+=a().gray(`

Number of calls: ${a().bold(e.mock.calls.length)}
`),r),$=(e,r,i)=>(r+=a().gray(`

Received: 

${e.mock.results.map((o,l)=>{let f=a().bold(`  ${g(l+1)} ${e.getMockName()} call return:

`);return i?f+=B(i,o.value,{omitAnnotationLines:!0}):f+=S(o).split(`
`).map(m=>`    ${m}`).join(`
`),f+=`
`,f}).join(`
`)}`),r+=a().gray(`

Number of calls: ${a().bold(e.mock.calls.length)}
`),r);c(["toHaveBeenCalledTimes","toBeCalledTimes"],function(e){const r=p(this),i=r.getMockName(),o=r.mock.calls.length;return this.assert(o===e,`expected "${i}" to be called #{exp} times, but got ${o} times`,`expected "${i}" to not be called #{exp} times`,e,o,!1)}),c("toHaveBeenCalledOnce",function(){const e=p(this),r=e.getMockName(),i=e.mock.calls.length;return this.assert(i===1,`expected "${r}" to be called once, but got ${i} times`,`expected "${r}" to not be called once`,1,i,!1)}),c(["toHaveBeenCalled","toBeCalled"],function(){const e=p(this),r=e.getMockName(),i=e.mock.calls.length,o=i>0,l=t.flag(this,"negate");let f=t.getMessage(this,[o,`expected "${r}" to be called at least once`,`expected "${r}" to not be called at all, but actually been called ${i} times`,!0,o]);if(o&&l&&(f=d(e,f)),o&&l||!o&&!l)throw new s(f)}),c(["toHaveBeenCalledWith","toBeCalledWith"],function(...e){const r=p(this),i=r.getMockName(),o=r.mock.calls.some(m=>y(m,e,[...u,N])),l=t.flag(this,"negate"),f=t.getMessage(this,[o,`expected "${i}" to be called with arguments: #{exp}`,`expected "${i}" to not be called with arguments: #{exp}`,e]);if(o&&l||!o&&!l)throw new s(d(r,f,e))}),c(["toHaveBeenNthCalledWith","nthCalledWith"],function(e,...r){const i=p(this),o=i.getMockName(),l=i.mock.calls[e-1],f=i.mock.calls.length,m=e<=f;this.assert(y(l,r,[...u,N]),`expected ${g(e)} "${o}" call to have been called with #{exp}${m?"":`, but called only ${f} times`}`,`expected ${g(e)} "${o}" call to not have been called with #{exp}`,r,l,m)}),c(["toHaveBeenLastCalledWith","lastCalledWith"],function(...e){const r=p(this),i=r.getMockName(),o=r.mock.calls[r.mock.calls.length-1];this.assert(y(o,e,[...u,N]),`expected last "${i}" call to have been called with #{exp}`,`expected last "${i}" call to not have been called with #{exp}`,e,o)}),c(["toThrow","toThrowError"],function(e){if(typeof e=="string"||typeof e>"u"||e instanceof RegExp)return this.throws(e);const r=this._obj,i=t.flag(this,"promise"),o=t.flag(this,"negate");let l=null;if(i==="rejects")l=r;else if(i==="resolves"&&typeof r!="function"){if(o)return;{const f=t.flag(this,"message")||"expected promise to throw an error, but it didn't",m={showDiff:!1};throw new s(f,m,t.flag(this,"ssfi"))}}else{let f=!1;try{r()}catch(m){f=!0,l=m}if(!f&&!o){const m=t.flag(this,"message")||"expected function to throw an error, but it didn't",b={showDiff:!1};throw new s(m,b,t.flag(this,"ssfi"))}}if(typeof e=="function"){const f=e.name||e.prototype.constructor.name;return this.assert(l&&l instanceof e,`expected error to be instance of ${f}`,`expected error not to be instance of ${f}`,e,l)}if(e instanceof Error)return this.assert(l&&e.message===l.message,`expected error to have message: ${e.message}`,`expected error not to have message: ${e.message}`,e.message,l&&l.message);if(typeof e=="object"&&"asymmetricMatch"in e&&typeof e.asymmetricMatch=="function"){const f=e;return this.assert(l&&f.asymmetricMatch(l),"expected error to match asymmetric matcher","expected error not to match asymmetric matcher",f,l)}throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof e}"`)}),c(["toHaveReturned","toReturn"],function(){const e=p(this),r=e.getMockName(),i=e.mock.calls.length>0&&e.mock.results.some(({type:o})=>o!=="throw");this.assert(i,`expected "${r}" to be successfully called at least once`,`expected "${r}" to not be successfully called`,i,!i,!1)}),c(["toHaveReturnedTimes","toReturnTimes"],function(e){const r=p(this),i=r.getMockName(),o=r.mock.results.reduce((l,{type:f})=>f==="throw"?l:++l,0);this.assert(o===e,`expected "${i}" to be successfully called ${e} times`,`expected "${i}" to not be successfully called ${e} times`,`expected number of returns: ${e}`,`received number of returns: ${o}`,!1)}),c(["toHaveReturnedWith","toReturnWith"],function(e){const r=p(this),i=r.getMockName(),o=r.mock.results.some(({type:m,value:b})=>m==="return"&&y(e,b)),l=t.flag(this,"negate"),f=t.getMessage(this,[o,`expected "${i}" to return with: #{exp} at least once`,`expected "${i}" to not return with: #{exp}`,e]);if(o&&l||!o&&!l)throw new s($(r,f,e))}),c(["toHaveLastReturnedWith","lastReturnedWith"],function(e){const r=p(this),i=r.getMockName(),{value:o}=r.mock.results[r.mock.results.length-1],l=y(o,e);this.assert(l,`expected last "${i}" call to return #{exp}`,`expected last "${i}" call to not return #{exp}`,e,o)}),c(["toHaveNthReturnedWith","nthReturnedWith"],function(e,r){const i=p(this),o=i.getMockName(),l=t.flag(this,"negate"),{type:f,value:m}=i.mock.results[e-1],b=`${g(e)} call`;!l&&f==="throw"&&n.assert.fail(`expected ${b} to return #{exp}, but instead it threw an error`);const w=y(m,r);this.assert(w,`expected ${b} "${o}" call to return #{exp}`,`expected ${b} "${o}" call to not return #{exp}`,r,m)}),c("toSatisfy",function(e,r){return this.be.satisfy(e,r)}),t.addProperty(n.Assertion.prototype,"resolves",function(){const r=new Error("resolves");t.flag(this,"promise","resolves"),t.flag(this,"error",r);const i=t.flag(this,"vitest-test"),o=t.flag(this,"object");if(typeof(o==null?void 0:o.then)!="function")throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof o}'.`);const l=new Proxy(this,{get:(f,m,b)=>{const w=Reflect.get(f,m,b);return typeof w!="function"?w instanceof n.Assertion?l:w:async(...T)=>{const C=o.then(M=>(t.flag(this,"object",M),w.call(this,...T)),M=>{const x=new s(`promise rejected "${t.inspect(M)}" instead of resolving`,{showDiff:!1});throw x.cause=M,x.stack=r.stack.replace(r.message,x.message),x});return et(i,C)}}});return l}),t.addProperty(n.Assertion.prototype,"rejects",function(){const r=new Error("rejects");t.flag(this,"promise","rejects"),t.flag(this,"error",r);const i=t.flag(this,"vitest-test"),o=t.flag(this,"object"),l=typeof o=="function"?o():o;if(typeof(l==null?void 0:l.then)!="function")throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof l}'.`);const f=new Proxy(this,{get:(m,b,w)=>{const T=Reflect.get(m,b,w);return typeof T!="function"?T instanceof n.Assertion?f:T:async(...C)=>{const M=l.then(x=>{const E=new s(`promise resolved "${t.inspect(x)}" instead of rejecting`,{showDiff:!0,expected:new Error("rejected promise"),actual:x});throw E.stack=r.stack.replace(r.message,E.message),E},x=>(t.flag(this,"object",x),T.call(this,...C)));return et(i,M)}}});return f})};function jt(n,t){const s=n._obj,a=F.flag(n,"negate"),u=F.flag(n,"promise")||"",c={...ot(),diff:B,stringify:S,iterableEquality:N,subsetEquality:A};return{state:{...k(t),customTesters:V(),isNot:a,utils:c,promise:u,equals:y,suppressedErrors:[]},isNot:a,obj:s}}class nt extends Error{constructor(t,s,a){super(t),this.actual=s,this.expected=a}}function Ct(n,t){return(s,a)=>{Object.entries(t).forEach(([u,c])=>{function h(...$){const{state:e,isNot:r,obj:i}=jt(this,n),o=c.call(e,i,...$);if(o&&typeof o=="object"&&o instanceof Promise)return o.then(({pass:w,message:T,actual:C,expected:M})=>{if(w&&r||!w&&!r)throw new nt(T(),C,M)});const{pass:l,message:f,actual:m,expected:b}=o;if(l&&r||!l&&!r)throw new nt(f(),m,b)}const p=ut(a,h);a.addMethod(globalThis[_].matchers,u,p),a.addMethod(s.Assertion.prototype,u,p);class g extends j{constructor(e=!1,...r){super(r,e)}asymmetricMatch(e){const{pass:r}=c.call(this.getMatcherContext(n),e,...this.sample);return this.inverse?!r:r}toString(){return`${this.inverse?"not.":""}${u}`}getExpectedType(){return"any"}toAsymmetricMatcher(){return`${this.toString()}<${this.sample.map(String).join(", ")}>`}}const d=(...$)=>new g(!1,...$);Object.defineProperty(n,u,{configurable:!0,enumerable:!0,value:d,writable:!0}),Object.defineProperty(n.not,u,{configurable:!0,enumerable:!0,value:(...$)=>new g(!0,...$),writable:!0}),Object.defineProperty(globalThis[st],u,{configurable:!0,enumerable:!0,value:d,writable:!0})})}}const Dt=(n,t)=>{t.addMethod(n.expect,"extend",(s,a)=>{n.use(Ct(s,a))})};export{st as A,L as G,Dt as J,qt as a,Rt as b,Pt as c,A as d,y as e,k as g,N as i,Bt as s};
//# sourceMappingURL=vitest_expect-r-L7D122.js.map

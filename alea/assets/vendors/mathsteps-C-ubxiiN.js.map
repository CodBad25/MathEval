{"version":3,"file":"mathsteps-C-ubxiiN.js","sources":["../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/ChangeTypes.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/MathjsInstance.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/Type.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/Creator.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/evaluate.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/Term.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/PolynomialTerm.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/Negative.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/CustomType.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/MixedNumber.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/NthRootTerm.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/Status.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/node/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canAddLikeTerms.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/resolvesToConstant.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canFindRoots.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/collectAndCombineSearch/ConstantOrConstantPower.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canMultiplyLikeTermConstantNodes.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canMultiplyLikeTermPolynomialNodes.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/factor/ConstantFactors.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/flattenOperands.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/cloneDeepWithChangGroup.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/setImplicitMultiply.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/addParenthesis.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/print.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/functionsSearch/nthRoot.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canMultiplyLikeTermsNthRoots.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canRearrangeCoefficient.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canSimplifyPolynomialTerms.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/hasUnsupportedNodes.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/Symbols.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/isQuadratic.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/equation/Equation.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/canCrossMuliplication.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/checks/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/factor/factorQuadratic.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/Util.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/collectAndCombineSearch/LikeTermCollector.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/util/removeUnnecessaryParens.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/factor/stepThrough.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/factor/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/TreeSearch.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/arithmeticSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/convertMixedNumberToImproperFraction.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/rearrangeCoefficient.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/reduceExponentByZero.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/reduceMultiplicationByZero.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/reduceZeroDividedByAnything.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/removeAdditionOfZero.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/removeDivisionByOne.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/removeExponentBaseOne.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/removeExponentByOne.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/removeMultiplicationByNegativeOne.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/removeMultiplicationByOne.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/simplifyDoubleUnaryMinus.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/breakUpNumeratorSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/divideByGCD.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/addConstantFractions.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/addConstantAndFraction.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/collectAndCombineSearch/evaluateConstantSum.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/collectAndCombineSearch/addLikeTerms.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/multiplyFractionsSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/collectAndCombineSearch/multiplyLikeTerms.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/collectAndCombineSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/distributeSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/divisionSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/cancelLikeTerms.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/simplifyFractionSigns.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/simplifyPolynomialFraction.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/functionsSearch/absoluteValue.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/functionsSearch/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/stepThrough.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/equation/Status.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/solveEquation/EquationOperations.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/solveEquation/stepThrough.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/solveEquation/index.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/fractionsSearch/simplifyFractionSignsBefore.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/lib/simplifyExpression/basicsSearch/indexSimplifyOneRule.js","../../../node_modules/.pnpm/mathsteps@https+++codeload.github.com+mathalea+mathsteps+tar.gz+cef559c7cfd903446b530a8527499611e8f53cea/node_modules/mathsteps/index.js"],"sourcesContent":["// The text to identify rules for each possible step that can be taken\n\nmodule.exports = {\n  NO_CHANGE: 'NO_CHANGE',\n\n  EQUALITY: 'EQUALITY',\n\n  // ARITHMETIC\n\n  // e.g. 2 + 2 -> 4 or 2 * 2 -> 4\n  SIMPLIFY_ARITHMETIC: 'SIMPLIFY_ARITHMETIC',\n\n  // BASICS\n\n  // e.g. 2/-1 -> -2\n  DIVISION_BY_NEGATIVE_ONE: 'DIVISION_BY_NEGATIVE_ONE',\n  // e.g. 2/1 -> 2\n  DIVISION_BY_ONE: 'DIVISION_BY_ONE',\n  // e.g. x * 0 -> 0\n  MULTIPLY_BY_ZERO: 'MULTIPLY_BY_ZERO',\n  // e.g. x * 2 -> 2x\n  REARRANGE_COEFF: 'REARRANGE_COEFF',\n  // e.g. x ^ 0 -> 1\n  REDUCE_EXPONENT_BY_ZERO: 'REDUCE_EXPONENT_BY_ZERO',\n  // e.g. 0/1 -> 0\n  REDUCE_ZERO_NUMERATOR: 'REDUCE_ZERO_NUMERATOR',\n  // e.g. 2 + 0 -> 2\n  REMOVE_ADDING_ZERO: 'REMOVE_ADDING_ZERO',\n  // e.g. x ^ 1 -> x\n  REMOVE_EXPONENT_BY_ONE: 'REMOVE_EXPONENT_BY_ONE',\n  // e.g. 1 ^ x -> 1\n  REMOVE_EXPONENT_BASE_ONE: 'REMOVE_EXPONENT_BASE_ONE',\n  // e.g. x * -1 -> -x\n  REMOVE_MULTIPLYING_BY_NEGATIVE_ONE: 'REMOVE_MULTIPLYING_BY_NEGATIVE_ONE',\n  // e.g. x * 1 -> x\n  REMOVE_MULTIPLYING_BY_ONE: 'REMOVE_MULTIPLYING_BY_ONE',\n  // e.g. 2 - - 3 -> 2 + 3\n  RESOLVE_DOUBLE_MINUS: 'RESOLVE_DOUBLE_MINUS',\n\n  // COLLECT AND COMBINE AND BREAK UP\n\n  // e.g. 2 + x + 3 + x -> 5 + 2x\n  COLLECT_AND_COMBINE_LIKE_TERMS: 'COLLECT_AND_COMBINE_LIKE_TERMS',\n  // e.g. x + 2 + x^2 + x + 4 -> x^2 + (x + x) + (4 + 2)\n  COLLECT_LIKE_TERMS: 'COLLECT_LIKE_TERMS',\n\n  // MULTIPLYING CONSTANT POWERS\n  // e.g. 10^2 * 10^3 -> 10^(2+3)\n  COLLECT_CONSTANT_EXPONENTS: 'COLLECT_CONSTANT_EXPONENTS',\n\n  // ADDING POLYNOMIALS\n\n  // e.g. 2x + x -> 2x + 1x\n  ADD_COEFFICIENT_OF_ONE: 'ADD_COEFFICIENT_OF_ONE',\n  // e.g. x^2 + x^2 -> 2x^2\n  ADD_POLYNOMIAL_TERMS: 'ADD_POLYNOMIAL_TERMS',\n  // e.g. 2x^2 + 3x^2 + 5x^2 -> (2+3+5)x^2\n  GROUP_COEFFICIENTS: 'GROUP_COEFFICIENTS',\n  // e.g. -x + 2x => -1*x + 2x\n  UNARY_MINUS_TO_NEGATIVE_ONE: 'UNARY_MINUS_TO_NEGATIVE_ONE',\n\n  // CROSS MULTIPLICATION\n  // e.g. 3/b = 4/5 -> 3*5 = 4*b\n  CROSS_PRODUCT_EQUALITY: 'CROSS_PRODUCT_EQUALITY',\n\n  // MULTIPLYING POLYNOMIALS\n\n  // e.g. x^2 * x -> x^2 * x^1\n  ADD_EXPONENT_OF_ONE: 'ADD_EXPONENT_OF_ONE',\n  // e.g. x^2 * x^3 * x^1 -> x^(2 + 3 + 1)\n  COLLECT_POLYNOMIAL_EXPONENTS: 'COLLECT_POLYNOMIAL_EXPONENTS',\n  // e.g. 2x * 3x -> (2 * 3)(x * x)\n  MULTIPLY_COEFFICIENTS: 'MULTIPLY_COEFFICIENTS',\n  // e.g. 2x * x -> 2x ^ 2\n  MULTIPLY_POLYNOMIAL_TERMS: 'MULTIPLY_POLYNOMIAL_TERMS',\n\n  // FRACTIONS\n\n  // e.g. (x + 2)/2 -> x/2 + 2/2\n  BREAK_UP_FRACTION: 'BREAK_UP_FRACTION',\n  // e.g. -2/-3 => 2/3\n  CANCEL_MINUSES: 'CANCEL_MINUSES',\n  // e.g. 2x/2 -> x\n  CANCEL_TERMS: 'CANCEL_TERMS',\n  // e.g. 2/6 -> 1/3\n  SIMPLIFY_FRACTION: 'SIMPLIFY_FRACTION',\n  // e.g. 2/-3 -> -2/3\n  SIMPLIFY_SIGNS: 'SIMPLIFY_SIGNS',\n   // e.g. 2/-3 -> -\\frac{2}{3} -> using unary minus\n  SIMPLIFY_SIGNS_BEFORE: 'SIMPLIFY_SIGNS_BEFORE',\n  // e.g. 15/6 -> (5*3)/(2*3)\n  FIND_GCD: 'FIND_GCD',\n  // e.g. (5*3)/(2*3) -> 5/2\n  CANCEL_GCD: 'CANCEL_GCD',\n  // e.g. 1 2/3 -> 5/3\n  CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION: 'CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION',\n  // e.g. 1 2/3 -> ((1 * 3) + 2) / 3\n  IMPROPER_FRACTION_NUMERATOR: 'IMPROPER_FRACTION_NUMERATOR',\n\n  // ADDING FRACTIONS\n\n  // e.g. 1/2 + 1/3 -> 5/6\n  ADD_FRACTIONS: 'ADD_FRACTIONS',\n  // e.g. (1 + 2)/3 -> 3/3\n  ADD_NUMERATORS: 'ADD_NUMERATORS',\n  // e.g. (2+1)/5\n  COMBINE_NUMERATORS: 'COMBINE_NUMERATORS',\n  // e.g. 2/6 + 1/4 -> (2*2)/(6*2) + (1*3)/(4*3)\n  COMMON_DENOMINATOR: 'COMMON_DENOMINATOR',\n  // e.g. 3 + 1/2 -> 6/2 + 1/2 (for addition)\n  CONVERT_INTEGER_TO_FRACTION: 'CONVERT_INTEGER_TO_FRACTION',\n  // e.g. 1.2 + 1/2 -> 1.2 + 0.5\n  DIVIDE_FRACTION_FOR_ADDITION: 'DIVIDE_FRACTION_FOR_ADDITION',\n  // e.g. (2*2)/(6*2) + (1*3)/(4*3) -> (2*2)/12 + (1*3)/12\n  MULTIPLY_DENOMINATORS: 'MULTIPLY_DENOMINATORS',\n  // e.g. (2*2)/12 + (1*3)/12 -> 4/12 + 3/12\n  MULTIPLY_NUMERATORS: 'MULTIPLY_NUMERATORS',\n\n  // MULTIPLYING FRACTIONS\n\n  // e.g. 1/2 * 2/3 -> 2/6\n  MULTIPLY_FRACTIONS: 'MULTIPLY_FRACTIONS',\n\n  // DIVISION\n\n  // e.g. 2/3/4 -> 2/(3*4)\n  SIMPLIFY_DIVISION: 'SIMPLIFY_DIVISION',\n  // e.g. x/(2/3) -> x * 3/2\n  MULTIPLY_BY_INVERSE: 'MULTIPLY_BY_INVERSE',\n\n  // DISTRIBUTION\n\n  // e.g. 2(x + y) -> 2x + 2y\n  DISTRIBUTE: 'DISTRIBUTE',\n  // e.g. -(2 + x) -> -2 - x\n  DISTRIBUTE_NEGATIVE_ONE: 'DISTRIBUTE_NEGATIVE_ONE',\n  // e.g. 2 * 4x + 2*5 --> 8x + 10 (as part of distribution)\n  SIMPLIFY_TERMS: 'SIMPLIFY_TERMS',\n  // e.g. (nthRoot(x, 2))^2 -> nthRoot(x, 2) * nthRoot(x, 2)\n  // e.g. (2x + 3)^2 -> (2x + 3) (2x + 3)\n  EXPAND_EXPONENT: 'EXPAND_EXPONENT',\n\n  // ABSOLUTE\n  // e.g. |-3| -> 3\n  ABSOLUTE_VALUE: 'ABSOLUTE_VALUE',\n\n  // ROOTS\n  // e.g. nthRoot(x ^ 2, 4) -> nthRoot(x, 2)\n  CANCEL_EXPONENT: 'CANCEL_EXPONENT',\n  // e.g. nthRoot(x ^ 2, 2) -> x\n  CANCEL_EXPONENT_AND_ROOT: 'CANCEL_EXPONENT_AND_ROOT',\n  // e.g. nthRoot(x ^ 4, 2) -> x ^ 2\n  CANCEL_ROOT: 'CANCEL_ROOT',\n  // e.g. nthRoot(2, 2) * nthRoot(3, 2) -> nthRoot(2 * 3, 2)\n  COMBINE_UNDER_ROOT: 'COMBINE_UNDER_ROOT',\n  // e.g. 2 * 2 * 2 -> 2 ^ 3\n  CONVERT_MULTIPLICATION_TO_EXPONENT: 'CONVERT_MULTIPLICATION_TO_EXPONENT',\n  // e.g. nthRoot(2 * x) -> nthRoot(2) * nthRoot(x)\n  DISTRIBUTE_NTH_ROOT: 'DISTRIBUTE_NTH_ROOT',\n  // e.g. nthRoot(4) * nthRoot(x^2) -> 2 * x\n  EVALUATE_DISTRIBUTED_NTH_ROOT: 'EVALUATE_DISTRIBUTED_NTH_ROOT',\n  // e.g. 12 -> 2 * 2 * 3\n  FACTOR_INTO_PRIMES: 'FACTOR_INTO_PRIMES',\n  // e.g. nthRoot(2 * 2 * 2, 2) -> nthRoot((2 * 2) * 2)\n  GROUP_TERMS_BY_ROOT: 'GROUP_TERMS_BY_ROOT',\n  // e.g. nthRoot(4) -> 2\n  NTH_ROOT_VALUE: 'NTH_ROOT_VALUE',\n  // e.g. nthRoot(4) + nthRoot(4) = 2*nthRoot(4)\n  ADD_NTH_ROOTS: 'ADD_NTH_ROOTS',\n  // e.g. nthRoot(x, 2) * nthRoot(x, 2) -> nthRoot(x^2, 2)\n  MULTIPLY_NTH_ROOTS: 'MULTIPLY_NTH_ROOTS',\n\n  // SOLVING FOR A VARIABLE\n\n  // e.g. x - 3 = 2 -> x - 3 + 3 = 2 + 3\n  ADD_TO_BOTH_SIDES: 'ADD_TO_BOTH_SIDES',\n  // e.g. 2x = 1 -> (2x)/2 = 1/2\n  DIVIDE_FROM_BOTH_SIDES: 'DIVIDE_FROM_BOTH_SIDES',\n  // e.g. (2/3)x = 1 -> (2/3)x * (3/2) = 1 * (3/2)\n  MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION: 'MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION',\n  // e.g. -x = 2 -> -1 * -x = -1 * 2\n  MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE: 'MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE',\n  // e.g. x/2 = 1 -> (x/2) * 2 = 1 * 2\n  MULTIPLY_TO_BOTH_SIDES: 'MULTIPLY_TO_BOTH_SIDES',\n  // e.g. x + 2 - 1 = 3 -> x + 1 = 3\n  SIMPLIFY_LEFT_SIDE: 'SIMPLIFY_LEFT_SIDE',\n  // e.g. x = 3 - 1 -> x = 2\n  SIMPLIFY_RIGHT_SIDE: 'SIMPLIFY_RIGHT_SIDE',\n  // e.g. x + 3 = 2 -> x + 3 - 3 = 2 - 3\n  SUBTRACT_FROM_BOTH_SIDES: 'SUBTRACT_FROM_BOTH_SIDES',\n  // e.g. 2 = x -> x = 2\n  SWAP_SIDES: 'SWAP_SIDES',\n  // e.g. (x - 2) (x + 2) = 0 => x = [-2, 2]\n  FIND_ROOTS: 'FIND_ROOTS',\n\n  // CONSTANT EQUATION\n\n  // e.g. 2 = 2\n  STATEMENT_IS_TRUE: 'STATEMENT_IS_TRUE',\n  // e.g. 2 = 3\n  STATEMENT_IS_FALSE: 'STATEMENT_IS_FALSE',\n\n  // FACTORING\n\n  // e.g. x^2 - 4x -> x(x - 4)\n  FACTOR_SYMBOL: 'FACTOR_SYMBOL',\n  // e.g. x^2 - 4 -> (x - 2)(x + 2)\n  FACTOR_DIFFERENCE_OF_SQUARES: 'FACTOR_DIFFERENCE_OF_SQUARES',\n  // e.g. x^2 + 2x + 1 -> (x + 1)^2\n  FACTOR_PERFECT_SQUARE: 'FACTOR_PERFECT_SQUARE',\n  // e.g. x^2 + 3x + 2 -> (x + 1)(x + 2)\n  FACTOR_SUM_PRODUCT_RULE: 'FACTOR_SUM_PRODUCT_RULE',\n  // e.g. 2x^2 + 4x + 2 -> 2x^2 + 2x + 2x + 2\n  BREAK_UP_TERM: 'BREAK_UP_TERM',\n};\n","const { create, NodeDependencies, lcmDependencies, nthRootDependencies, gcdDependencies, fractionDependencies, parseDependencies, evaluateDependencies, simplifyDependencies, formatDependencies } = require('mathjs')\n\n\nconst config = {\n  // optionally, you can specify configuration\n}\n\n// Create just the functions we need\nconst math = create({\n  fractionDependencies,\n  lcmDependencies,\n  gcdDependencies,\n  nthRootDependencies,\n  NodeDependencies,\n  formatDependencies,\n  parseDependencies,\n  evaluateDependencies,\n  simplifyDependencies\n}, config)\n\nmodule.exports = math;\n","/*\n  For determining the type of a mathJS node.\n */\n\nconst NodeType = {};\n\nNodeType.isOperator = function(node, operator=null) {\n  return node.type === 'OperatorNode' &&\n         node.fn !== 'unaryMinus' &&\n         '*+-/^'.includes(node.op) &&\n         (operator ? node.op === operator : true);\n};\n\nNodeType.isParenthesis = function(node) {\n  return node.type === 'ParenthesisNode';\n};\n\nNodeType.isUnaryMinus = function(node) {\n  return node.type === 'OperatorNode' && node.fn === 'unaryMinus';\n};\n\nNodeType.isFunction = function(node, functionName=null) {\n  if (node.type !== 'FunctionNode') {\n    return false;\n  }\n  if (functionName && node.fn.name !== functionName) {\n    return false;\n  }\n  return true;\n};\n\nNodeType.isSymbol = function(node, allowUnaryMinus=false) {\n  if (node.type === 'SymbolNode') {\n    return true;\n  }\n  else if (allowUnaryMinus && NodeType.isUnaryMinus(node)) {\n    return NodeType.isSymbol(node.args[0], false);\n  }\n  else {\n    return false;\n  }\n};\n\nNodeType.isConstant = function(node, allowUnaryMinus=false) {\n  if (node.type === 'ConstantNode') {\n    return true;\n  }\n  else if (allowUnaryMinus && NodeType.isUnaryMinus(node)) {\n    if (NodeType.isConstant(node.args[0], false)) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n  else {\n    return false;\n  }\n};\n\nNodeType.isConstantFraction = function(node, allowUnaryMinus=false) {\n  if (NodeType.isOperator(node, '/')) {\n    return node.args.every(n => NodeType.isConstant(n, allowUnaryMinus));\n  }\n  else {\n    return false;\n  }\n};\n\nNodeType.isConstantOrConstantFraction = function(node, allowUnaryMinus=false) {\n  if (NodeType.isConstant(node, allowUnaryMinus) ||\n      NodeType.isConstantFraction(node, allowUnaryMinus)) {\n    return true;\n  }\n  else {\n    return false;\n  }\n};\n\nNodeType.isIntegerFraction = function(node, allowUnaryMinus=false) {\n  if (!NodeType.isConstantFraction(node, allowUnaryMinus)) {\n    return false;\n  }\n  let numerator = node.args[0];\n  let denominator = node.args[1];\n  if (allowUnaryMinus) {\n    if (NodeType.isUnaryMinus(numerator)) {\n      numerator = numerator.args[0];\n    }\n    if (NodeType.isUnaryMinus(denominator)) {\n      denominator = denominator.args[0];\n    }\n  }\n  return (Number.isInteger(parseFloat(numerator.value)) &&\n          Number.isInteger(parseFloat(denominator.value)));\n};\n\nmodule.exports = NodeType;\n","/*\n  Functions to generate any mathJS node supported by the stepper\n  see http://mathjs.org/docs/expressions/expression_trees.html#nodes for more\n  information on nodes in mathJS\n*/\n\nconst math = require('./MathjsInstance');\nconst NodeType = require('./Type');\n\nconst NodeCreator = {\n  operator (op, args, implicit=false) {\n    switch (op) {\n    case '+':\n      return new math.OperatorNode('+', 'add', args);\n    case '-':\n      return new math.OperatorNode('-', 'subtract', args);\n    case '/':\n      return new math.OperatorNode('/', 'divide', args);\n    case '*':\n      return new math.OperatorNode(\n        '*', 'multiply', args, implicit);\n    case '^':\n      return new math.OperatorNode('^', 'pow', args);\n    default:\n      throw Error('Unsupported operation: ' + op);\n    }\n  },\n\n  // In almost all cases, use Negative.negate (with naive = true) to add a\n  // unary minus to your node, rather than calling this constructor directly\n  unaryMinus (content) {\n    return new math.OperatorNode(\n      '-', 'unaryMinus', [content]);\n  },\n\n  constant (val) {\n    return new math.ConstantNode(val);\n  },\n\n  symbol (name) {\n    return new math.SymbolNode(name);\n  },\n\n  parenthesis (content) {\n    return new math.ParenthesisNode(content);\n  },\n\n  list (content) {\n    return new math.ArrayNode(content);\n  },\n\n  // exponent might be null, which means there's no exponent node.\n  // similarly, coefficient might be null, which means there's no coefficient\n  // the base node can never be null.\n  term (base, exponent, coeff, explicitCoeff=false) {\n    let term = base;\n    if (exponent) {\n      term = this.operator('^', [term, exponent]);\n    }\n    if (coeff && (explicitCoeff || parseFloat(coeff.value) !== 1)) {\n      if (NodeType.isConstant(coeff) &&\n          parseFloat(coeff.value) === -1 &&\n          !explicitCoeff) {\n        // if you actually want -1 as the coefficient, set explicitCoeff to true\n        term = this.unaryMinus(term);\n      }\n      else {\n        term = this.operator('*', [coeff, term], true);\n      }\n    }\n    return term;\n  },\n\n  polynomialTerm (symbol, exponent, coeff, explicitCoeff=false) {\n    return this.term(symbol, exponent, coeff, explicitCoeff);\n  },\n\n  // Given a root value and a radicand (what is under the radical)\n  nthRoot (radicandNode, rootNode) {\n    const symbol = NodeCreator.symbol('nthRoot');\n    return new math.FunctionNode(symbol, [radicandNode, rootNode]);\n  }\n};\n\nmodule.exports = NodeCreator;\n","// Evaluates a node to a numerical value\n// e.g. the tree representing (2 + 2) * 5 would be evaluated to the number 20\n// it's important that `node` does not contain any symbol nodes\n\nfunction evaluate(node) {\nif (node.evaluate != null) return node.evaluate()\n  else if (node.eval != null) return node.eval()\n  else throw Error(`Problem, no method for evaluate this : ${node}`)\n}\n\nmodule.exports = evaluate;\n","const NodeCreator = require('./Creator');\nconst NodeType = require('./Type');\n\nconst evaluate = require('../util/evaluate');\n\n// For storing term that have a base node, maybe an exponent,\n// and maybe a coefficient.\n// These expressions are Terms:\n//   -- x^2, 2y, z, 3x/5 (PolynomialTerm)\n//   -- nthRoot(4), 5*nthRoot(x) (NthRootTerm)\n// These expressions are not: 4, x^(3+4), 2+x, 3*7, x-z\n/* Fields:\n - coeff: either a constant node or a fraction of two constant nodes\n   (might be null if no coefficient)\n - base: the base node (e.g. in x^2, the node x)\n - exponent: a node that can take any form, e.g. x^(2+x^2)\n   (might be null if no exponent)\n*/\nclass Term {\n  // Params:\n  // -- node: The node from which to construct the Term\n  // -- baseNodeFunc: A boolean function returning true if the base node\n  //    is of the right type\n  //    e.g., for PolynomialTerms, baseNodeFunc checks if the base is a symbol\n  //    for NthRootTerms, baseNodeFunc checks if the base node is an nth root\n  // -- onlyImplicitMultiplication: If onlyImplicitMultiplication is true,\n  //    we throw an error if `node` is a term without implicit multiplication\n  //    (i.e. 2*x instead of 2x) and therefore isTerm will return false.\n  constructor(node, baseNodeFunc, onlyImplicitMultiplication=false) {\n    const values = Term.parseNode(node, baseNodeFunc, onlyImplicitMultiplication);\n    this.base = values.base;\n    this.exponent = values.exponent;\n    this.coeff = values.coeff;\n  }\n  /* GETTER FUNCTIONS */\n  getBaseNode() {\n    return this.base;\n  }\n\n  getCoeffNode(defaultOne=false) {\n    if (!this.coeff && defaultOne) {\n      return NodeCreator.constant(1);\n    }\n    else {\n      return this.coeff;\n    }\n  }\n\n  getCoeffValue() {\n    if (this.coeff) {\n      return evaluate(this.coeff);\n    }\n    else {\n      return 1; // no coefficient is like a coeff of 1\n    }\n  }\n\n  getExponentNode(defaultOne=false) {\n    if (!this.exponent && defaultOne) {\n      return NodeCreator.constant(1);\n    }\n    else {\n      return this.exponent;\n    }\n  }\n\n  // note: there is no exponent value getter function because the exponent\n  // can be any expression and not necessarily a number.\n\n  /* CHECKER FUNCTIONS (returns true / false for certain conditions) */\n\n  // Returns true if the coefficient is a fraction\n  hasFractionCoeff() {\n    // coeffNode is either a constant or a division operation.\n    return this.coeff && NodeType.isOperator(this.coeff);\n  }\n\n  hasCoeff() {\n    return !!this.coeff;\n  }\n}\n\n// Returns if the node represents an expression that can be considered\n// a term with a coefficient.\nTerm.isTerm = function(\n  node, baseNodeFunc, onlyImplicitMultiplication=false) {\n  try {\n    // will throw error if node isn't term with coefficient\n    new Term(node, baseNodeFunc, onlyImplicitMultiplication);\n    return true;\n  }\n  catch (err) {\n    return false;\n  }\n};\n\nTerm.parseNode = function(node, baseNodeFunc, onlyImplicitMultiplication) {\n  let base, exponent, coeff;\n  if (NodeType.isOperator(node)) {\n    if (node.op === '^') {\n      const baseNode = node.args[0];\n      if (!baseNodeFunc(baseNode)) {\n        throw Error('Expected base term, got ' + baseNode);\n      }\n      base = baseNode;\n      exponent = node.args[1];\n    }\n    // it's '*' ie it has a coefficient\n    else if (node.op === '*') {\n      if (onlyImplicitMultiplication && !node.implicit) {\n        throw Error('Expected implicit multiplication');\n      }\n      if (node.args.length !== 2) {\n        throw Error('Expected two arguments to *');\n      }\n      const coeffNode = NodeType.isParenthesis(node.args[0]) ? node.args[0].content : node.args[0];\n      if (!NodeType.isConstantOrConstantFraction(coeffNode)) {\n        throw Error('Expected coefficient to be constant or fraction of ' +\n          'constants term, got ' + coeffNode);\n      }\n      coeff = coeffNode;\n      const nonCoefficientTerm = new Term(\n        node.args[1], baseNodeFunc, onlyImplicitMultiplication);\n      if (nonCoefficientTerm.hasCoeff()) {\n        throw Error('Cannot have two coefficients ' + coeffNode +\n          ' and ' + nonCoefficientTerm.getCoeffNode());\n      }\n      base = nonCoefficientTerm.getBaseNode();\n      exponent = nonCoefficientTerm.getExponentNode();\n    }\n    // this means there's a fraction coefficient\n    else if (node.op === '/') {\n      const denominatorNode = node.args[1];\n      if (!NodeType.isConstant(denominatorNode)) {\n        throw Error('denominator must be constant node, instead of ' +\n          denominatorNode);\n      }\n      const numeratorNode = new Term(\n        node.args[0], baseNodeFunc, onlyImplicitMultiplication);\n      if (numeratorNode.hasFractionCoeff()) {\n        throw Error('Terms with coefficients cannot have nested fractions');\n      }\n      exponent = numeratorNode.getExponentNode();\n      base = numeratorNode.getBaseNode();\n      const numeratorConstantNode = numeratorNode.getCoeffNode(true);\n      coeff = NodeCreator.operator(\n        '/', [numeratorConstantNode, denominatorNode]);\n    }\n    else {\n      throw Error('Unsupported operatation for term with coefficent: ' + node.op);\n    }\n  }\n  else if (NodeType.isUnaryMinus(node)) {\n    var arg = node.args[0];\n    if (NodeType.isParenthesis(arg)) {\n      arg = arg.content;\n    }\n    const termNode = new Term(\n      arg, baseNodeFunc, onlyImplicitMultiplication);\n    exponent = termNode.getExponentNode();\n    base = termNode.getBaseNode();\n    if (!termNode.hasCoeff()) {\n      coeff = NodeCreator.constant(-1);\n    }\n    else {\n      coeff = negativeCoefficient(termNode.getCoeffNode());\n    }\n  }\n  else if (baseNodeFunc(node)) {\n    base = node;\n  }\n  else if (NodeType.isParenthesis(node)) {\n    return Term.parseNode(node.content, baseNodeFunc, onlyImplicitMultiplication);\n  }\n  else {\n    throw Error('Unsupported node type: ' + node.type);\n  }\n\n  return {\n    base,\n    exponent,\n    coeff,\n  };\n};\n\n\n// Multiplies `node`, a constant or fraction of two constant nodes, by -1\n// Returns a node\nfunction negativeCoefficient(node) {\n  if (NodeType.isConstant(node)) {\n    // Node is a constant\n    node = NodeCreator.constant(0 - parseFloat(node.value));\n  }\n  else {\n    // Node is a constant fraction\n    const numeratorValue = 0 - parseFloat(node.args[0].value);\n    node.args[0] = NodeCreator.constant(numeratorValue);\n  }\n  return node;\n}\n\nmodule.exports = Term;\n","const NodeType = require('./Type');\nconst Term = require('./Term');\n\n// For storing polynomial terms, which are a subclass of Term\n// where the base node is a symbol\nclass PolynomialTerm extends Term {\n  constructor(node, onlyImplicitMultiplication=false) {\n    super(node, PolynomialTerm.baseNodeFunc, onlyImplicitMultiplication);\n  }\n\n  getSymbolNode() {\n    return this.base;\n  }\n\n  getSymbolName() {\n    return this.base.name;\n  }\n}\n\n// Returns true if the term has a base node that makes it a polynomial term\n// e.g. 4x^2 has a base of x, so it is a polynomial\n// 4*sqrt(x)^2 has a base of sqrt(x), so it is not\nPolynomialTerm.baseNodeFunc = function(node) {\n  return NodeType.isSymbol(node);\n};\n\n// Returns true if the node is a polynomial term.\n// e.g. x^2, 2y, z, 3x/5 are all polynomial terms.\n// 4, 2+x, 3*7, x-z are all not polynomial terms.\n// See the tests for some more thorough examples.\nPolynomialTerm.isPolynomialTerm = function(\n  node, onlyImplicitMultiplication=false) {\n  return Term.isTerm(\n    node, PolynomialTerm.baseNodeFunc, onlyImplicitMultiplication);\n};\n\nmodule.exports = PolynomialTerm;\n","const NodeCreator = require('./node/Creator');\nconst NodeType = require('./node/Type');\nconst PolynomialTerm = require('./node/PolynomialTerm');\n\nconst Negative = {};\n\n// Returns if the given node is negative. Treats a unary minus as a negative,\n// as well as a negative constant value or a constant fraction that would\n// evaluate to a negative number\nNegative.isNegative = function(node) {\n  if (NodeType.isUnaryMinus(node)) {\n    return !Negative.isNegative(node.args[0]);\n  }\n  else if (NodeType.isConstant(node)) {\n    return parseFloat(node.value) < 0;\n  }\n  else if (NodeType.isConstantFraction(node)) {\n    const numeratorValue = parseFloat(node.args[0].value);\n    const denominatorValue = parseFloat(node.args[1].value);\n    if (numeratorValue < 0 || denominatorValue < 0) {\n      return !(numeratorValue < 0 && denominatorValue < 0);\n    }\n  }\n  else if (PolynomialTerm.isPolynomialTerm(node)) {\n    const polyNode = new PolynomialTerm(node);\n    return Negative.isNegative(polyNode.getCoeffNode(true));\n  }\n\n  return false;\n};\n\n// Given a node, returns the negated node\n// If naive is true, then we just add an extra unary minus to the expression\n// otherwise, we do the actual negation\n// E.g.\n//    not naive: -3 -> 3, x -> -x\n//    naive: -3 -> --3, x -> -x\nNegative.negate = function(node, naive=false) {\n  if (NodeType.isConstantFraction(node)) {\n    node.args[0] = Negative.negate(node.args[0], naive);\n    return node;\n  }\n  else if (PolynomialTerm.isPolynomialTerm(node)) {\n    return Negative.negatePolynomialTerm(node, naive);\n  }\n  else if (!naive) {\n    if (NodeType.isUnaryMinus(node)) {\n      return node.args[0];\n    }\n    else if (NodeType.isConstant(node)) {\n      return NodeCreator.constant(0 - parseFloat(node.value));\n    }\n  }\n  return NodeCreator.unaryMinus(node);\n};\n\n// Multiplies a polynomial term by -1 and returns the new node\n// If naive is true, then we just add an extra unary minus to the expression\n// otherwise, we do the actual negation\n// E.g.\n//    not naive: -3x -> 3x, x -> -x\n//    naive: -3x -> --3x, x -> -x\nNegative.negatePolynomialTerm = function(node, naive=false) {\n  if (!PolynomialTerm.isPolynomialTerm(node)) {\n    throw Error('node is not a polynomial term');\n  }\n  const polyNode = new PolynomialTerm(node);\n\n  let newCoeff;\n  if (!polyNode.hasCoeff()) {\n    newCoeff = NodeCreator.constant(-1);\n  }\n  else {\n    const oldCoeff = polyNode.getCoeffNode();\n    if (oldCoeff.value === '-1') {\n      newCoeff = null;\n    }\n    else if (polyNode.hasFractionCoeff()) {\n      let numerator = oldCoeff.args[0];\n      numerator = Negative.negate(numerator, naive);\n\n      const denominator = oldCoeff.args[1];\n      newCoeff = NodeCreator.operator('/', [numerator, denominator]);\n    }\n    else {\n      newCoeff = Negative.negate(oldCoeff, naive);\n      if (newCoeff.value === '1') {\n        newCoeff = null;\n      }\n    }\n  }\n  return NodeCreator.polynomialTerm(\n    polyNode.getSymbolNode(), polyNode.getExponentNode(), newCoeff);\n};\n\nmodule.exports = Negative;\n","const Negative = require('../Negative');\nconst NodeCreator = require('./Creator');\nconst NodeType = require('./Type');\n\nconst NodeCustomType = {};\n\n// Returns true if `node` belongs to the type specified by boolean `isTypeFunc`.\n// If `allowUnaryMinus/allowParens` is true, we allow for the node to be nested.\nNodeCustomType.isType = function(node, isTypeFunc, allowUnaryMinus=true, allowParens=true) {\n  if (isTypeFunc(node)) {\n    return true;\n  }\n  else if (allowUnaryMinus && NodeType.isUnaryMinus(node)) {\n    return NodeCustomType.isType(node.args[0], isTypeFunc, allowUnaryMinus, allowParens);\n  }\n  else if (allowParens && NodeType.isParenthesis(node)) {\n    return NodeCustomType.isType(node.content, isTypeFunc, allowUnaryMinus, allowParens);\n  }\n\n  return false;\n};\n\n// Returns `node` if `node` belongs to the type specified by boolean `isTypeFunc`.\n// If `allowUnaryMinus/allowParens` is true, we check for an inner node of this type.\n// `moveUnaryMinus` should be defined if `allowUnaryMinus` is true, and should\n// move the unaryMinus into the inside of the type\n// e.g. for fractions, this function will negate the numerator\nNodeCustomType.getType = function(\n  node, isTypeFunc, allowUnaryMinus=true, allowParens=true, moveUnaryMinus=undefined) {\n  if (allowUnaryMinus === true && moveUnaryMinus === undefined) {\n    throw Error('Error in `getType`: moveUnaryMinus is undefined');\n  }\n\n  if (isTypeFunc(node)) {\n    return node;\n  }\n  else if (allowUnaryMinus && NodeType.isUnaryMinus(node)) {\n    return moveUnaryMinus(\n      NodeCustomType.getType(\n        node.args[0], isTypeFunc, allowUnaryMinus, allowParens, moveUnaryMinus));\n  }\n  else if (allowParens && NodeType.isParenthesis(node)) {\n    return NodeCustomType.getType(\n      node.content, isTypeFunc, allowUnaryMinus, allowParens, moveUnaryMinus);\n  }\n\n  throw Error('`getType` called on a node that does not belong to specified type');\n};\n\nNodeCustomType.isFraction = function(node, allowUnaryMinus=true, allowParens=true) {\n  return NodeCustomType.isType(\n    node,\n    (node) => NodeType.isOperator(node, '/'),\n    allowUnaryMinus,\n    allowParens);\n};\n\nNodeCustomType.getFraction = function(node,  allowUnaryMinus=true, allowParens=true) {\n  const moveUnaryMinus = function(node) {\n    if (!(NodeType.isOperator(node, '/'))) {\n      throw Error('Expected a fraction');\n    }\n\n    const numerator = node.args[0];\n    const denominator = node.args[1];\n    const newNumerator = Negative.negate(numerator);\n    return NodeCreator.operator('/', [newNumerator, denominator]);\n  };\n\n  return NodeCustomType.getType(\n    node,\n    (node) => NodeType.isOperator(node, '/'),\n    allowParens,\n    allowUnaryMinus,\n    moveUnaryMinus);\n};\n\nmodule.exports = NodeCustomType;\n","const Negative = require('../Negative');\nconst NodeType = require('./Type');\n\n// Returns true if `node` is a mixed number\n// e.g. 2 1/2, 19 2/3\n// Right now mathjs cannot parse the above examples;\n// instead it expects the input to look like e.g. 2(1)/(2),\n// which is division with implicit multiplication in the numerator\n// TODO: Add better support for mixed numbers in the future\nfunction isMixedNumber(node) {\n  if (!NodeType.isOperator(node, '/')) {\n    return false;\n  }\n\n  if (node.args.length !== 2) {\n    return false;\n  }\n\n  const numerator = node.args[0];\n  const denominator = node.args[1];\n\n  // check for implicit multiplication between two constants in the numerator\n  // first can be wrapped in unary minus\n  // second one can be optionally wrapped in parenthesis\n  if (!(NodeType.isOperator(numerator, '*') && numerator.implicit)) {\n    return false;\n  }\n\n  const numeratorFirstArg = NodeType.isUnaryMinus(numerator.args[0]) ?\n        Negative.negate(numerator.args[0].args[0])\n        : numerator.args[0];\n\n  const numeratorSecondArg = NodeType.isParenthesis(numerator.args[1]) ?\n        numerator.args[1].content\n        : numerator.args[1];\n\n  if (!(NodeType.isConstant(numeratorFirstArg) &&\n        NodeType.isConstant(numeratorSecondArg))) {\n    return false;\n  }\n\n  // check for a constant in the denominator,\n  // optionally wrapped in parenthesis\n  const denominatorValue = NodeType.isParenthesis(denominator) ?\n        denominator.content\n        : denominator;\n\n  if (!NodeType.isConstant(denominatorValue)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Returns true if the mixed number is negative,\n// in which case we have to ignore the negative while converting to an\n// improper fraction, and instead we negate the whole thing at the end\n// e.g. -1 2/3 !== ((-1 * 3) + 2)/3 = -1/3\n//      -1 2/3 == -((1 * 3) + 2)/3 = -5/2\nfunction isNegativeMixedNumber(node) {\n  if (!isMixedNumber(node)) {\n    throw Error('Expected a mixed number');\n  }\n\n  return NodeType.isUnaryMinus(node.args[0].args[0]);\n}\n\n// Get the whole number part of a mixed number\n// e.g. 1 2/3 -> 1\n// Negatives are ignored; e.g. -1 2/3 -> 1\nfunction getWholeNumberValue(node) {\n  if (!isMixedNumber(node)) {\n    throw Error('Expected a mixed number');\n  }\n\n  const wholeNumberNode = NodeType.isUnaryMinus(node.args[0].args[0]) ?\n        node.args[0].args[0].args[0]\n        : node.args[0].args[0];\n\n  return parseInt(wholeNumberNode.value);\n}\n\n// Get the numerator part of a mixed number\n// e.g. 1 2/3 -> 2\nfunction getNumeratorValue(node) {\n  if (!isMixedNumber(node)) {\n    throw Error('Expected a mixed number');\n  }\n\n  const numeratorNode = NodeType.isParenthesis(node.args[0].args[1]) ?\n        node.args[0].args[1].content\n        : node.args[0].args[1];\n\n  return parseInt(numeratorNode.value);\n}\n\n// Get the denominator part of a mixed number\n// e.g. 1 2/3 -> 3\nfunction getDenominatorValue(node) {\n  if (!isMixedNumber(node)) {\n    throw Error('Expected a mixed number');\n  }\n\n  const denominatorNode = NodeType.isParenthesis(node.args[1]) ?\n        node.args[1].content\n        : node.args[1];\n\n  return parseInt(denominatorNode.value);\n}\n\nmodule.exports = {\n  isMixedNumber,\n  isNegativeMixedNumber,\n  getWholeNumberValue,\n  getNumeratorValue,\n  getDenominatorValue\n};\n","const NodeType = require('./Type');\nconst Term = require('./Term');\n\n// For storing nth root terms, which are a subclass of Term\n// where the base node is an nth root\nclass NthRootTerm extends Term {\n  constructor(node, onlyImplicitMultiplication=false) {\n    super(node, NthRootTerm.baseNodeFunc, onlyImplicitMultiplication);\n  }\n}\n\n// Returns true if the term has a base node that makes it an nth root term\n// e.g. 4x^2 has a base of x, so it is not an nth root term\n// 4*sqrt(x)^2 has a base of sqrt(x), so it is an nth root term\nNthRootTerm.baseNodeFunc = function(node) {\n  return NodeType.isFunction(node, 'nthRoot');\n};\n\n// Returns true if the node represents an nth root term.\n// e.g. nthRoot(4), nthRoot(x^2), 4*nthRoot(10)^2\nNthRootTerm.isNthRootTerm = function(\n  node, onlyImplicitMultiplication=false) {\n  return Term.isTerm(\n    node, NthRootTerm.baseNodeFunc, onlyImplicitMultiplication);\n};\n\nmodule.exports = NthRootTerm;\n","const ChangeTypes = require('../ChangeTypes');\nconst Type = require('./Type');\n\n// This represents the current (sub)expression we're simplifying.\n// As we move step by step, a node might be updated. Functions return this\n// status object to pass on the updated node and information on if/how it was\n// changed.\n// Status(node) creates a Status object that signals no change\nclass Status {\n  constructor(changeType, oldNode, newNode, substeps=[]) {\n    if (!newNode) {\n      throw Error('node is not defined');\n    }\n    if (changeType === undefined || typeof(changeType) !== 'string') {\n      throw Error('changetype isn\\'t valid');\n    }\n\n    this.changeType = changeType;\n    this.oldNode = oldNode;\n    this.newNode = newNode;\n    this.substeps = substeps;\n  }\n\n  hasChanged() {\n    return this.changeType !== ChangeTypes.NO_CHANGE;\n  }\n}\n\nStatus.resetChangeGroups = function(node) {\n  node = node.cloneDeep();\n  node.filter(node => node.changeGroup).forEach(change => {\n    delete change.changeGroup;\n  });\n  return node;\n};\n\n// A wrapper around the Status constructor for the case where node hasn't\n// been changed.\nStatus.noChange = function(node) {\n  return new Status(ChangeTypes.NO_CHANGE, null, node);\n};\n\n// A wrapper around the Status constructor for the case of a change\n// that is happening at the level of oldNode + newNode\n// e.g. 2 + 2 --> 4 (an addition node becomes a constant node)\nStatus.nodeChanged = function(\n  changeType, oldNode, newNode, defaultChangeGroup=true, steps=[]) {\n  if (defaultChangeGroup) {\n    oldNode.changeGroup = 1;\n    newNode.changeGroup = 1;\n  }\n\n  return new Status(changeType, oldNode, newNode, steps);\n};\n\n// A wrapper around the Status constructor for the case where there was\n// a change that happened deeper `node`'s tree, and `node`'s children must be\n// updated to have the newNode/oldNode metadata (changeGroups)\n// e.g. (2 + 2) + x --> 4 + x has to update the left argument\nStatus.childChanged = function(node, childStatus, childArgIndex=null) {\n  const oldNode = node.cloneDeep();\n  const newNode = node.cloneDeep();\n  let substeps = childStatus.substeps;\n\n  if (!childStatus.oldNode) {\n    throw Error ('Expected old node for changeType: ' + childStatus.changeType);\n  }\n\n  function updateSubsteps(substeps, fn) {\n    substeps.map((step) => {\n      step = fn(step);\n      step.substeps = updateSubsteps(step.substeps, fn);\n    });\n    return substeps;\n  }\n\n  if (Type.isParenthesis(node)) {\n    oldNode.content = childStatus.oldNode;\n    newNode.content = childStatus.newNode;\n    substeps = updateSubsteps(substeps, (step) => {\n      const oldNode = node.cloneDeep();\n      const newNode = node.cloneDeep();\n      oldNode.content = step.oldNode;\n      newNode.content = step.newNode;\n      step.oldNode = oldNode;\n      step.newNode = newNode;\n      return step;\n    });\n  }\n  else if ((Type.isOperator(node) || Type.isFunction(node) &&\n            childArgIndex !== null)) {\n    oldNode.args[childArgIndex] = childStatus.oldNode;\n    newNode.args[childArgIndex] = childStatus.newNode;\n    substeps = updateSubsteps(substeps, (step) => {\n      const oldNode = node.cloneDeep();\n      const newNode = node.cloneDeep();\n      oldNode.args[childArgIndex] = step.oldNode;\n      newNode.args[childArgIndex] = step.newNode;\n      step.oldNode = oldNode;\n      step.newNode = newNode;\n      return step;\n    });\n  }\n  else if (Type.isUnaryMinus(node)) {\n    oldNode.args[0] = childStatus.oldNode;\n    newNode.args[0] = childStatus.newNode;\n    substeps = updateSubsteps(substeps, (step) => {\n      const oldNode = node.cloneDeep();\n      const newNode = node.cloneDeep();\n      oldNode.args[0] = step.oldNode;\n      newNode.args[0] = step.newNode;\n      step.oldNode = oldNode;\n      step.newNode = newNode;\n      return step;\n    });\n  }\n  else {\n    throw Error('Unexpected node type: ' + node.type);\n  }\n\n  return new Status(childStatus.changeType, oldNode, newNode, substeps);\n};\n\nmodule.exports = Status;\n","const Creator = require('./Creator');\nconst CustomType = require('./CustomType');\nconst MixedNumber = require('./MixedNumber');\nconst NthRootTerm = require('./NthRootTerm');\nconst PolynomialTerm = require('./PolynomialTerm');\nconst Status = require('./Status');\nconst Term = require('./Term');\nconst Type = require('./Type');\n\nmodule.exports = {\n  Creator,\n  CustomType,\n  MixedNumber,\n  NthRootTerm,\n  PolynomialTerm,\n  Status,\n  Term,\n  Type,\n};\n","const Node = require('../node');\n\n// Returns true if the nodes are terms that can be added together.\n// The nodes need to have the same base and exponent\n// e.g. 2x + 5x, 6x^2 + x^2, nthRoot(4,2) + nthRoot(4,2)\nfunction canAddLikeTermNodes(node, termSubclass) {\n  if (!Node.Type.isOperator(node, '+')) {\n    return false;\n  }\n  const args = node.args;\n  if (!args.every(n => Node.Term.isTerm(n, termSubclass.baseNodeFunc))) {\n    return false;\n  }\n  if (args.length === 1) {\n    return false;\n  }\n\n  const termList = args.map(n => new termSubclass(n));\n\n  // to add terms, they must have the same base *and* exponent\n  const firstTerm = termList[0];\n  const sharedBase = firstTerm.getBaseNode();\n  const sharedExponentNode = firstTerm.getExponentNode(true);\n\n  const restTerms = termList.slice(1);\n  return restTerms.every(term => {\n    const haveSameBase = sharedBase.equals(term.getBaseNode());\n    const exponentNode = term.getExponentNode(true);\n    const haveSameExponent = exponentNode.equals(sharedExponentNode);\n    return haveSameBase && haveSameExponent;\n  });\n}\n\n// Returns true if the nodes are nth roots that can be added together\nfunction canAddLikeTermNthRootNodes(node) {\n  return canAddLikeTermNodes(node, Node.NthRootTerm);\n}\n\n// Returns true if the nodes are polynomial terms that can be added together.\nfunction canAddLikeTermPolynomialNodes(node) {\n  return canAddLikeTermNodes(node, Node.PolynomialTerm);\n}\n\nmodule.exports = {\n  canAddLikeTermNodes,\n  canAddLikeTermNthRootNodes,\n  canAddLikeTermPolynomialNodes,\n};\n","const Node = require('../node');\n\n// Returns true if the node is a constant or can eventually be resolved to\n// a constant.\n// e.g. 2, 2+4, (2+4)^2 would all return true. x + 4 would return false\nfunction resolvesToConstant(node) {\n  if (Node.Type.isOperator(node) || Node.Type.isFunction(node)) {\n    return node.args.every(\n      (child) => resolvesToConstant(child));\n  }\n  else if (Node.Type.isParenthesis(node)) {\n    return resolvesToConstant(node.content);\n  }\n  else if (Node.Type.isConstant(node, true)) {\n    return true;\n  }\n  else if (Node.Type.isSymbol(node)) {\n    return false;\n  }\n  else if (Node.Type.isUnaryMinus(node)) {\n    return resolvesToConstant(node.args[0]);\n  }\n  else {\n    throw Error('Unsupported node type: ' + node.type);\n  }\n}\n\nmodule.exports = resolvesToConstant;\n","const Node = require('../node');\nconst resolvesToConstant = require('./resolvesToConstant.js');\n/*\n  Return true if the equation is of the form factor * factor = 0 or factor^power = 0\n  // e.g (x - 2)^2 = 0, x(x + 2)(x - 2) = 0\n*/\nfunction canFindRoots(equation) {\n  const left = equation.leftNode;\n  const right = equation.rightNode;\n\n  const zeroRightSide = Node.Type.isConstant(right)\n        && parseFloat(right.value) === 0;\n\n  const isMulOrPower = Node.Type.isOperator(left, '*') || Node.Type.isOperator(left, '^');\n\n  if (!(zeroRightSide && isMulOrPower)) {\n    return false;\n  }\n\n  // If the left side of the equation is multiplication, filter out all the factors\n  // that do evaluate to constants because they do not have roots. If the\n  // resulting array is empty, there is no roots to be found. Do a similiar check\n  // for when the left side is a power node.\n  // e.g 2^7 and (33 + 89) do not have solutions when set equal to 0\n\n  if (Node.Type.isOperator(left, '*')) {\n    const factors = left.args.filter(arg => !resolvesToConstant(arg));\n    return factors.length >= 1;\n  }\n  else if (Node.Type.isOperator(left, '^')) {\n    return !resolvesToConstant(left);\n  }\n}\n\nmodule.exports = canFindRoots;\n","const NodeCreator = require('../../node/Creator');\nconst NodeType = require('../../node/Type');\n\n// This module is needed when simplifying multiplication of constant powers\n// as it contains functions to get different parts of the node instead of\n// creating a new class, like polynomialTerm. The functions can return the base\n// and the exponent of the power, it can also check if the node is constant or\n// constant power.\n// e.g 2^10 is an constant power, while x^10 is not\n// e.g 2 is an constant, while x is not\n\n// Returns the base if the node is on power form\n// else returns the node as it is constant.\n// e.g 2^4 returns 2\n// e.g 3 returns 3, since 3 is equal to 3^1 which has a base of 3\nfunction getBaseNode(node) {\n  if (node.args) {\n    return node.args[0];\n  }\n  else {\n    return node;\n  }\n}\n\n// Returns the node that is an exponent to a constant, or a constant node with\n// value 1 if there's no exponent.\n// e.g. on the node representing 2^3, returns a constant node with value 3\n// e.g 3 returns 1, since 3 is equal to 3^1 which has an exponent of 1\nfunction getExponentNode(node) {\n  if (NodeType.isConstant(node)) {\n    return NodeCreator.constant(1);\n  }\n  else {\n    return node.args[1];\n  }\n}\n\n// Checks if the node is an constant or a power with constant base.\n// e.g. 2^3 is a constant power node, 5 is a constant node, x and x^2 are not\nfunction isConstantOrConstantPower(node) {\n  return ((NodeType.isOperator(node, '^') &&\n           NodeType.isConstant(node.args[0])) ||\n          NodeType.isConstant(node));\n}\n\nmodule.exports = {\n  getBaseNode,\n  getExponentNode,\n  isConstantOrConstantPower\n};\n","const ConstantOrPowerTerm = require('../simplifyExpression/collectAndCombineSearch/ConstantOrConstantPower');\nconst Node = require('../node');\n\n// Returns true if node is a multiplication of constant power nodes\n// where you can combine their exponents, e.g. 10^2 * 10^4 * 10 can become 10^7.\n// The node can either be on form c^n or c, as long as c is the same for all.\nfunction canMultiplyLikeTermConstantNodes(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '*') {\n    return false;\n  }\n  const args = node.args;\n  if (!args.every(n => ConstantOrPowerTerm.isConstantOrConstantPower(n))) {\n    return false;\n  }\n\n  // if none of the terms have exponents, return false here,\n  // else e.g. 6*6 will become 6^1 * 6^1 => 6^2\n  if (args.every(arg => !Node.Type.isOperator(arg, '^'))) {\n    return false;\n  }\n\n  const constantTermBaseList = args.map(n => ConstantOrPowerTerm.getBaseNode(n));\n  const firstTerm = constantTermBaseList[0];\n  const restTerms = constantTermBaseList.slice(1);\n  // they're considered like terms if they have the same base value\n  return restTerms.every(term => firstTerm.value === term.value);\n}\n\nmodule.exports = canMultiplyLikeTermConstantNodes;\n","const Node = require('../node');\n\n// Returns true if the nodes are symbolic terms with the same symbol and no\n// coefficients.\nfunction canMultiplyLikeTermPolynomialNodes(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '*') {\n    return false;\n  }\n  const args = node.args;\n  if (!args.every(n => Node.PolynomialTerm.isPolynomialTerm(n))) {\n    return false;\n  }\n  if (args.length === 1) {\n    return false;\n  }\n\n  const polynomialTermList = node.args.map(n => new Node.PolynomialTerm(n));\n  if (!polynomialTermList.every(polyTerm => !polyTerm.hasCoeff())) {\n    return false;\n  }\n\n  const firstTerm = polynomialTermList[0];\n  const restTerms = polynomialTermList.slice(1);\n  // they're considered like terms if they have the same symbol name\n  return restTerms.every(term => firstTerm.getSymbolName() === term.getSymbolName());\n}\n\nmodule.exports = canMultiplyLikeTermPolynomialNodes;\n","// This module deals with getting constant factors, including prime factors\n// and factor pairs of a number\n\nconst ConstantFactors = {};\n\n// Given a number, will return all the prime factors of that number as a list\n// sorted from smallest to largest\nConstantFactors.getPrimeFactors = function(number){\n  let factors = [];\n  if (number < 0) {\n    factors = [-1];\n    factors = factors.concat(ConstantFactors.getPrimeFactors(-1 * number));\n    return factors;\n  }\n\n  const root = Math.sqrt(number);\n  let candidate = 2;\n  if (number % 2) {\n    candidate = 3; // assign first odd\n    while (number % candidate && candidate <= root) {\n      candidate = candidate + 2;\n    }\n  }\n\n  // if no factor found then the number is prime\n  if (candidate > root) {\n    factors.push(number);\n  }\n  // if we find a factor, make a recursive call on the quotient of the number and\n  // our newly found prime factor in order to find more factors\n  else {\n    factors.push(candidate);\n    factors = factors.concat(ConstantFactors.getPrimeFactors(number/candidate));\n  }\n\n  return factors;\n};\n\n// Given a number, will return all the factor pairs for that number as a list\n// of 2-item lists\nConstantFactors.getFactorPairs = function(number){\n  const factors = [];\n\n  const bound = Math.floor(Math.sqrt(Math.abs(number)));\n  for (var divisor = -bound; divisor <= bound; divisor++) {\n    if (divisor === 0) {\n      continue;\n    }\n    if (number % divisor === 0) {\n      const quotient = number / divisor;\n      factors.push([divisor, quotient]);\n    }\n  }\n\n  return factors;\n};\n\nmodule.exports = ConstantFactors;\n","const evaluate = require('./evaluate');\n\nconst Negative = require('../Negative');\nconst Node = require('../node');\n\n/*\nBackground:\n\nExpression trees are commonly parsed as binary trees, and mathjs does this too.\nThat means that a mathjs expression tree likely looks like:\nhttp://collegelabs.co/clabs/nld/images/524px-Expression_Tree.svg.png\n\ne.g. 2+2+2 is parsed by mathjs as 2 + 2+2 (a plus node with children 2 and 2+2)\nHowever...\n1. This is more complicated than needed. 2+2+2 is the same as 2+(2+2)\n2. To collect like terms, we actually *need* it to be flat. e.g. with 2x+(2+2x),\n   there's no easy way to know that there are two 2x's to collect without\n   running up and down the tree. If we flatten to 2x+2+2x, it becomes a lot\n   easier to collect like terms to (2x+2x) + 2, which would then be combined to\n   4x + 2\nThe purpose of flatteOperands is to flatten the tree in this way.\n\ne.g. an expression that is grouped in the tree like\n(2 + ((4 * ((1 + 2) + (3 + 4))) * 8))\nshould be flattened to look like:\n(2 + (4 * (1 + 2 + 3 + 4) * 8))\n\nSubtraction and division are also flattened, though that gets a bit more\ncomplicated and you may as well start reading through the code if you're\ninterested in how that works\n*/\n\n// Flattens the tree accross the same operation (just + and * for now)\n// e.g. 2+2+2 is parsed by mathjs as 2+(2+2), but this would change that to\n// 2+2+2, ie one + node that has three children.\n// Input: an expression tree\n// Output: the expression tree updated with flattened operations\nfunction flattenOperands(node) {\n  // If the node is a mixed number, do not perform any flattening\n  // -- Flattening will take out the implicit multiplication, and so\n  //    it will be impossible to tell if the node is a mixed number or\n  //    if it is legitimate multiplication\n  // -- Converting fractions happens before any other simplification step,\n  //    so the tree *will* get flattened before any other changes happen\n  if (Node.MixedNumber.isMixedNumber(node)) {\n    return node;\n  }\n\n  if (Node.Type.isConstant(node, true)) {\n    // the evaluate() changes unary minuses around constant nodes to constant nodes\n    // with negative values.\n    const constNode = Node.Creator.constant(evaluate(node));\n    if (node.changeGroup) {\n      constNode.changeGroup = node.changeGroup;\n    }\n    return constNode;\n  }\n  else if (Node.Type.isOperator(node)) {\n    if ('+-/*'.includes(node.op)) {\n      let parentOp;\n      if (node.op === '/') {\n        // Division is flattened in partner with multiplication. This means\n        // that after collecting the operands, they'll be children args of *\n        parentOp = '*';\n      }\n      else if (node.op === '-') {\n        // Subtraction is flattened in partner with addition, This means that\n        // after collecting the operands, they'll be children args of +\n        parentOp = '+';\n      }\n      else {\n        parentOp = node.op;\n      }\n      return flattenSupportedOperation(node, parentOp);\n    }\n    // If the operation is not supported, just recurse on the children\n    else {\n      node.args.forEach((child, i) => {\n        node.args[i] = flattenOperands(child);\n      });\n    }\n    return node;\n  }\n  else if (Node.Type.isParenthesis(node)) {\n    node.content = flattenOperands(node.content);\n    return node;\n  }\n  else if (Node.Type.isUnaryMinus(node)) {\n    const arg = flattenOperands(node.args[0]);\n    const flattenedNode = Negative.negate(arg, true);\n    if (node.changeGroup) {\n      flattenedNode.changeGroup = node.changeGroup;\n    }\n    return flattenedNode;\n  }\n  else if (Node.Type.isFunction(node) && node.fn.args) {\n    // node.fn.args will only be populated in the case where a function node is\n    // followed by a node in parenthesis\n    // mathjs parses this incorrectly; we want to convert the node to be\n    // multiplication between the function and the node in parenthesis\n    // e.g. nthRoot(11)(x+y) -> nthRoot(11) * (x+y)\n    //      abs(3)(1+2) -> abs(3) * (1+2)\n    const flattenedFn = flattenOperands(node.fn); // e.g. nthRoot(11)\n    const flattenedArg = flattenOperands(node.args[0]); // e.g. x+y\n    const newNode = Node.Creator.operator(\n      '*', [flattenedFn, Node.Creator.parenthesis(flattenedArg)]);\n    return newNode;\n  }\n  else if (Node.Type.isFunction(node, 'abs')) {\n    node.args[0] = flattenOperands(node.args[0]);\n    return node;\n  }\n  else if (Node.Type.isFunction(node, 'nthRoot')) {\n    node.args[0] = flattenOperands(node.args[0]);\n    if (node.args[1]) {\n      node.args[1] = flattenOperands(node.args[1]);\n    }\n    return node;\n  }\n  else {\n    return node;\n  }\n}\n\n// Flattens operations (see flattenOperands docstring) for an operator node\n// with an operation type that can be flattened. Currently * + / are supported.\n// Returns the updated, flattened node.\n// NOTE: the returned node will be of operation type `parentOp`, regardless of\n// the operation type of `node`, unless `node` wasn't changed\n// e.g. 2 * 3 / 4 would be * of 2 and 3/4, but 2/3 would stay 2/3 and division\nfunction flattenSupportedOperation(node, parentOp) {\n  // First get the list of operands that this operator operates on.\n  // e.g. 2 + 3 + 4 + 5 is stored as (((2 + 3) + 4) + 5) in the tree and we\n  // want to get the list [2, 3, 4, 5]\n  const operands = getOperands(node, parentOp);\n\n  // If there's only one operand (possible if 2*x was flattened to 2x)\n  // then it's no longer an operation, so we should replace the node\n  // with the one operand.\n  if (operands.length === 1) {\n    node = operands[0];\n  }\n  else {\n    // When we are dealing with flattening division, and there's also\n    // multiplication involved, we might end up with a top level * instead.\n    // e.g. 2*4/5 is parsed with / at the top, but in the end we want 2 * (4/5)\n    // Check for this by first checking if we have more than two operands\n    // (which is impossible for division), then by recursing through the\n    // original tree for any multiplication node - if there was one, it would\n    // have ended up at the root.\n    if (node.op === '/' && (operands.length > 2 ||\n                            hasMultiplicationBesideDivision(node))) {\n      node = Node.Creator.operator('*', operands);\n    }\n    // similarily, - will become + always\n    else if (node.op === '-') {\n      node = Node.Creator.operator('+', operands);\n    }\n    // otherwise keep the operator, replace operands\n    else {\n      node.args = operands;\n    }\n    // When we collect operands to flatten multiplication, the\n    // multiplication of those operands should never be implicit\n    if (node.op === '*') {\n      node.implicit = false;\n    }\n  }\n  return node;\n}\n\n// Recursively finds the operands under `parentOp` in the input tree `node`.\n// The input tree `node` will always have a parent that is an operation\n// of type `op`.\n// Op is a string e.g. '+' or '*'\n// returns the list of all the node operated on by `parentOp`\nfunction getOperands(node, parentOp) {\n  // We can only recurse on operations of type op.\n  // If the node is not an operator node or of the right operation type,\n  // we can't break up or flatten this tree any further, so we return just\n  // the current node, and recurse on it to flatten its ops.\n  if (!Node.Type.isOperator(node)) {\n    return [flattenOperands(node)];\n  }\n  switch (node.op) {\n  // division is part of flattening multiplication\n  case '*':\n  case '/':\n    if (parentOp !== '*') {\n      return [flattenOperands(node)];\n    }\n    break;\n  case '+':\n  case '-':\n    if (parentOp !== '+') {\n      return [flattenOperands(node)];\n    }\n    break;\n  default:\n    return [flattenOperands(node)];\n  }\n  if (Node.PolynomialTerm.isPolynomialTerm(node, true)) {\n    node.args.forEach((arg, i) => {\n      node.args[i] = flattenOperands(node.args[i]);\n    });\n    return [node];\n  }\n\n  // If we're flattening over *, check for a polynomial term (ie a\n  // coefficient multiplied by a symbol such as 2x^2 or 3y)\n  // This is true if there's an implicit multiplication and the right operand\n  // is a symbol or a symbol to an exponent.\n  else if (parentOp === '*' && isPolynomialTermMultiplication(node)) {\n    return maybeFlattenPolynomialTerm(node);\n  }\n  else if (parentOp === '*' && node.op === '/') {\n    return flattenDivision(node);\n  }\n  else if (node.op === '-') {\n    // this operation will become addition e.g. 2 - 3 -> 2 + -(-3)\n    const secondOperand = node.args[1];\n    const negativeSecondOperand = Negative.negate(secondOperand, true);\n    const operands = [\n      getOperands(node.args[0], parentOp),\n      getOperands(negativeSecondOperand, parentOp)\n    ];\n    return [].concat.apply([], operands);\n  }\n  else {\n    const operands = [];\n    node.args.forEach((child) => {\n      // This will make an array of arrays\n      operands.push(getOperands(child, parentOp));\n    });\n    return [].concat.apply([], operands);\n  }\n}\n\n// Return true iff node is a candidate for simplifying to a polynomial\n// term. This function is a helper function for getOperands.\n// Context: Usually we'd flatten 2*2*x to a multiplication node with 3 children\n// (2, 2, and x) but if we got 2*2x, we want to keep 2x together.\n// 2*2*x (a tree stored in two levels because initially nodes only have two\n// children) in the flattening process should be turned into 2*2x instead of\n// 2*2*x (which has three children).\n// So this function would return true for the input 2*2x, if it was stored as\n// an expression tree with root node * and children 2*2 and x\nfunction isPolynomialTermMultiplication(node) {\n  // This concept only applies when we're flattening multiplication operations\n  if (node.op !== '*') {\n    return false;\n  }\n  // This only makes sense when we're flattening two arguments\n  if (node.args.length !== 2) {\n    return false;\n  }\n  // The second node should be for the form x or x^2 (ie a polynomial term\n  // with no coefficient)\n  const secondOperand = node.args[1];\n  if (Node.PolynomialTerm.isPolynomialTerm(secondOperand)) {\n    const polyNode = new Node.PolynomialTerm(secondOperand);\n    return !polyNode.hasCoeff();\n  }\n  else {\n    return false;\n  }\n}\n\n// Takes a node that might represent a multiplication with a polynomial term\n// and flattens it appropriately so the coefficient and symbol are grouped\n// together. Returns a new list of operands from this node that should be\n// multiplied together.\nfunction maybeFlattenPolynomialTerm(node) {\n  // We recurse on the left side of the tree to find operands so far\n  const operands = getOperands(node.args[0], '*');\n\n  // If the last operand (so far) under * was a constant, then it's a\n  // polynomial term.\n  // e.g. 2*5*6x creates a tree where the top node is implicit multiplcation\n  // and the left branch goes to the tree with 2*5*6, and the right operand\n  // is the symbol x. We want to check that the last argument on the left (in\n  // this example 6) is a constant.\n  const lastOperand = operands.pop();\n\n  // in the above example, node.args[1] would be the symbol x\n  const nextOperand = flattenOperands(node.args[1]);\n\n  // a coefficient can be constant or a fraction of constants\n  if (Node.Type.isConstantOrConstantFraction(lastOperand)) {\n    // we replace the constant (which we popped) with constant*symbol\n    operands.push(\n      Node.Creator.operator('*', [lastOperand, nextOperand], false));\n  }\n  // Now we know it isn't a polynomial term, it's just another seperate operand\n  else {\n    operands.push(lastOperand);\n    operands.push(nextOperand);\n  }\n  return operands;\n}\n\n// Takes a division node and returns a list of operands\n// If there is multiplication in the numerator, the operands returned\n// are to be multiplied together. Otherwise, a list of length one with\n// just the division node is returned. getOperands might change the\n// operator accordingly.\nfunction flattenDivision(node) {\n  // We recurse on the left side of the tree to find operands so far\n  // Flattening division is always considered part of a bigger picture\n  // of multiplication, so we get operands with '*'\n  let operands = getOperands(node.args[0], '*');\n\n  if (operands.length === 1) {\n    node.args[0] = operands.pop();\n    node.args[1] = flattenOperands(node.args[1]);\n    operands = [node];\n  }\n  else {\n    // This is the last operand, the term we'll want to add our division to\n    const numerator = operands.pop();\n    // This is the denominator of the current division node we're recursing on\n    const denominator = flattenOperands(node.args[1]);\n    // Note that this means 2 * 3 * 4 / 5 / 6 * 7 will flatten but keep the 4/5/6\n    // as an operand - in simplifyDivision.js this is changed to 4/(5*6)\n    const divisionNode = Node.Creator.operator('/', [numerator, denominator]);\n    operands.push(divisionNode);\n  }\n\n  return operands;\n}\n\n// Returns true if there is a * node nested in some division, with no other\n// operators or parentheses between them.\n// e.g. returns true: 2*3/4, 2 / 5 / 6 * 7 / 8\n// e.g. returns false: 3/4/5, ((3*2) - 5) / 7, (2*5)/6\nfunction hasMultiplicationBesideDivision(node) {\n  if (!Node.Type.isOperator(node)) {\n    return false;\n  }\n  if (node.op === '*') {\n    return true;\n  }\n  // we ony recurse through division\n  if (node.op !== '/') {\n    return false;\n  }\n  return node.args.some(hasMultiplicationBesideDivision);\n}\n\nmodule.exports = flattenOperands;\n","\nfunction cloneDeepWithChangeGroup(node) {\n  const cloned = node.cloneDeep();\n\n  const originalList = [];\n  const cloneList = [];\n\n  node.traverse((n) => originalList.push(n));\n  cloned.traverse((n) => cloneList.push(n));\n\n  for (let i = 0; i < originalList.length; i++) {\n    const src = originalList[i];\n    const dst = cloneList[i];\n\n    if (Object.prototype.hasOwnProperty.call(src, 'changeGroup')) {\n      dst.changeGroup = src.changeGroup; // copie brute\n    }\n  }\n  return cloned;\n}\n\nmodule.exports = cloneDeepWithChangeGroup;","const math = require('../node/MathjsInstance');\nconst cloneDeepWithChangeGroup = require('./cloneDeepWithChangGroup');\n\n/**\n * Multiplication implicite:\n * 2*x devient 2x \n * 2*(x+3) devient 2(x+3)\n * 2*x^2 devient 2x^2\n * @param {MathNode} node \n * @returns {MathNode}\n */\nfunction setImplicityMultiplySign(node) {\n    const copy = cloneDeepWithChangeGroup(node)\n    let modif = false;  \n    copy.transform(function (nodeChild, path, parent) {\n        if (nodeChild.type === 'OperatorNode' && nodeChild.op === '*') {\n            if (\n                (nodeChild.args[1].type === 'ParenthesisNode' || nodeChild.args[1].type === 'SymbolNode') ||\n                (nodeChild.args[1].type === 'OperatorNode' && nodeChild.args[1].op === '^' && nodeChild.args[1].args[0].type === 'SymbolNode')\n            ) {\n                nodeChild.implicit = true;\n                modif = true;  \n            }\n            if (nodeChild.args[1].isOperatorNode && nodeChild.args[1].op === '^' && nodeChild.args[1].args[0].isSymbolNode) {\n                nodeChild.args[1].implicit = true;\n                modif = true;\n            }\n        }\n        return nodeChild;\n    });\n    // if (modif) console.log('Found multiplication et modification:', copy.toString());\n    return copy;\n}\n\nmodule.exports = setImplicityMultiplySign;\n","const { Creator, PolynomialTerm } = require('../node');\nconst NodeType = require('../node/Type');\n\nfunction isNegatifTerm(node){\n    if (PolynomialTerm.isPolynomialTerm(node)) {\n        const polyTerm = new PolynomialTerm(node);\n        const aValue = polyTerm.getCoeffValue();\n        if (aValue < 0) {\n            return true;\n        }\n    }\n    return false\n}\n\n\n/**\n * @param {MathNode} node \n * @returns {MathNode}\n */\nfunction addParenthesis(node) {\n    const copy = node.cloneDeep()\n    let modif = false;  \n    copy.transform(function (nodeChild, path, parent) {\n        if (nodeChild.type === 'OperatorNode' && nodeChild.op === '*') {\n            if (\n                (NodeType.isUnaryMinus(nodeChild.args[1]) ||\n                (NodeType.isConstant(nodeChild.args[1]) && nodeChild.args[1].value < 0) ||\n                isNegatifTerm(nodeChild.args[1]) ||\n                (NodeType.isOperator(nodeChild.args[1]) && (nodeChild.args[1].op === '+' || nodeChild.args[1].op === '-')))\n            ) {\n                const paren = Creator.parenthesis(nodeChild.args[1])\n                nodeChild.args[1] = paren\n                modif = true\n            }\n        } else if (nodeChild.type === 'OperatorNode' && nodeChild.op === '^') {\n            if (\n                (NodeType.isUnaryMinus(nodeChild.args[0])) ||\n                (NodeType.isConstantOrConstantFraction(nodeChild.args[0]) && nodeChild.args[0].value < 0) ||\n                (NodeType.isOperator(nodeChild.args[0]))\n            ) {\n                const paren = Creator.parenthesis(nodeChild.args[0])\n                nodeChild.args[0] = paren\n                modif = true\n            }\n        }\n        return nodeChild;\n    });\n    // if (modif) console.log('Found multiplication et modification:', copy.toString());\n    return copy;\n}\n\nmodule.exports = addParenthesis;\n","const flatten = require('./flattenOperands');\nconst Node = require('../node');\nconst math = require('../node/MathjsInstance');\nconst setImplicityMultiplySign = require('./setImplicitMultiply');\nconst addParenthesis = require('./addParenthesis');\n\n// Prints an expression node in asciimath\n// If showPlusMinus is true, print + - (e.g. 2 + -3)\n// If it's false (the default) 2 + -3 would print as 2 - 3\n// (The + - is needed to support the conversion of subtraction to addition of\n// negative terms. See flattenOperands for more details if you're curious.)\nfunction printAscii(node, showPlusMinus=false, forceMultiplySign=false, flattenUsed=true, forceAddParenthesis=false) {\n  if (flattenUsed) {\n    node = flatten(node.cloneDeep());\n  } else {\n    node = (node.cloneDeep());\n  }\n  if (forceMultiplySign) {\n    node.transform(function (child, path, parent) {\n      // Vrifie si on est sur un noeud d'oprateur \"^\"\n      if (child.isOperatorNode && child.op === '*') {\n        child.implicit = false;\n      }\n      return child;\n    });\n  }\n  if (forceAddParenthesis) {\n    node = addParenthesis(node);\n  }\n  let string = printTreeTraversal(node);\n  if (!showPlusMinus) {\n    string = string.replace(/\\s*?\\+\\s*?\\-\\s*?/g, ' - ');\n  }\n  if (forceMultiplySign){\n    return math.parse(string).toString({ notation: 'fixed' });\n  } else {\n    return setImplicityMultiplySign(math.parse(string)).toString({ notation: 'fixed' });\n  }\n}\n\nfunction printTreeTraversal(node, parentNode) {\n  if (Node.PolynomialTerm.isPolynomialTerm(node)) {\n    const polyTerm = new Node.PolynomialTerm(node);\n    // This is so we don't print 2/3 x^2 as 2 / 3x^2\n    // Still print x/2 as x/2 and not 1/2 x though\n    if (polyTerm.hasFractionCoeff() && node.op !== '/') {\n      const coeffTerm = polyTerm.getCoeffNode();\n      const coeffStr = printTreeTraversal(coeffTerm);\n\n      const nonCoeffTerm = Node.Creator.polynomialTerm(\n        polyTerm.getSymbolNode(), polyTerm.exponent, null);\n      const nonCoeffStr = printTreeTraversal(nonCoeffTerm);\n\n      return `${coeffStr} ${nonCoeffStr}`;\n    }\n  }\n\n  if (Node.Type.isIntegerFraction(node)) {\n    return `${node.args[0]}/${node.args[1]}`;\n  }\n\n  if (Node.Type.isOperator(node)) {\n    if (node.op === '/' && Node.Type.isOperator(node.args[1])) {\n      return `${printTreeTraversal(node.args[0])} / (${printTreeTraversal(node.args[1])})`;\n    }\n\n    let opString = '';\n\n    switch (node.op) {\n    case '+':\n    case '-':\n      // add space between operator and operands\n      opString = ` ${node.op} `;\n      break;\n    case '*':\n      if (node.implicit) {\n        opString = ' ';\n        break;\n      }\n      opString = ` ${node.op} `;\n      break;\n    case '/':\n      // no space for constant fraction divisions (slightly easier to read)\n      if (Node.Type.isConstantFraction(node, true)) {\n        opString = `${node.op}`;\n      }\n      else {\n        opString = ` ${node.op} `;\n      }\n      break;\n    case '^':\n      // no space for exponents\n      opString = `${node.op}`;\n      break;\n    }\n\n    let str = node.args.map(arg => printTreeTraversal(arg, node)).join(opString);\n\n    // Need to add parens around any [+, -] operation\n    // nested in [/, *, ^] operation\n    // Check #120, #126 issues for more details.\n    // { \"/\" [{ \"+\" [\"x\", \"2\"] }, \"2\"] } -> (x + 2) / 2.\n    if (parentNode &&\n        Node.Type.isOperator(parentNode) &&\n        node.op && parentNode.op &&\n        '*/^'.indexOf(parentNode.op) >= 0 &&\n        '+-'.indexOf(node.op) >= 0) {\n      str = `(${str})`;\n    }\n\n    return str;\n  }\n  else if (Node.Type.isParenthesis(node)) {\n    return `(${printTreeTraversal(node.content)})`;\n  }\n  else if (Node.Type.isUnaryMinus(node)) {\n    if (Node.Type.isOperator(node.args[0]) &&\n        '*/^'.indexOf(node.args[0].op) === -1 &&\n        !Node.PolynomialTerm.isPolynomialTerm(node)) {\n      return `-(${printTreeTraversal(node.args[0])})`;\n    }\n    else {\n      return `-${printTreeTraversal(node.args[0])}`;\n    }\n  }\n  else {\n    return node.toString();\n  }\n}\n\n// Prints an expression node in LaTeX\n// (The + - is needed to support the conversion of subtraction to addition of\n// negative terms. See flattenOperands for more details if you're curious.)\nfunction printLatex(node, showPlusMinus=false, forceMultiplySign=false, flattenUsed=true, forceAddParenthesis=false, postAction) {\n  if (flattenUsed) {\n    node = flatten(node.cloneDeep());\n  } else {\n    node = (node.cloneDeep());\n  }\n  if (forceAddParenthesis) {\n    node = addParenthesis(node);\n  }\n  if (forceMultiplySign) {\n    node.transform(function (child, path, parent) {\n      // Vrifie si on est sur un noeud d'oprateur \"^\"\n      if (child.isOperatorNode && child.op === '*') {\n        child.implicit = false;\n      }\n      return child;\n    });\n  } else {\n    node = setImplicityMultiplySign(node);\n  }\n    \n  if (postAction && Array.isArray(postAction)) {\n    postAction.forEach(action => {\n      node = action(node);\n    });\n  }\n\n  let nodeTex = node.toTex({implicit: 'hide', parenthesis: 'keep'});\n\n  if (!showPlusMinus) {\n    // Replaces '+ -' with '-'\n    nodeTex = nodeTex.replace(/\\s*?\\+\\s*?\\-\\s*?/g, ' - ').replaceAll('\\\\frac', '\\\\dfrac').replaceAll('\\\\cdot', '\\\\times ');\n    \n  }\n  nodeTex = nodeTex.replace(/~/g, ' ').replace(/ {2,}/g, ' ');\n  return nodeTex;\n}\n\nmodule.exports = {\n  ascii: printAscii,\n  latex: printLatex,\n};\n","const math = require('../../node/MathjsInstance');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst ConstantFactors = require('../../factor/ConstantFactors');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\nconst print = require('../../util/print');\n\n// Evaluate nthRoot() function.\n// Returns a Node.Status object.\nfunction nthRoot(node) {\n  if (!Node.Type.isFunction(node, 'nthRoot')) {\n    return Node.Status.noChange(node);\n  }\n\n  const radicandNode = getRadicandNode(node);\n\n  if (Node.Type.isOperator(radicandNode)) {\n    if (radicandNode.op === '^') {\n      return nthRootExponent(node);\n    }\n    else if (radicandNode.op === '*') {\n      return nthRootMultiplication(node);\n    }\n  }\n  else if (Node.Type.isConstant(radicandNode)) {\n    return nthRootConstant(node);\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Returns the nthRoot evaluated for an exponent node. Expects an exponent under\n// the radicand. Cancels the root and the exponent if possible. Three cases:\n// equal: nthRoot(2^x, x) = 2\n// root > exponent: nthRoot(x^2, 4) = nthRoot(x, 2)\n// exponent > root: nthRoot(x^4, 2) = x^2\nfunction nthRootExponent(node) {\n  let newNode = node.cloneDeep();\n\n  const radicandNode = getRadicandNode(node);\n  const rootNode = getRootNode(node);\n  const baseNode = radicandNode.args[0];\n  const exponentNode = Node.Type.isParenthesis(radicandNode.args[1])\n        ? radicandNode.args[1].content\n        : radicandNode.args[1];\n  if (rootNode.equals(exponentNode)) {\n    newNode = baseNode;\n    return Node.Status.nodeChanged(\n      ChangeTypes.CANCEL_EXPONENT_AND_ROOT, node, newNode);\n  }\n  else if (Node.Type.isConstant(rootNode) && Node.Type.isConstant(exponentNode)) {\n    const rootValue = parseFloat(rootNode.value);\n    const exponentValue = parseFloat(exponentNode.value);\n    if (rootValue % exponentValue === 0) {\n      const newRootValue = rootValue/exponentValue;\n      const newRootNode = Node.Creator.constant(newRootValue);\n\n      newNode = Node.Creator.nthRoot(baseNode, newRootNode);\n      return Node.Status.nodeChanged(\n        ChangeTypes.CANCEL_EXPONENT, node, newNode);\n    }\n    else if (exponentValue % rootValue === 0) {\n      const newExponentValue = exponentValue/rootValue;\n      const newExponentNode = Node.Creator.constant(newExponentValue);\n\n      newNode = Node.Creator.operator('^', [baseNode, newExponentNode]);\n      return Node.Status.nodeChanged(\n        ChangeTypes.CANCEL_ROOT, node, newNode);\n    }\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Returns the nthRoot evaluated for a multiplication node.\n// Expects a multiplication node uder the radicand.\n// If the root is a positive constant, it:\n//  1A: factors the multiplicands\n//  1B: groups them into groups whose length is the root value\n//  1C: converts the multiplications into exponents.\n// If it's possible to simplify further, it:\n//  2A: Distributes the nthRoot into the children nodes,\n//  2B: evaluates those nthRoots\n//  2C: combines them\nfunction nthRootMultiplication(node) {\n  let newNode = node.cloneDeep();\n  const rootNode = getRootNode(node);\n\n  const substeps = [];\n  let status;\n  if (Node.Type.isConstant(rootNode) && !Negative.isNegative(rootNode)) {\n    // Step 1A\n    status = factorMultiplicands(newNode);\n    if (status.hasChanged()) {\n      substeps.push(status);\n      newNode = Node.Status.resetChangeGroups(status.newNode);\n    }\n\n    // Step 1B\n    status = groupTermsByRoot(newNode);\n    if (status.hasChanged()) {\n      substeps.push(status);\n      newNode = Node.Status.resetChangeGroups(status.newNode);\n    }\n\n    // Step 1C\n    status = convertMultiplicationToExponent(newNode);\n    if (status.hasChanged()) {\n      substeps.push(status);\n      newNode = Node.Status.resetChangeGroups(status.newNode);\n      if (newNode.args[0].op === '^') {\n        status = nthRootExponent(newNode);\n        substeps.push(status);\n        return Node.Status.nodeChanged(\n          ChangeTypes.NTH_ROOT_VALUE, node, status.newNode, true, substeps);\n      }\n    }\n  }\n\n  // Step 2A\n  status = distributeNthRoot(newNode);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // Step 2B\n  status = evaluateNthRootForChildren(newNode);\n  if (status.hasChanged()) {\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n\n    // Step 2C\n    status = combineRoots(newNode);\n    if (status.hasChanged()) {\n      substeps.push(status);\n      newNode = Node.Status.resetChangeGroups(status.newNode);\n    }\n\n    return Node.Status.nodeChanged(\n      ChangeTypes.NTH_ROOT_VALUE, node, newNode, true, substeps);\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Given an nthRoot node with a constant positive root, will do the step of\n// factoring all the multiplicands under the radicand\n// e.g. nthRoot(2 * 9 * 5 * 12) = nthRoot(2 * 3 * 3 * 5 * 2 * 2 * 3)\nfunction factorMultiplicands(node) {\n  const newNode = node.cloneDeep();\n  const radicandNode = getRadicandNode(node);\n  let children = [];\n  let factored = false;\n  radicandNode.args.forEach(child => {\n    if (Node.PolynomialTerm.isPolynomialTerm(child)) {\n      const polyTerm = new Node.PolynomialTerm(child);\n      const coeffNode = polyTerm.getCoeffNode();\n      const polyTermNoCoeff = Node.Creator.polynomialTerm(\n        polyTerm.getSymbolNode(), polyTerm.getExponentNode(), null);\n      if (coeffNode) {\n        const factorNodes = getFactorNodes(coeffNode);\n        if (factorNodes.length > 1) {\n          factored = true;\n        }\n        children = children.concat(factorNodes);\n      }\n      children.push(polyTermNoCoeff);\n    }\n    else {\n      const factorNodes = getFactorNodes(child);\n      if (factorNodes.length > 1) {\n        factored = true;\n      }\n      children = children.concat(factorNodes);\n    }\n  });\n\n  if (factored) {\n    newNode.args[0] = Node.Creator.operator('*', children);\n    return Node.Status.nodeChanged(\n      ChangeTypes.FACTOR_INTO_PRIMES, node, newNode);\n  }\n\n  return Node.Status.noChange(node);\n}\n\nfunction getFactorNodes(node) {\n  if (Node.Type.isConstant(node) && !Negative.isNegative(node)) {\n    const value = parseFloat(node.value);\n    const factors = ConstantFactors.getPrimeFactors(value);\n    const factorNodes = factors.map(Node.Creator.constant);\n    return factorNodes;\n  }\n  return [node];\n}\n\n// Given an nthRoot node with a constant positive root, will group the arguments\n// into groups of the root as a step\n// e.g. nthRoot(2 * 2 * 2, 2) -> nthRoot((2 * 2) * 2, 2)\nfunction groupTermsByRoot(node) {\n  let newNode = node.cloneDeep();\n  const radicandNode = getRadicandNode(node);\n  const rootNode = getRootNode(node);\n  const rootValue = parseFloat(rootNode.value);\n\n  radicandNode.args.sort(sortNodes);\n\n  const termStrings = radicandNode.args.map(arg => print.ascii(arg));\n\n\n  // there is nothing to simplify when there are no duplicates of factors in the radicand\n  if ([...new Set(termStrings)].length === termStrings.length) {\n    return Node.Status.noChange(node);\n  }\n\n  // dictionary storing the number of times a constant appears\n  // e.g. 2 * 2 * 2 => {'2': 3} , 2 appears 3 times\n  const count = {};\n\n  radicandNode.args.forEach(arg => {\n    const argString = print.ascii(arg);\n    count[argString] ? count[argString]++ : count[argString] = 1;\n  });\n\n  const termString = Object.keys(count);\n\n  const newTermGroups = termString.map(key => {\n    let leftover = count[key];\n    const term = math.parse(key);\n    const times = rootValue;\n\n    const args = [];\n\n    // Recursively create groups\n    while (leftover - times > 0) {\n      leftover -= times;\n      args.push(Node.Creator.parenthesis(\n        Node.Creator.operator('*', Array(times).fill(term))));\n    }\n\n    // Remaining terms after groups have been created\n    const remainder = leftover === 1\n      ? term\n      : Node.Creator.parenthesis(\n        Node.Creator.operator('*', Array(leftover).fill(term)));\n    args.push(remainder);\n\n    return args;\n  });\n\n  // Compress array of arrays\n  const newTerms = newTermGroups.reduce((acc, val) => acc.concat(val), []);\n\n  const newBase = Node.Creator.operator('*', newTerms);\n\n  newNode = Node.Creator.nthRoot(newBase, rootNode);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.GROUP_TERMS_BY_ROOT, node, newNode);\n}\n\n// Given an nthRoot node with a constant positive root,\n// will convert any grouped factors into exponent nodes as a step\n// e.g. nthRoot((2 * 2) * 2, 2) -> nthRoot(2^2 * 2, 2)\nfunction convertMultiplicationToExponent(node) {\n  const newNode = node.cloneDeep();\n\n  const radicandNode = getRadicandNode(node);\n\n  if (Node.Type.isParenthesis(radicandNode)) {\n    const child = radicandNode.content;\n    if (isMultiplicationOfEqualNodes(child)) {\n      const baseNode = child.args[0];\n      const exponentNode = Node.Creator.constant(child.args.length);\n      newNode.args[0] = Node.Creator.operator('^', [baseNode, exponentNode]);\n      return Node.Status.nodeChanged(\n        ChangeTypes.CONVERT_MULTIPLICATION_TO_EXPONENT, node, newNode);\n    }\n  }\n  else if (Node.Type.isOperator(radicandNode, '*')) {\n    const children = [];\n    radicandNode.args.forEach(child => {\n      if (Node.Type.isParenthesis(child)) {\n        const grandChild = child.content;\n        if (isMultiplicationOfEqualNodes(grandChild)) {\n          const baseNode = grandChild.args[0];\n          const exponentNode = Node.Creator.constant(grandChild.args.length);\n          children.push(Node.Creator.operator('^', [baseNode, exponentNode]));\n          return;\n        }\n      }\n      children.push(child);\n    });\n\n    newNode.args[0] = Node.Creator.operator('*', children);\n    return Node.Status.nodeChanged(\n      ChangeTypes.CONVERT_MULTIPLICATION_TO_EXPONENT, node, newNode);\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Given an nthRoot node with a multiplication under the radicand, will\n// distribute the nthRoot to all the arguments under the radicand as a step\n// e.g. nthRoot(2 * x^2, 2) -> nthRoot(2) * nthRoot(x^2)\nfunction distributeNthRoot(node) {\n  let newNode = node.cloneDeep();\n  const radicandNode = getRadicandNode(node);\n  const rootNode = getRootNode(node);\n\n  const children = [];\n  for (let i = 0; i < radicandNode.args.length; i++) {\n    const child = radicandNode.args[i];\n    children.push(Node.Creator.nthRoot(child, rootNode));\n  }\n\n  newNode = Node.Creator.operator('*', children);\n  return Node.Status.nodeChanged(\n    ChangeTypes.DISTRIBUTE_NTH_ROOT, node, newNode);\n}\n\n// Given a multiplication node of nthRoots (with the same root)\n// will evaluate the nthRoot of each child as a substep\n// e.g. nthRoot(2) * nthRoot(x^2) -> nthRoot(2) * x\nfunction evaluateNthRootForChildren(node) {\n  const newNode = node.cloneDeep();\n\n  const substeps = [];\n  for (let i = 0; i < newNode.args.length; i++) {\n    const child = newNode.args[i];\n    const childNodeStatus = nthRoot(child);\n    if (childNodeStatus.hasChanged()) {\n      newNode.args[i] = childNodeStatus.newNode;\n      substeps.push(Node.Status.childChanged(newNode, childNodeStatus, i));\n    }\n  }\n\n  if (substeps.length === 0) {\n    return Node.Status.noChange(node);\n  }\n  else if (substeps.length === 1) {\n    return substeps[0];\n  }\n  else {\n    return Node.Status.nodeChanged(\n      ChangeTypes.EVALUATE_DISTRIBUTED_NTH_ROOT, node, newNode, true, substeps);\n  }\n}\n\n// Given a multiplication node, with children including nthRoots, will combine\n// the nodes with the same radicand as a step\n// e.g. 2 * nthRoot(2) * nthRoot(x) -> 2 * nthRoot(2 * x)\n// Assumes that all the roots are the same (that this is occuring right\n// after distributeNthRoot and evaluateNthRootForChildren)\nfunction combineRoots(node) {\n  let newNode = node.cloneDeep();\n\n  let rootNode;\n  const children = [];\n  const radicandArgs = [];\n  for (let i = 0; i < newNode.args.length; i++) {\n    const child = newNode.args[i];\n    if (Node.Type.isFunction(child, 'nthRoot')) {\n      radicandArgs.push(child.args[0]);\n      rootNode = getRootNode(child);\n    }\n    else {\n      children.push(child);\n    }\n  }\n\n  if (children.length > 0) {\n    if (radicandArgs.length > 0) {\n      const radicandNode = radicandArgs.length === 1 ?\n        radicandArgs[0] : Node.Creator.operator('*', radicandArgs);\n      children.push(Node.Creator.nthRoot(radicandNode, rootNode));\n    }\n\n    newNode = Node.Creator.operator('*', children);\n    if (!newNode.equals(node)) {\n      return Node.Status.nodeChanged(\n        ChangeTypes.COMBINE_UNDER_ROOT, node, newNode);\n    }\n  }\n\n  // if there are no items moved out of the root, then nothing has changed\n  return Node.Status.noChange(node);\n}\n\n// Returns the nthRoot evaluated on a constant node\n// Potentially factors the constant node into primes, and calls\n// nthRootMultiplication on the new nthRoot\nfunction nthRootConstant(node) {\n  let newNode = node.cloneDeep();\n  const radicandNode = getRadicandNode(node);\n  const rootNode = getRootNode(node);\n\n  if (Negative.isNegative(radicandNode)) {\n    return Node.Status.noChange(node);\n  }\n  else if (!Node.Type.isConstant(rootNode) || Negative.isNegative(rootNode)) {\n    return Node.Status.noChange(node);\n  }\n\n  const radicandValue = parseFloat(radicandNode.value);\n  const rootValue = parseFloat(rootNode.value);\n  const nthRootValue = math.nthRoot(radicandValue, rootValue);\n  const roundedNthRootValue = math.round(nthRootValue);\n  // Perfect root e.g. nthRoot(4, 2) = 2\n  // nthRoot may have round-off error, so we'll check for perfect roots by rounding to the nearest integer\n  // and checking if that value that satisfies the root expression\n  if (math.pow(roundedNthRootValue, rootValue) === radicandValue) {\n    newNode = Node.Creator.constant(roundedNthRootValue);\n    return Node.Status.nodeChanged(\n      ChangeTypes.NTH_ROOT_VALUE, node, newNode);\n  }\n  // Try to find if we can simplify by finding factors that can be\n  // pulled out of the radical\n  else {\n    // convert the number into the product of its prime factors\n    const factors = ConstantFactors.getPrimeFactors(radicandValue);\n    if (factors.length > 1) {\n      let substeps = [];\n      const factorNodes = factors.map(Node.Creator.constant);\n\n      newNode.args[0] = Node.Creator.operator('*', factorNodes);\n      substeps.push(Node.Status.nodeChanged(\n        ChangeTypes.FACTOR_INTO_PRIMES, node, newNode));\n\n      // run nthRoot on the new node\n      const nodeStatus = nthRootMultiplication(newNode);\n      if (nodeStatus.hasChanged()) {\n        substeps = substeps.concat(nodeStatus.substeps);\n        newNode = nodeStatus.newNode;\n\n        return Node.Status.nodeChanged(\n          ChangeTypes.NTH_ROOT_VALUE, node, newNode, true, substeps);\n      }\n    }\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Helpers\n\n// Given an nthRoot node, will return the root node.\n// The root node is the second child of the nthRoot node, but if one doesn't\n// exist, we assume it's a square root and return 2.\nfunction getRootNode(node) {\n  if (!Node.Type.isFunction(node, 'nthRoot')) {\n    throw Error('Expected nthRoot');\n  }\n\n  return node.args.length === 2 ? node.args[1] : Node.Creator.constant(2);\n}\n\n// Given an nthRoot node, will return the radicand node.\nfunction getRadicandNode(node) {\n  if (!Node.Type.isFunction(node, 'nthRoot')) {\n    throw Error('Expected nthRoot');\n  }\n\n  return node.args[0];\n}\n\n// Sorts nodes, ordering constants nodes from smallest to largest and symbol\n// nodes after\nfunction sortNodes(a, b) {\n  if (Node.Type.isConstant(a) && Node.Type.isConstant(b)) {\n    return parseFloat(a.value) - parseFloat(b.value);\n  }\n  else if (Node.Type.isConstant(a)) {\n    return -1;\n  }\n  else if (Node.Type.isConstant(b)) {\n    return 1;\n  }\n  return 0;\n}\n\n// Simple helper function which determines a node is a multiplication node\n// of all equal nodes\nfunction isMultiplicationOfEqualNodes(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '*') {\n    return false;\n  }\n\n  const termStrings = node.args.map(print.ascii);\n\n  // return if they are all equal nodes\n  return [...new Set(termStrings)].length === 1;\n}\n\nmodule.exports = {\n  getRadicandNode,\n  getRootNode,\n  nthRoot,\n};\n","const Node = require('../node');\nconst NthRoot = require('../simplifyExpression/functionsSearch/nthRoot');\n\n// Function to check if nthRoot nodes can be multiplied\n// e.g. nthRoot(x, 2) * nthRoot(x, 2) -> true\n// e.g. nthRoot(x, 2) * nthRoot(x, 3) -> false\nfunction canMultiplyLikeTermsNthRoots(node) {\n  // checks if node is a multiplication of nthRoot nodes\n  // all the terms has to have the same root node to be multiplied\n\n  if (!Node.Type.isOperator(node, '*')\n      || !(node.args.every(term => Node.Type.isFunction(term, 'nthRoot')))){\n    return false;\n  }\n\n  // Take arbitrary root node\n  const firstTerm = node.args[0];\n  const rootNode = NthRoot.getRootNode(firstTerm);\n\n  return node.args.every(\n    term => NthRoot.getRootNode(term).equals(rootNode));\n}\n\nmodule.exports = canMultiplyLikeTermsNthRoots;\n","const Node = require('../node');\n\n// Returns true if the expression is a multiplication between a constant\n// and polynomial without a coefficient.\nfunction canRearrangeCoefficient(node) {\n  // implicit multiplication doesn't count as multiplication here, since it\n  // represents a single term.\n  if (node.op !== '*' || node.implicit) {\n    return false;\n  }\n  if (node.args.length !== 2) {\n    return false;\n  }\n   if (!Node.PolynomialTerm.isPolynomialTerm(node.args[0])) {\n    return false;\n  }\n  const polyNode = new Node.PolynomialTerm(node.args[0]);\n  if ((Node.Type.isParenthesis(node.args[1]) && Node.Type.isConstantOrConstantFraction(node.args[1].content, true))) {\n    return !polyNode.hasCoeff();\n  }\n  if (Node.Type.isConstantOrConstantFraction(node.args[1], true)) {\n    return !polyNode.hasCoeff();\n  }\n  return false;\n}\n\nmodule.exports = canRearrangeCoefficient;\n","const canAddLikeTerms = require('./canAddLikeTerms');\nconst canMultiplyLikeTermPolynomialNodes = require('./canMultiplyLikeTermPolynomialNodes');\nconst canRearrangeCoefficient = require('./canRearrangeCoefficient');\n\n// Returns true if the node is an operation node with parameters that are\n// polynomial terms that can be combined in some way.\nfunction canSimplifyPolynomialTerms(node) {\n  return (canAddLikeTerms.canAddLikeTermPolynomialNodes(node) ||\n          canMultiplyLikeTermPolynomialNodes(node) ||\n          canRearrangeCoefficient(node));\n}\n\nmodule.exports = canSimplifyPolynomialTerms;\n","const Node = require('../node');\nconst resolvesToConstant = require('./resolvesToConstant');\n\nfunction hasUnsupportedNodes(node) {\n  if (Node.Type.isParenthesis(node)) {\n    return hasUnsupportedNodes(node.content);\n  }\n  else if (Node.Type.isUnaryMinus(node)) {\n    return hasUnsupportedNodes(node.args[0]);\n  }\n  else if (Node.Type.isOperator(node)) {\n    return node.args.some(hasUnsupportedNodes);\n  }\n  else if (Node.Type.isSymbol(node) || Node.Type.isConstant(node)) {\n    return false;\n  }\n  else if (Node.Type.isFunction(node, 'abs')) {\n    if (node.args.length !== 1) {\n      return true;\n    }\n    if (node.args.some(hasUnsupportedNodes)) {\n      return true;\n    }\n    return !resolvesToConstant(node.args[0]);\n  }\n  else if (Node.Type.isFunction(node, 'nthRoot')) {\n    return node.args.some(hasUnsupportedNodes) || node.args.length < 1;\n  }\n  else {\n    return true;\n  }\n}\n\nmodule.exports = hasUnsupportedNodes;\n","const Node = require('./node');\n\nconst Symbols = {};\n\n// returns the set of all the symbols in an equation\nSymbols.getSymbolsInEquation = function(equation) {\n  const leftSymbols = Symbols.getSymbolsInExpression(equation.leftNode);\n  const rightSymbols = Symbols.getSymbolsInExpression(equation.rightNode);\n  const symbols = new Set([...leftSymbols, ...rightSymbols]);\n  return symbols;\n};\n\n// return the set of symbols in the expression tree\nSymbols.getSymbolsInExpression = function(expression) {\n  const symbolNodes = expression.filter(node => node.isSymbolNode); // all the symbol nodes\n  const symbols = symbolNodes.map(node => node.name); // all the symbol nodes' names\n  const symbolSet = new Set(symbols); // to get rid of duplicates\n  return symbolSet;\n};\n\n// Iterates through a node and returns the last term with the symbol name\n// Returns null if no terms with the symbol name are in the node.\n// e.g. 4x^2 + 2x + y + 2 with `symbolName=x` would return 2x\nSymbols.getLastSymbolTerm = function(node, symbolName) {\n  // First check if the node itself is a polyomial term with symbolName\n  if (isSymbolTerm(node, symbolName)) {\n    return node;\n  }\n  // If it's a sum of terms, look through the operands for a term\n  // with `symbolName`\n  else if (Node.Type.isOperator(node, '+') || Node.Type.isOperator(node, '*')) {\n    for (let i = node.args.length - 1; i >= 0 ; i--) {\n      const child = node.args[i];\n      if (Node.Type.isOperator(child, '+')) {\n        return Symbols.getLastSymbolTerm(child, symbolName);\n      }\n      else if (isSymbolTerm(child, symbolName)) {\n        return child;\n      }\n    }\n  }\n  else if (Node.Type.isParenthesis(node)) {\n    return Symbols.getLastSymbolTerm(node.content, symbolName);\n  }\n\n  return null;\n};\n\n// Iterates through a node and returns the last term that does not have the\n// symbolName including other polynomial terms, and constants or constant\n// fractions\n// e.g. 4x^2 with `symbolName=x` would return 4\n// e.g. 4x^2 + 2x + 2/4 with `symbolName=x` would return 2/4\n// e.g. 4x^2 + 2x + y with `symbolName=x` would return y\nSymbols.getLastNonSymbolTerm = function(node, symbolName) {\n  if (isPolynomialTermWithSymbol(node, symbolName)) {\n    return new Node.PolynomialTerm(node).getCoeffNode();\n  }\n  else if (hasDenominatorSymbol(node, symbolName)) {\n    return null;\n  }\n  else if (Node.Type.isOperator(node)) {\n    for (let i = node.args.length - 1; i >= 0 ; i--) {\n      const child = node.args[i];\n      if (Node.Type.isOperator(child, '+')) {\n        return Symbols.getLastNonSymbolTerm(child, symbolName);\n      }\n      else if (!isSymbolTerm(child, symbolName)) {\n        return child;\n      }\n    }\n  }\n\n  return null;\n};\n\n// Iterates through a node and returns the denominator if it has a\n// symbolName in its denominator\n// e.g. 1/(2x) with `symbolName=x` would return 2x\n// e.g. 1/(x+2) with `symbolName=x` would return x+2\n// e.g. 1/(x+2) + (x+1)/(2x+3) with `symbolName=x` would return (2x+3)\nSymbols.getLastDenominatorWithSymbolTerm = function(node, symbolName) {\n  // First check if the node itself has a symbol in the denominator\n  if (hasDenominatorSymbol(node, symbolName)) {\n    return node.args[1];\n  }\n  // Otherwise, it's a sum of terms. e.g. 1/x + 1(2+x)\n  // Look through the operands for a\n  // denominator term with `symbolName`\n  else if (Node.Type.isOperator(node, '+')) {\n    for (let i = node.args.length - 1; i >= 0 ; i--) {\n      const child = node.args[i];\n      if (Node.Type.isOperator(child, '+')) {\n        return Symbols.getLastDenominatorWithSymbolTerm(child, symbolName);\n      }\n      else if (hasDenominatorSymbol(child, symbolName)) {\n        return child.args[1];\n      }\n    }\n  }\n  return null;\n};\n\n// Returns if `node` is a term with symbol `symbolName`\nfunction isSymbolTerm(node, symbolName) {\n  return isPolynomialTermWithSymbol(node, symbolName) ||\n    hasDenominatorSymbol(node, symbolName);\n}\n\nfunction isPolynomialTermWithSymbol(node, symbolName) {\n  if (Node.PolynomialTerm.isPolynomialTerm(node)) {\n    const polyTerm = new Node.PolynomialTerm(node);\n    if (polyTerm.getSymbolName() === symbolName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Return if `node` has a symbol in its denominator\n// e.g. true for 1/(2x)\n// e.g. false for 5x\nfunction hasDenominatorSymbol(node, symbolName) {\n  if (Node.Type.isOperator(node) && node.op === '/') {\n    const allSymbols = Symbols.getSymbolsInExpression(node.args[1]);\n    return allSymbols.has(symbolName);\n  }\n\n  return false;\n}\n\nmodule.exports = Symbols;\n","const Node = require('../node');\nconst Symbols = require('../Symbols');\n\n// Given a node, will determine if the expression is in the form of a quadratic\n// e.g. `x^2 + 2x + 1` OR `x^2 - 1` but not `x^3 + x^2 + x + 1`\nfunction isQuadratic(node) {\n  if (!Node.Type.isOperator(node, '+')) {\n    return false;\n  }\n\n  if (node.args.length > 3) {\n    return false;\n  }\n\n  // make sure only one symbol appears in the expression\n  const symbolSet = Symbols.getSymbolsInExpression(node);\n  if (symbolSet.size !== 1) {\n    return false;\n  }\n\n  const secondDegreeTerms = node.args.filter(isPolynomialTermOfDegree(2));\n  const firstDegreeTerms = node.args.filter(isPolynomialTermOfDegree(1));\n  const constantTerms = node.args.filter(Node.Type.isConstant);\n\n  // Check that there is one second degree term and at most one first degree\n  // term and at most one constant term\n  if (secondDegreeTerms.length !== 1 || firstDegreeTerms.length > 1 ||\n    constantTerms.length > 1) {\n    return false;\n  }\n\n  // check that there are no terms that don't fall into these groups\n  if ((secondDegreeTerms.length + firstDegreeTerms.length +\n      constantTerms.length) !== node.args.length) {\n    return false;\n  }\n\n  return true;\n}\n\n// Given a degree, returns a function that checks if a node\n// is a polynomial term of the given degree.\nfunction isPolynomialTermOfDegree(degree) {\n  return function(node) {\n    if (Node.PolynomialTerm.isPolynomialTerm(node)) {\n      const polyTerm = new Node.PolynomialTerm(node);\n      const exponent = polyTerm.getExponentNode(true);\n      return exponent && parseFloat(exponent.value) === degree;\n    }\n    return false;\n  };\n}\n\nmodule.exports = isQuadratic;\n","const math = require('../node/MathjsInstance');\n\nconst printNode = require('../util/print');\nconst setImplicityMultiplySign = require('../util/setImplicitMultiply');\n\n// This represents an equation, made up of the leftNode (LHS), the\n// rightNode (RHS) and a comparator (=, <, >, <=, or >=)\nclass Equation {\n  constructor(leftNode, rightNode, comparator) {\n    this.leftNode = setImplicityMultiplySign(leftNode);\n    this.rightNode = setImplicityMultiplySign(rightNode);\n    this.comparator = comparator;\n  }\n\n  // Prints an Equation properly using the print module\n  ascii(showPlusMinus=false, forceMultiplySign=false) {\n    const leftSide = printNode.ascii(this.leftNode, showPlusMinus, forceMultiplySign);\n    const rightSide = printNode.ascii(this.rightNode, showPlusMinus, forceMultiplySign);\n    const comparator = this.comparator;\n\n    return `${leftSide} ${comparator} ${rightSide}`;\n  }\n\n  // Prints an Equation properly using LaTeX\n  latex(showPlusMinus=false) {\n    const leftSide = printNode.latex(this.leftNode, showPlusMinus);\n    const rightSide = printNode.latex(this.rightNode, showPlusMinus);\n    const comparator = this.comparator;\n    return `${leftSide} ${comparator?.replaceAll('>=', '\\\\geqslant')\n            .replaceAll('<=', '\\\\leqslant')} ${rightSide}`;\n  }\n\n  clone() {\n    const newLeft = this.leftNode.cloneDeep();\n    const newRight = this.rightNode.cloneDeep();\n    return new Equation(newLeft, newRight, this.comparator);\n  }\n}\n\n// Splits a string on the given comparator and returns a new Equation object\n// from the left and right hand sides\nEquation.createEquationFromString = function(str, comparator) {\n  const sides = str.split(comparator);\n  if (sides.length !== 2) {\n    throw Error('Expected two sides of an equation using comparator: ' +\n      comparator);\n  }\n  const leftNode = math.parse(sides[0]);\n  const rightNode = math.parse(sides[1]);\n\n  return new Equation(leftNode, rightNode, comparator);\n};\n\nmodule.exports = Equation;\n","const Equation = require('../equation/Equation.js');\nconst Node = require('../node/index.js');\n\n/**\n * Returns true if the equation is a proportion that can be solved\n * by cross multiplication, e.g. 3/x = 8/9\n * @param {Equation} equation\n * @returns {boolean}\n */\nfunction canCrossMultiplication(equation) {\n  if (equation.comparator !== '=') return false;\n\n  const left = equation.leftNode;\n  const right = equation.rightNode;\n\n  const isDivide = Node.Type.isOperator(left, '/') && Node.Type.isOperator(right, '/');\n\n  if (!(isDivide)) {\n    return false;\n  }\n\n  // 2/x = 4/9 => return true\n  // x/2 = 4/9 => return false\n  // 2/(7x) = 4/9 => return true\n  if (Node.Type.isConstantOrConstantFraction(left.args[0]) &&\n       Node.PolynomialTerm.isPolynomialTerm(left.args[1]) &&\n       Node.Type.isConstantOrConstantFraction(right.args[0]) &&\n       Node.Type.isConstantOrConstantFraction(right.args[1])){\n    return true;\n  }\n  // 2/7 = 4/x => return true\n  // 2/2 = x/4 => return false\n  // 4/9 = 2/(7x) => return true\n  if (Node.Type.isConstantOrConstantFraction(left.args[0]) &&\n       Node.Type.isConstantOrConstantFraction(left.args[1]) &&\n       Node.Type.isConstantOrConstantFraction(right.args[0]) &&\n       Node.PolynomialTerm.isPolynomialTerm(right.args[1])){\n    return true;\n  }\n  return false;\n}\n\nmodule.exports = canCrossMultiplication;\n\n","const canAddLikeTerms = require('./canAddLikeTerms');\nconst canFindRoots = require('./canFindRoots');\nconst canMultiplyLikeTermConstantNodes = require('./canMultiplyLikeTermConstantNodes');\nconst canMultiplyLikeTermPolynomialNodes = require('./canMultiplyLikeTermPolynomialNodes');\nconst canMultiplyLikeTermsNthRoots = require('./canMultiplyLikeTermsNthRoots');\nconst canRearrangeCoefficient = require('./canRearrangeCoefficient');\nconst canSimplifyPolynomialTerms = require('./canSimplifyPolynomialTerms');\nconst hasUnsupportedNodes = require('./hasUnsupportedNodes');\nconst isQuadratic = require('./isQuadratic');\nconst resolvesToConstant = require('./resolvesToConstant');\nconst canCrossMultiplication = require('./canCrossMuliplication.js');\n\nmodule.exports = {\n  canFindRoots,\n  canAddLikeTerms,\n  canMultiplyLikeTermConstantNodes,\n  canMultiplyLikeTermPolynomialNodes,\n  canMultiplyLikeTermsNthRoots,\n  canRearrangeCoefficient,\n  canSimplifyPolynomialTerms,\n  hasUnsupportedNodes,\n  isQuadratic,\n  resolvesToConstant,\n  canCrossMultiplication\n};\n","const math = require('../node/MathjsInstance');\n\nconst ConstantFactors = require('./ConstantFactors');\n\nconst ChangeTypes = require('../ChangeTypes');\nconst evaluate = require('../util/evaluate');\nconst Negative = require('../Negative');\nconst Node = require('../node');\n\nconst FACTOR_FUNCTIONS = [\n  // factor just the symbol e.g. x^2 + 2x -> x(x + 2)\n  factorSymbol,\n  // factor difference of squares e.g. x^2 - 4\n  factorDifferenceOfSquares,\n  // factor perfect square e.g. x^2 + 2x + 1\n  factorPerfectSquare,\n  // factor sum product rule e.g. x^2 + 3x + 2\n  factorSumProductRule\n];\n\n// Given a node, will check if it's in the form of a quadratic equation\n// `ax^2 + bx + c`, and\n// if it is, will factor it using one of the following rules:\n//    - Factor out the symbol e.g. x^2 + 2x -> x(x + 2)\n//    - Difference of squares e.g. x^2 - 4 -> (x+2)(x-2)\n//    - Perfect square e.g. x^2 + 2x + 1 -> (x+1)^2\n//    - Sum/product rule e.g. x^2 + 3x + 2 -> (x+1)(x+2)\n//    - TODO: quadratic formula\n//        requires us simplify the following only within the parens:\n//        a(x - (-b + sqrt(b^2 - 4ac)) / 2a)(x - (-b - sqrt(b^2 - 4ac)) / 2a)\nfunction factorQuadratic(node) {\n  // get a, b and c\n  let symbol, aValue = 0, bValue = 0, cValue = 0;\n  for (const term of node.args) {\n    if (Node.Type.isConstant(term)) {\n      cValue = evaluate(term);\n    }\n    else if (Node.PolynomialTerm.isPolynomialTerm(term)) {\n      const polyTerm = new Node.PolynomialTerm(term);\n      const exponent = polyTerm.getExponentNode(true);\n      if (exponent.value === '2' || exponent.value === 2) {\n        symbol = polyTerm.getSymbolNode();\n        aValue = polyTerm.getCoeffValue();\n      }\n      else if (exponent.value === '1' || exponent.value === 1) {\n        bValue = polyTerm.getCoeffValue();\n      }\n      else {\n        return Node.Status.noChange(node);\n      }\n    }\n    else {\n      return Node.Status.noChange(node);\n    }\n  }\n\n  if (!symbol || !aValue) {\n    return Node.Status.noChange(node);\n  }\n\n  let negate = false;\n  if (aValue < 0) {\n    negate = true;\n    aValue = -aValue;\n    bValue = -bValue;\n    cValue = -cValue;\n  }\n\n  for (let i = 0; i < FACTOR_FUNCTIONS.length; i++) {\n    const nodeStatus = FACTOR_FUNCTIONS[i](node, symbol, aValue, bValue, cValue, negate);\n    if (nodeStatus.hasChanged()) {\n      return nodeStatus;\n    }\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Will factor the node if it's in the form of ax^2 + bx\nfunction factorSymbol(node, symbol, aValue, bValue, cValue, negate) {\n  if (!bValue || cValue) {\n    return Node.Status.noChange(node);\n  }\n\n  const gcd = math.gcd(aValue, bValue);\n  const gcdNode = Node.Creator.constant(gcd);\n  const aNode = Node.Creator.constant(aValue/gcd);\n  const bNode = Node.Creator.constant(bValue/gcd);\n\n  const factoredNode = Node.Creator.polynomialTerm(symbol, null, gcdNode);\n  const polyTerm = Node.Creator.polynomialTerm(symbol, null, aNode);\n  const paren = Node.Creator.parenthesis(\n    Node.Creator.operator('+', [polyTerm, bNode]));\n\n  let newNode = Node.Creator.operator('*', [factoredNode, paren], true);\n  if (negate) {\n    newNode = Negative.negate(newNode);\n  }\n\n  return Node.Status.nodeChanged(ChangeTypes.FACTOR_SYMBOL, node, newNode);\n}\n\n// Will factor the node if it's in the form of ax^2 - c, and the aValue\n// and cValue are perfect squares\n// e.g. 4x^2 - 4 -> (2x + 2)(2x - 2)\nfunction factorDifferenceOfSquares(node, symbol, aValue, bValue, cValue, negate) {\n  // check if difference of squares:\n  //    (i) abs(a) and abs(c) are squares,\n  //    (ii) b = 0,\n  //    (iii) c is negative\n  if (bValue || !cValue) {\n    return Node.Status.noChange(node);\n  }\n\n  // we factor out the gcd first, providing us with a modified expression to\n  // factor with new a and c values\n  const gcd = math.gcd(aValue, cValue);\n  aValue = aValue/gcd;\n  cValue = cValue/gcd;\n  const aRootValue = Math.sqrt(Math.abs(aValue));\n  const cRootValue = Math.sqrt(Math.abs(cValue));\n\n  // must be a difference of squares\n  if (Number.isInteger(aRootValue) &&\n      Number.isInteger(cRootValue) &&\n      cValue < 0) {\n\n    const aRootNode = Node.Creator.constant(aRootValue);\n    const cRootNode = Node.Creator.constant(cRootValue);\n\n    const polyTerm = Node.Creator.polynomialTerm(symbol, null, aRootNode);\n    const firstParen = Node.Creator.parenthesis(\n      Node.Creator.operator('+', [polyTerm, cRootNode]));\n    const secondParen = Node.Creator.parenthesis(\n      Node.Creator.operator('-', [polyTerm, cRootNode]));\n\n    // create node in difference of squares form\n    let newNode = Node.Creator.operator('*', [firstParen, secondParen], true);\n    if (gcd !== 1) {\n      const gcdNode = Node.Creator.constant(gcd);\n      newNode = Node.Creator.operator('*', [gcdNode, newNode], true);\n    }\n    if (negate) {\n      newNode = Negative.negate(newNode);\n    }\n\n    return Node.Status.nodeChanged(\n      ChangeTypes.FACTOR_DIFFERENCE_OF_SQUARES, node, newNode);\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Will factor the node if it's in the form of ax^2 + bx + c, where a and c\n// are perfect squares and b = 2*sqrt(a)*sqrt(c)\n// e.g. x^2 + 2x + 1 -> (x + 1)^2\nfunction factorPerfectSquare(node, symbol, aValue, bValue, cValue, negate) {\n  // check if perfect square: (i) a and c squares, (ii) b = 2*sqrt(a)*sqrt(c)\n  if (!bValue || !cValue) {\n    return Node.Status.noChange(node);\n  }\n\n  // we factor out the gcd first, providing us with a modified expression to\n  // factor with new a and c values\n  const gcd = math.gcd(aValue, bValue, cValue);\n  aValue = aValue/gcd;\n  cValue = cValue/gcd;\n  const aRootValue = Math.sqrt(Math.abs(aValue));\n  let cRootValue = Math.sqrt(Math.abs(cValue));\n\n  // if the second term is negative, then the constant in the parens is\n  // subtracted: e.g. x^2 - 2x + 1 -> (x - 1)^2\n  if (bValue < 0) {\n    cRootValue = cRootValue * -1;\n  }\n\n  // apply the perfect square test\n  const perfectProduct = 2 * aRootValue * cRootValue;\n  if (Number.isInteger(aRootValue) &&\n      Number.isInteger(cRootValue) &&\n      (bValue/gcd) === perfectProduct) {\n    const aRootNode = Node.Creator.constant(aRootValue);\n    const cRootNode = Node.Creator.constant(cRootValue);\n\n    const polyTerm = Node.Creator.polynomialTerm(symbol, null, aRootNode);\n    const paren = Node.Creator.parenthesis(\n      Node.Creator.operator('+', [polyTerm, cRootNode]));\n    const exponent = Node.Creator.constant(2);\n\n    // create node in perfect square form\n    let newNode = Node.Creator.operator('^', [paren, exponent]);\n    if (gcd !== 1) {\n      const gcdNode = Node.Creator.constant(gcd);\n      newNode = Node.Creator.operator('*', [gcdNode, newNode], true);\n    }\n    if (negate) {\n      newNode = Negative.negate(newNode);\n    }\n\n    return Node.Status.nodeChanged(\n      ChangeTypes.FACTOR_PERFECT_SQUARE, node, newNode);\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Will factor the node if it's in the form of ax^2 + bx + c, by\n// applying the sum product rule: finding factors of a*c that add up to b.\n// e.g. x^2 + 3x + 2 -> (x + 1)(x + 2) or\n// or   2x^2 + 5x + 3 -> (2x - 1)(x + 3)\nfunction factorSumProductRule(node, symbol, aValue, bValue, cValue, negate) {\n  let newNode;\n\n  if (bValue && cValue) {\n    // we factor out the gcd first, providing us with a modified expression to\n    // factor with new a, b and c values\n    const gcd = math.gcd(aValue, bValue, cValue);\n    const gcdNode = Node.Creator.constant(gcd);\n\n    aValue = aValue/gcd;\n    bValue = bValue/gcd;\n    cValue = cValue/gcd;\n\n    // try sum/product rule: find a factor pair of a*c that adds up to b\n    const product = aValue * cValue;\n    const factorPairs = ConstantFactors.getFactorPairs(product, true);\n    for (const pair of factorPairs) {\n      if (pair[0] + pair[1] === bValue) {\n        // To factor, we go through some transformations\n        // 1. Break apart the middle term into two terms using our factor pair\n        //    (p and q): e.g. ax^2 + bx + c -> ax^2 + px + qx + c\n        // 2. Consider the first two terms together and the second two terms\n        //    together (this doesn't require any actual change to the expression)\n        //    e.g. first group: [ax^2 + px] and second group: [qx + c]\n        // 3. Factor both groups separately\n        //    e.g first group: [ux(rx + s)] and second group [v(rx + s)]\n        // 4. Finish factoring by combining the factored terms through grouping:\n        //    e.g. (ux + v)(rx + s)\n        const substeps = [];\n        let status;\n\n        const a = Node.Creator.constant(aValue);\n        const b = Node.Creator.constant(bValue);\n        const c = Node.Creator.constant(cValue);\n        const ax2 = Node.Creator.polynomialTerm(symbol, Node.Creator.constant(2), a);\n        const bx = Node.Creator.polynomialTerm(symbol, null, b);\n\n        // OPTIONAL SUBSTEP (this happens iff a is negative)\n        // ax^2 + bx + c -> -(-ax^2 - bx - c)\n        if (negate) {\n          newNode = Node.Creator.operator('+', [ax2, bx, c], true);\n          newNode = Negative.negate(newNode);\n          status = Node.Status.nodeChanged(\n            ChangeTypes.REARRANGE_COEFF, node, newNode);\n          substeps.push(status);\n          newNode = Node.Status.resetChangeGroups(status.newNode);\n        }\n\n        // SUBSTEP 1: ax^2 + bx + c -> ax^2 + px + qx + c\n        const pValue = pair[0];\n        const qValue = pair[1];\n        const p = Node.Creator.constant(pValue);\n        const q = Node.Creator.constant(qValue);\n        const px = Node.Creator.polynomialTerm(symbol, null, p);\n        const qx = Node.Creator.polynomialTerm(symbol, null, q);\n\n        newNode = Node.Creator.operator('+', [ax2, px, qx, c], true);\n        if (negate) {\n          newNode = Negative.negate(newNode);\n        }\n        status = Node.Status.nodeChanged(\n          ChangeTypes.BREAK_UP_TERM, node, newNode);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n\n        // STEP 2: ax^2 + px + qx + c -> (ax^2 + px) + (qx + c)\n        const firstTerm = Node.Creator.parenthesis(\n          Node.Creator.operator('+', [ax2, px]));\n        const secondTerm = Node.Creator.parenthesis(\n          Node.Creator.operator('+', [qx, c]));\n\n        newNode = Node.Creator.operator('+', [firstTerm, secondTerm], true);\n        if (negate) {\n          newNode = Negative.negate(newNode);\n        }\n        status = Node.Status.nodeChanged(\n          ChangeTypes.COLLECT_LIKE_TERMS, node, newNode);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n\n        // SUBSTEP 3A: (ax^2 + px) + (qx + c) -> ux(rx + s) + (qx + c)\n        const u = Node.Creator.constant(math.gcd(aValue, pValue));\n        const r = Node.Creator.constant(aValue/u);\n        const s = Node.Creator.constant(pValue/u);\n        const ux = Node.Creator.polynomialTerm(symbol, null, u);\n\n        // create the first group's part that's in parentheses: (rx + s)\n        const rx = Node.Creator.polynomialTerm(symbol, null, r);\n        const firstParen = Node.Creator.parenthesis(\n          Node.Creator.operator('+', [rx, s]));\n\n        const firstFactoredGroup = Node.Creator.operator('*', [ux, firstParen], true);\n        newNode = Node.Creator.operator('+', [firstFactoredGroup, secondTerm], true);\n        if (negate) {\n          newNode = Negative.negate(newNode);\n        }\n        status = Node.Status.nodeChanged(\n          ChangeTypes.FACTOR_SYMBOL, node, newNode);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n\n        // STEP 3B: ux(rx + s) + (qx + c) -> ux(rx + s) + v(rx + s)\n        let vValue = math.gcd(cValue, qValue);\n        if (qValue < 0) {\n          vValue = vValue * -1;\n        }\n        const v = Node.Creator.constant(vValue);\n\n        // create the second parenthesis\n        const secondParen = Node.Creator.parenthesis(\n          Node.Creator.operator('+', [ux, v]));\n\n        const secondFactoredGroup = Node.Creator.operator('*', [v, firstParen], true);\n        newNode = Node.Creator.operator('+', [firstFactoredGroup, secondFactoredGroup], true);\n        if (negate) {\n          newNode = Negative.negate(newNode);\n        }\n        status = Node.Status.nodeChanged(\n          ChangeTypes.FACTOR_SYMBOL, node, newNode);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n\n        // STEP 4: ux(rx + s) + v(rx + s) -> (ux + v)(rx + s)\n        if (gcd === 1) {\n          newNode = Node.Creator.operator(\n            '*', [firstParen, secondParen], true);\n        }\n        else {\n          newNode = Node.Creator.operator(\n            '*', [gcdNode, firstParen, secondParen], true);\n        }\n\n        if (negate) {\n          newNode = Negative.negate(newNode);\n        }\n\n        status = Node.Status.nodeChanged(\n          ChangeTypes.FACTOR_SUM_PRODUCT_RULE, node, newNode);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n\n        return Node.Status.nodeChanged(\n          ChangeTypes.FACTOR_SUM_PRODUCT_RULE, node, newNode, true, substeps);\n      }\n    }\n  }\n\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = factorQuadratic;\n","/*\n  Various utility functions used in the math stepper\n */\nconst Util = {};\n\n// Adds `value` to a list in `dict`, creating a new list if the key isn't in\n// the dictionary yet. Returns the updated dictionary.\nUtil.appendToArrayInObject = function(dict, key, value) {\n  if (dict[key]) {\n    dict[key].push(value);\n  }\n  else {\n    dict[key] = [value];\n  }\n  return dict;\n};\n\nmodule.exports = Util;\n","const print = require('../../util/print');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\nconst NthRoot = require('../functionsSearch/nthRoot');\nconst Util = require('../../util/Util');\n\nconst CONSTANT = 'constant';\nconst CONSTANT_FRACTION = 'constantFraction';\nconst NTH_ROOT = 'nthRoot';\nconst OTHER = 'other';\n\nconst LikeTermCollector = {};\n\n// Given an expression tree, returns true if there are terms that can be\n// collected\nLikeTermCollector.canCollectLikeTerms = function(node) {\n  // We can collect like terms through + or through *\n  // Note that we never collect like terms with - or /, those expressions will\n  // always be manipulated in flattenOperands so that the top level operation is\n  // + or *.\n  if (!(Node.Type.isOperator(node, '+') || Node.Type.isOperator(node, '*'))) {\n    return false;\n  }\n\n  let terms;\n  if (node.op === '+') {\n    terms = getTermsForCollectingAddition(node);\n  }\n  else if (node.op === '*') {\n    terms = getTermsForCollectingMultiplication(node);\n  }\n  else {\n    throw Error('Operation not supported: ' + node.op);\n  }\n\n  // Conditions we need to meet to decide to to reorganize (collect) the terms:\n  // - more than 1 term type\n  // - more than 1 of at least one type (not including other)\n  // (note that this means x^2 + x + x + 2 -> x^2 + (x + x) + 2,\n  // which will be recorded as a step, but doesn't change the order of terms)\n  const termTypes = Object.keys(terms);\n  const filteredTermTypes = termTypes.filter(x => x !== OTHER);\n  return (termTypes.length > 1 &&\n    filteredTermTypes.some(x => terms[x].length > 1));\n};\n\n// Collects like terms for an operation node and returns a Node.Status object.\nLikeTermCollector.collectLikeTerms = function(node) {\n  if (!LikeTermCollector.canCollectLikeTerms(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  const op = node.op;\n  let terms = [];\n  if (op === '+') {\n    terms = getTermsForCollectingAddition(node);\n  }\n  else if (op === '*') {\n    terms = getTermsForCollectingMultiplication(node);\n  }\n  else {\n    throw Error('Operation not supported: ' + op);\n  }\n\n  // List the symbols alphabetically\n  const termTypesSorted = Object.keys(terms)\n      .filter(x => (x !== CONSTANT && x !== CONSTANT_FRACTION && x !== OTHER))\n      .sort(sortTerms);\n\n\n  // Then add const\n  if (terms[CONSTANT]) {\n    // at the end for addition (since we'd expect x^2 + (x + x) + 4)\n    if (op === '+') {\n      termTypesSorted.push(CONSTANT);\n    }\n    // for multipliation it should be at the front (e.g. (3*4) * x^2)\n    if (op === '*') {\n      termTypesSorted.unshift(CONSTANT);\n    }\n  }\n  if (terms[CONSTANT_FRACTION]) {\n    termTypesSorted.push(CONSTANT_FRACTION);\n  }\n\n  // Collect the new operands under op.\n  let newOperands = [];\n  let changeGroup = 1;\n  termTypesSorted.forEach(termType => {\n    const termsOfType = terms[termType];\n    if (termsOfType.length === 1) {\n      const singleTerm = termsOfType[0].cloneDeep();\n      singleTerm.changeGroup = changeGroup;\n      newOperands.push(singleTerm);\n    }\n    // Any like terms should be wrapped in parens.\n    else {\n      const termList = Node.Creator.parenthesis(\n        Node.Creator.operator(op, termsOfType)).cloneDeep();\n      termList.changeGroup = changeGroup;\n      newOperands.push(termList);\n    }\n    termsOfType.forEach(term => {\n      term.changeGroup = changeGroup;\n    });\n    changeGroup++;\n  });\n\n  // then stick anything else (paren nodes, operator nodes) at the end\n  if (terms[OTHER]) {\n    newOperands = newOperands.concat(terms[OTHER]);\n  }\n\n  const newNode = node.cloneDeep();\n  newNode.args = newOperands;\n  return Node.Status.nodeChanged(\n    ChangeTypes.COLLECT_LIKE_TERMS, node, newNode, false);\n};\n\n// Terms with coefficients are collected by categorizing them by their 'name'\n// which is used to separate them into groups that can be combined. getTermName\n// returns this group 'name'\nfunction getTermName(node, termSubclass, op) {\n  const term = new termSubclass(node);\n  // we 'name' terms by their base node name\n  let termName = print.ascii(term.getBaseNode());\n  // when adding terms, the exponent matters too (e.g. 2x^2 + 5x^3 can't be combined)\n  if (op === '+') {\n    const exponent = print.ascii(term.getExponentNode(true));\n    termName += '^' + exponent;\n  }\n  return termName;\n}\n\n// Collects like terms in an addition expression tree into categories.\n// Returns a dictionary of termname to lists of nodes with that name\n// e.g. 2x + 4 + 5x would return {'x': [2x, 5x], CONSTANT: [4]}\n// (where 2x, 5x, and 4 would actually be expression trees)\nfunction getTermsForCollectingAddition(node) {\n  let terms = {};\n\n  for (let i = 0; i < node.args.length; i++) {\n    const child = node.args[i];\n\n    if (Node.PolynomialTerm.isPolynomialTerm(child)) {\n      const termName = getTermName(child, Node.PolynomialTerm, '+');\n      terms = Util.appendToArrayInObject(terms, termName, child);\n    }\n    else if (Node.NthRootTerm.isNthRootTerm(child)) {\n      const termName = getTermName(child, Node.NthRootTerm, '+');\n      terms = Util.appendToArrayInObject(terms, termName, child);\n    }\n    else if (Node.Type.isIntegerFraction(child)) {\n      terms = Util.appendToArrayInObject(terms, CONSTANT_FRACTION, child);\n    }\n    else if (Node.Type.isConstant(child)) {\n      terms = Util.appendToArrayInObject(terms, CONSTANT, child);\n    }\n    else if (Node.Type.isOperator(node) ||\n             Node.Type.isFunction(node) ||\n             Node.Type.isParenthesis(node) ||\n             Node.Type.isUnaryMinus(node)) {\n      terms = Util.appendToArrayInObject(terms, OTHER, child);\n    }\n    else {\n      // Note that we shouldn't get any symbol nodes in the switch statement\n      // since they would have been handled by isPolynomialTerm\n      throw Error('Unsupported node type: ' + child.type);\n    }\n  }\n  // If there's exactly one constant and one fraction, we collect them\n  // to add them together.\n  // e.g. 2 + 1/3 + 5 would collect the constants (2+5) + 1/3\n  // but 2 + 1/3 + x would collect (2 + 1/3) + x so we can add them together\n  if (terms[CONSTANT] && terms[CONSTANT].length === 1 &&\n     terms[CONSTANT_FRACTION] && terms[CONSTANT_FRACTION].length === 1) {\n    const fraction = terms[CONSTANT_FRACTION][0];\n    terms = Util.appendToArrayInObject(terms, CONSTANT, fraction);\n    delete terms[CONSTANT_FRACTION];\n  }\n\n  return terms;\n}\n\n// Collects like terms in a multiplication expression tree into categories.\n// For multiplication, polynomial terms with constants are separated into\n// a symbolic term and a constant term.\n// Returns a dictionary of termname to lists of nodes with that name\n// e.g. 2x + 4 + 5x^2 would return {'x': [x, x^2], CONSTANT: [2, 4, 5]}\n// (where x, x^2, 2, 4, and 5 would actually be expression trees)\nfunction getTermsForCollectingMultiplication(node) {\n  let terms = {};\n\n  for (let i = 0; i < node.args.length; i++) {\n    let child = node.args[i];\n\n    if (Node.Type.isUnaryMinus(child)) {\n      terms = Util.appendToArrayInObject(\n        terms, CONSTANT, Node.Creator.constant(-1));\n      child = child.args[0];\n    }\n    if (Node.PolynomialTerm.isPolynomialTerm(child)) {\n      terms = addToTermsforPolynomialMultiplication(terms, child);\n    }\n    else if (Node.Type.isFunction(child, 'nthRoot')) {\n      terms = addToTermsforNthRootMultiplication(terms, child);\n    }\n    else if (Node.Type.isIntegerFraction(child)) {\n      terms = Util.appendToArrayInObject(terms, CONSTANT, child);\n    }\n    else if (Node.Type.isConstant(child)) {\n      terms = Util.appendToArrayInObject(terms, CONSTANT, child);\n    }\n    else if (Node.Type.isOperator(node) ||\n             Node.Type.isFunction(node) ||\n             Node.Type.isParenthesis(node) ||\n             Node.Type.isUnaryMinus(node)) {\n      terms = Util.appendToArrayInObject(terms, OTHER, child);\n    }\n    else {\n      // Note that we shouldn't get any symbol nodes in the switch statement\n      // since they would have been handled by isPolynomialTerm\n      throw Error('Unsupported node type: ' + child.type);\n    }\n  }\n  return terms;\n}\n\n// A helper function for getTermsForCollectingMultiplication\n// e.g. nthRoot(x, 2), append 'nthRoot2': nthRootNode to terms dictionary\n// Takes the terms dictionary and the nthRoot node, and returns an updated\n// terms dictionary.\nfunction addToTermsforNthRootMultiplication(terms, node) {\n  const rootNode = NthRoot.getRootNode(node);\n  const rootNodeValue = rootNode.value;\n\n  terms = Util.appendToArrayInObject(terms, NTH_ROOT + rootNodeValue , node);\n\n  return terms;\n}\n\n// A helper function for getTermsForCollectingMultiplication\n// Polynomial terms need to be divided into their coefficient + symbolic parts.\n// e.g. 2x^4 -> 2 (coeffient) and x^4 (symbolic, named after the symbol node)\n// Takes the terms list and the polynomial term node, and returns an updated\n// terms list.\nfunction addToTermsforPolynomialMultiplication(terms, node) {\n  const polyNode = new Node.PolynomialTerm(node);\n  let termName;\n\n  if (!polyNode.hasCoeff()) {\n    termName = getTermName(node, Node.PolynomialTerm, '*');\n    terms = Util.appendToArrayInObject(terms, termName, node);\n  }\n  else {\n    const coefficient = polyNode.getCoeffNode();\n    let termWithoutCoefficient = polyNode.getSymbolNode();\n    if (polyNode.getExponentNode()) {\n      termWithoutCoefficient = Node.Creator.operator(\n        '^', [termWithoutCoefficient, polyNode.getExponentNode()]);\n    }\n\n    terms = Util.appendToArrayInObject(terms, CONSTANT, coefficient);\n    termName = getTermName(termWithoutCoefficient, Node.PolynomialTerm, '*');\n    terms = Util.appendToArrayInObject(terms, termName, termWithoutCoefficient);\n  }\n  return terms;\n}\n\n// Sort function for termnames. Sort first by symbol name, and then by exponent.\nfunction sortTerms(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  // if no exponent, sort alphabetically\n  if (a.indexOf('^') === -1) {\n    return a < b ? -1 : 1;\n  }\n  // if exponent: sort by symbol, but then exponent decreasing\n  else {\n    const symbA = a.split('^')[0];\n    const expA = a.split('^')[1];\n    const symbB = b.split('^')[0];\n    const expB = b.split('^')[1];\n    if (symbA !== symbB) {\n      return symbA < symbB ? -1 : 1;\n    }\n    else {\n      return expA > expB ? -1 : 1;\n    }\n  }\n}\n\nmodule.exports = LikeTermCollector;\n","const checks = require('../checks');\nconst LikeTermCollector = require('../simplifyExpression/collectAndCombineSearch/LikeTermCollector');\nconst Node = require('../node');\n\n// Removes any parenthesis around nodes that can't be resolved further.\n// Input must be a top level expression.\n// Returns a node.\nfunction removeUnnecessaryParens(node, rootNode=false) {\n  // Parens that wrap everything are redundant.\n  // NOTE: removeUnnecessaryParensSearch recursively removes parens that aren't\n  // needed, while this step only applies to the very top level expression.\n  // e.g. (2 + 3) * 4 can't become 2 + 3 * 4, but if (2 + 3) as a top level\n  // expression can become 2 + 3\n  if (rootNode) {\n    while (Node.Type.isParenthesis(node)) {\n      node = node.content;\n    }\n  }\n  return removeUnnecessaryParensSearch(node);\n}\n\n// Recursively moves parenthesis around nodes that can't be resolved further if\n// it doesn't change the value of the expression. Returns a node.\n// NOTE: after this function is called, every parenthesis node in the\n// tree should always have an operator node or unary minus as its child.\nfunction removeUnnecessaryParensSearch(node) {\n  if (Node.Type.isOperator(node)) {\n    return removeUnnecessaryParensInOperatorNode(node);\n  }\n  else if (Node.Type.isFunction(node)) {\n    return removeUnnecessaryParensInFunctionNode(node);\n  }\n  else if (Node.Type.isParenthesis(node)) {\n    return removeUnnecessaryParensInParenthesisNode(node);\n  }\n  else if (Node.Type.isConstant(node, true) || Node.Type.isSymbol(node)) {\n    return node;\n  }\n  else if (Node.Type.isUnaryMinus(node)) {\n    const content = node.args[0];\n    node.args[0] = removeUnnecessaryParensSearch(content);\n    return node;\n  }\n  else {\n    throw Error('Unsupported node type: ' + node.type);\n  }\n}\n\n// Removes unncessary parens for each operator in an operator node, and removes\n// unncessary parens around operators that can't be simplified further.\n// Returns a node.\nfunction removeUnnecessaryParensInOperatorNode(node) {\n  // Special case: if the node is an exponent node and the base\n  // is an operator, we should keep the parentheses for the base.\n  // e.g. (2x)^2 -> (2x)^2 instead of 2x^2\n  if (node.op === '^' && Node.Type.isParenthesis(node.args[0])) {\n    const base = node.args[0];\n    if (Node.Type.isOperator(base.content)) {\n      base.content = removeUnnecessaryParensSearch(base.content);\n      node.args[1] = removeUnnecessaryParensSearch(node.args[1]);\n\n      return node;\n    }\n  }\n\n  node.args.forEach((child, i) => {\n    node.args[i] = removeUnnecessaryParensSearch(child);\n  });\n\n  /** x-(2/y) -> x - 2/y */\n  if ('+-'.includes(node.op) && node.args.length === 2) {\n    const [left, right] = node.args;\n    if (Node.Type.isParenthesis(right) && Node.Type.isOperator(right.content) && '*/'.includes(right.content.op)){\n      node.args[1] = right.content;\n      return node;\n    }\n  }\n\n  // Sometimes, parens are around expressions that have been simplified\n  // all they can be. If that expression is part of an addition or subtraction\n  // operation, we can remove the parenthesis.\n  // e.g. (x+4) + 12 -> x+4 + 12\n  if (node.op === '+') {\n    node.args.forEach((child, i) => {\n      if (Node.Type.isParenthesis(child) &&\n          !canCollectOrCombine(child.content)) {\n        // remove the parens by replacing the child node (in its args list)\n        // with its content\n        node.args[i] = child.content;\n      }\n    });\n  }\n  // This is different from addition because when subtracting a group of terms\n  //in parenthesis, we want to distribute the subtraction.\n  // e.g. `(2 + x) - (1 + x)` => `2 + x - (1 + x)` not `2 + x - 1 + x`\n  else if (node.op === '-') {\n    if (Node.Type.isParenthesis(node.args[0]) &&\n        !canCollectOrCombine(node.args[0].content)) {\n      node.args[0] = node.args[0].content;\n    }\n  }\n\n  return node;\n}\n\n// Removes unncessary parens for each argument in a function node.\n// Returns a node.\nfunction removeUnnecessaryParensInFunctionNode(node) {\n  node.args.forEach((child, i) => {\n    if (Node.Type.isParenthesis(child)) {\n      child = child.content;\n    }\n    node.args[i] = removeUnnecessaryParensSearch(child);\n  });\n\n  return node;\n}\n\n\n// Parentheses are unnecessary when their content is a constant e.g. (2)\n// or also a parenthesis node, e.g. ((2+3)) - this removes those parentheses.\n// Note that this means that the type of the content of a ParenthesisNode after\n// this step should now always be an OperatorNode (including unary minus).\n// Returns a node.\nfunction removeUnnecessaryParensInParenthesisNode(node) {\n  // polynomials terms can be complex trees (e.g. 3x^2/5) but don't need parens\n  // around them\n  if (Node.PolynomialTerm.isPolynomialTerm(node.content)) {\n    // also recurse to remove any unnecessary parens within the term\n    // (e.g. the exponent might have parens around it)\n    if (node.content.args) {\n      node.content.args.forEach((arg, i) => {\n        node.content.args[i] = removeUnnecessaryParensSearch(arg);\n      });\n    }\n    node = node.content;\n  }\n  // If the content is just one symbol or constant, the parens are not\n  // needed.\n  else if (Node.Type.isConstant(node.content, true) ||\n           Node.Type.isIntegerFraction(node.content) ||\n           Node.Type.isSymbol(node.content)) {\n    node = node.content;\n  }\n  // If the content is just one function call, the parens are not needed.\n  else if (Node.Type.isFunction(node.content)) {\n    node = node.content;\n    node = removeUnnecessaryParensSearch(node);\n  }\n  // If there is an operation within the parens, then the parens are\n  // likely needed. So, recurse.\n  else if (Node.Type.isOperator(node.content)) {\n    node.content = removeUnnecessaryParensSearch(node.content);\n    // exponent nodes don't need parens around them\n    if (node.content.op === '^') {\n      node = node.content;\n    }\n  }\n  // If the content is also parens, we have doubly nested parens. First\n  // recurse on the child node, then set the current node equal to its child\n  // to get rid of the extra parens.\n  else if (Node.Type.isParenthesis(node.content)) {\n    node = removeUnnecessaryParensSearch(node.content);\n  }\n  else if (Node.Type.isUnaryMinus(node.content)) {\n    node.content = removeUnnecessaryParensSearch(node.content);\n  }\n  else {\n    throw Error('Unsupported node type: ' + node.content.type);\n  }\n\n  return node;\n}\n\n// Returns true if any of the collect or combine steps can be applied to the\n// expression tree `node`.\nfunction canCollectOrCombine(node) {\n  return LikeTermCollector.canCollectLikeTerms(node) ||\n    checks.resolvesToConstant(node) ||\n    checks.canSimplifyPolynomialTerms(node);\n}\n\nmodule.exports = removeUnnecessaryParens;\n","const checks = require('../checks');\n\nconst factorQuadratic = require('./factorQuadratic');\n\nconst flattenOperands = require('../util/flattenOperands');\nconst removeUnnecessaryParens = require('../util/removeUnnecessaryParens');\n\n// Given a mathjs expression node, steps through factoring the expression.\n// Currently only supports factoring quadratics.\n// Returns a list of details about each step.\nfunction stepThrough(node, debug=false) {\n  if (debug) {\n    // eslint-disable-next-line\n    console.log('\\n\\nFactoring: ' + print.ascii(node, false, true));\n  }\n\n  if (checks.hasUnsupportedNodes(node)) {\n    return [];\n  }\n\n  let nodeStatus;\n  const steps = [];\n\n  node = flattenOperands(node);\n  node = removeUnnecessaryParens(node, true);\n  if (checks.isQuadratic(node)) {\n    nodeStatus = factorQuadratic(node);\n    if (nodeStatus.hasChanged()) {\n      steps.push(nodeStatus);\n    }\n  }\n  // Add factoring higher order polynomials...\n\n  return steps;\n}\n\nmodule.exports = stepThrough;\n","const math = require('../node/MathjsInstance');\nconst stepThrough = require('./stepThrough');\n\nfunction factorString(expressionString, debug=false) {\n  let node;\n  try {\n    node = math.parse(expressionString);\n  }\n  catch (err) {\n    return [];\n  }\n\n  if (node) {\n    return stepThrough(node, debug);\n  }\n  return [];\n}\n\nmodule.exports = factorString;\n","const Node = require('./node');\n\nconst TreeSearch = {};\n\n// Returns a function that performs a preorder search on the tree for the given\n// simplification function\nTreeSearch.preOrder = function(simplificationFunction) {\n  return function (node) {\n    return search(simplificationFunction, node, true);\n  };\n};\n\n// Returns a function that performs a postorder search on the tree for the given\n// simplification function\nTreeSearch.postOrder = function(simplificationFunction) {\n  return function (node) {\n    return search(simplificationFunction, node, false);\n  };\n};\n\n// A helper function for performing a tree search with a function\nfunction search(simplificationFunction, node, preOrder) {\n  let status;\n\n  if (preOrder) {\n    status = simplificationFunction(node);\n    if (status.hasChanged()) {\n      return status;\n    }\n  }\n\n  if (Node.Type.isConstant(node) || Node.Type.isSymbol(node)) {\n    return Node.Status.noChange(node);\n  }\n  else if (Node.Type.isUnaryMinus(node)) {\n    status = search(simplificationFunction, node.args[0], preOrder);\n    if (status.hasChanged()) {\n      return Node.Status.childChanged(node, status);\n    }\n  }\n  else if (Node.Type.isOperator(node) || Node.Type.isFunction(node)) {\n    for (let i = 0; i < node.args.length; i++) {\n      const child = node.args[i];\n      const childNodeStatus = search(simplificationFunction, child, preOrder);\n      if (childNodeStatus.hasChanged()) {\n        return  Node.Status.childChanged(node, childNodeStatus, i);\n      }\n    }\n  }\n  else if (Node.Type.isParenthesis(node)) {\n    status = search(simplificationFunction, node.content, preOrder);\n    if (status.hasChanged()) {\n      return Node.Status.childChanged(node, status);\n    }\n  }\n  else {\n    throw Error('Unsupported node type: ' + node);\n  }\n\n  if (!preOrder) {\n    return simplificationFunction(node);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n\nmodule.exports = TreeSearch;\n","const ChangeTypes = require('../../ChangeTypes');\nconst evaluate = require('../../util/evaluate');\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\n// Searches through the tree, prioritizing deeper nodes, and evaluates\n// arithmetic (e.g. 2+2 or 3*5*2) on an operation node if possible.\n// Returns a Node.Status object.\nconst search = TreeSearch.postOrder(arithmetic);\n\n// evaluates arithmetic (e.g. 2+2 or 3*5*2) on an operation node.\n// Returns a Node.Status object.\nfunction arithmetic(node) {\n  if (!Node.Type.isOperator(node)) {\n    return Node.Status.noChange(node);\n  }\n  if (!node.args.every(child => Node.Type.isConstant(child, true))) {\n    return Node.Status.noChange(node);\n  }\n\n  // we want to eval each arg so unary minuses around constant nodes become\n  // constant nodes with negative values\n  node.args.forEach((arg, i) => {\n    node.args[i] = Node.Creator.constant(evaluate(arg));\n  });\n\n  // Only resolve division of integers if we get an integer result.\n  // Note that a fraction of decimals will be divided out.\n  if (Node.Type.isIntegerFraction(node)) {\n    const numeratorValue = parseInt(node.args[0]);\n    const denominatorValue = parseInt(node.args[1]);\n    if (numeratorValue % denominatorValue === 0) {\n      const newNode = Node.Creator.constant(numeratorValue/denominatorValue);\n      return Node.Status.nodeChanged(\n        ChangeTypes.SIMPLIFY_ARITHMETIC, node, newNode);\n    }\n    else {\n      return Node.Status.noChange(node);\n    }\n  }\n  else {\n    const evaluatedValue = evaluateAndRound(node);\n    const newNode = Node.Creator.constant(evaluatedValue);\n    return Node.Status.nodeChanged(ChangeTypes.SIMPLIFY_ARITHMETIC, node, newNode);\n  }\n}\n\n// Evaluates a math expression to a constant, e.g. 3+4 -> 7 and rounds if\n// necessary\nfunction evaluateAndRound(node) {\n  let result = evaluate(node);\n  if (Math.abs(result) < 1) {\n    result  = parseFloat(result.toPrecision(4));\n  }\n  else {\n    result  = parseFloat(result.toFixed(4));\n  }\n  return result;\n}\n\nmodule.exports = search;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// Converts a mixed number to an improper fraction\n// e.g. 1 2/3 -> 5/3\n// All comments in the function are based on this example\nfunction convertMixedNumberToImproperFraction(node) {\n  if (!Node.MixedNumber.isMixedNumber(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  const substeps = [];\n  let newNode = node.cloneDeep();\n\n  // e.g. 1 2/3\n  const wholeNumber = Node.MixedNumber.getWholeNumberValue(node); // 1\n  const numerator = Node.MixedNumber.getNumeratorValue(node); // 2\n  const denominator = Node.MixedNumber.getDenominatorValue(node); // 3\n  const isNegativeMixedNumber = Node.MixedNumber.isNegativeMixedNumber(node);\n\n  // STEP 1: Convert to unsimplified improper fraction\n  // e.g. 1 2/3 -> ((1 * 3) + 2) / 3\n  let status = convertToUnsimplifiedImproperFraction(\n    newNode, wholeNumber, numerator, denominator, isNegativeMixedNumber);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // STEP 2: Simplify multiplication in numerator\n  // e.g. ((1 * 3) + 2) / 3 -> (3 + 2) / 3\n  status = simplifyMultiplicationInImproperFraction(\n    newNode, wholeNumber, numerator, denominator, isNegativeMixedNumber);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // STEP 3: Simplify addition in numerator\n  // e.g. (3 + 2) / 3 -> 5/3\n  status = simplifyAdditionInImproperFraction(\n    newNode, wholeNumber, numerator, denominator, isNegativeMixedNumber);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION,\n    node, newNode, true, substeps);\n}\n\n// Convert a mixed number to an unsimplified proper fraction\n// e.g. 1 2/3 -> ((1 * 3) + 2) / 3\nfunction convertToUnsimplifiedImproperFraction(\n  oldNode, wholeNumber, numerator, denominator, isNegativeMixedNumber) {\n  // (wholeNumber * denominator)\n  // e.g. (1 * 3)\n  const newNumeratorMultiplication = Node.Creator.parenthesis(\n    Node.Creator.operator(\n      '*',\n      [Node.Creator.constant(wholeNumber),\n        Node.Creator.constant(denominator)]));\n\n  // (wholeNumber * denominator) + numerator\n  // e.g. (1 * 3) + 2\n  const newNumerator = Node.Creator.operator(\n    '+',\n    [newNumeratorMultiplication, Node.Creator.constant(numerator)]);\n  oldNode.args[0].args[0].changeGroup = 1;\n  newNumerator.changeGroup = 1;\n\n  // e.g. 3\n  const newDenominator = Node.Creator.constant(denominator);\n\n  let newNode = Node.Creator.operator(\n    '/', [newNumerator, newDenominator]);\n\n  if (isNegativeMixedNumber) {\n    newNode = Node.Creator.unaryMinus(newNode);\n  }\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.IMPROPER_FRACTION_NUMERATOR, oldNode, newNode, false);\n}\n\n// Simplify multiplication in the numerator of an improper fraction\n// e.g. ((1 * 3) + 2) / 3 -> (3 + 2) / 3\nfunction simplifyMultiplicationInImproperFraction(\n  oldNode, wholeNumber, numerator, denominator, isNegativeMixedNumber) {\n  // (wholeNumber * denominator) + numerator\n  // e.g. 3 + 2\n  const newNumerator = Node.Creator.operator(\n    '+',\n    [Node.Creator.constant(wholeNumber * denominator),\n      Node.Creator.constant(numerator)]);\n  oldNode.args[0].changeGroup = 1;\n  newNumerator.changeGroup = 1;\n\n  // e.g. 3\n  const newDenominator = Node.Creator.constant(denominator);\n\n  let newNode = Node.Creator.operator(\n    '/', [newNumerator, newDenominator]);\n\n  if (isNegativeMixedNumber) {\n    newNode = Node.Creator.unaryMinus(newNode);\n  }\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.SIMPLIFY_ARITHMETIC, oldNode, newNode, false);\n}\n\n// Simplify addition in the numerator of an improper fraction\n// e.g. (3 + 2) / 3 -> 5/3\nfunction simplifyAdditionInImproperFraction(\n  oldNode, wholeNumber, numerator, denominator, isNegativeMixedNumber) {\n  // (wholeNumber * denominator) + numerator\n  // e.g. 5\n  const newNumerator = Node.Creator.constant(\n    wholeNumber * denominator + numerator);\n  oldNode.args[0].changeGroup = 1;\n  newNumerator.changeGroup = 1;\n\n  // e.g. 3\n  const newDenominator = Node.Creator.constant(denominator);\n\n  let newNode = Node.Creator.operator(\n    '/', [newNumerator, newDenominator]);\n\n  if (isNegativeMixedNumber) {\n    newNode = Node.Creator.unaryMinus(newNode);\n  }\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.SIMPLIFY_ARITHMETIC, oldNode, newNode, false);\n}\n\nmodule.exports = convertMixedNumberToImproperFraction;\n","const checks = require('../../checks');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// Rearranges something of the form x * 5 to be 5x, ie putting the coefficient\n// in the right place.\n// Returns a Node.Status object\nfunction rearrangeCoefficient(node) {\n  if (!checks.canRearrangeCoefficient(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  let newNode = node.cloneDeep();\n\n  const polyNode = new Node.PolynomialTerm(newNode.args[0]);\n  const constNode = Node.Type.isParenthesis(newNode.args[1]) ? newNode.args[1].content : newNode.args[1];\n  const exponentNode = polyNode.getExponentNode();\n  newNode = Node.Creator.polynomialTerm(\n    polyNode.getSymbolNode(), exponentNode, constNode);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.REARRANGE_COEFF, node, newNode);\n}\n\nmodule.exports = rearrangeCoefficient;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is an exponent of something to 0, we can reduce that to just 1.\n// Returns a Node.Status object.\nfunction reduceExponentByZero(node) {\n  if (node.op !== '^') {\n    return Node.Status.noChange(node);\n  }\n  const exponent = node.args[1];\n  if (Node.Type.isConstant(exponent) && exponent.value === 0) {\n    const newNode = Node.Creator.constant(1);\n    return Node.Status.nodeChanged(\n      ChangeTypes.REDUCE_EXPONENT_BY_ZERO, node, newNode);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\nmodule.exports = reduceExponentByZero;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is a multiplication node with 0 as one of its operands,\n// reduce the node to 0. Returns a Node.Status object.\nfunction reduceMultiplicationByZero(node) {\n  if (node.op !== '*') {\n    return Node.Status.noChange(node);\n  }\n  const zeroIndex = node.args.findIndex(arg => {\n    if (Node.Type.isConstant(arg) && arg.value === 0) {\n      return true;\n    }\n    if (Node.PolynomialTerm.isPolynomialTerm(arg)) {\n      const polyTerm = new Node.PolynomialTerm(arg);\n      return polyTerm.getCoeffValue() === 0;\n    }\n    return false;\n  });\n  if (zeroIndex >= 0) {\n    // reduce to just the 0 node\n    const newNode = Node.Creator.constant(0);\n    return Node.Status.nodeChanged(\n      ChangeTypes.MULTIPLY_BY_ZERO, node, newNode);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\nmodule.exports = reduceMultiplicationByZero;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is a fraction with 0 as the numerator, reduce the node to 0.\n// Returns a Node.Status object.\nfunction reduceZeroDividedByAnything(node) {\n  if (node.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n  if (node.args[0].value === 0) {\n    const newNode = Node.Creator.constant(0);\n    return Node.Status.nodeChanged(\n      ChangeTypes.REDUCE_ZERO_NUMERATOR, node, newNode);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\nmodule.exports = reduceZeroDividedByAnything;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is an addition node with 0 as one of its operands,\n// remove 0 from the operands list. Returns a Node.Status object.\nfunction removeAdditionOfZero(node) {\n  if (node.op !== '+') {\n    return Node.Status.noChange(node);\n  }\n  const zeroIndex = node.args.findIndex(arg => {\n    return Node.Type.isConstant(arg) && arg.value === 0;\n  });\n  let newNode = node.cloneDeep();\n  if (zeroIndex >= 0) {\n    // remove the 0 node\n    newNode.args.splice(zeroIndex, 1);\n    // if there's only one operand left, there's nothing left to add it to,\n    // so move it up the tree\n    if (newNode.args.length === 1) {\n      newNode = newNode.args[0];\n    }\n    return Node.Status.nodeChanged(\n      ChangeTypes.REMOVE_ADDING_ZERO, node, newNode);\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = removeAdditionOfZero;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\n\n// If `node` is a division operation of something by 1 or -1, we can remove the\n// denominator. Returns a Node.Status object.\nfunction removeDivisionByOne(node) {\n  if (node.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n  const denominator = node.args[1];\n  if (!Node.Type.isConstant(denominator)) {\n    return Node.Status.noChange(node);\n  }\n  // It's taken 40ms on average to pass distribution test,\n  // TODO: see if we should keep using utils/clone here\n  let numerator = node.args[0].cloneDeep();\n\n  // if denominator is -1, we make the numerator negative\n  if (parseFloat(denominator.value) === -1) {\n    // If the numerator was an operation, wrap it in parens before adding -\n    // to the front.\n    // e.g. 2+3 / -1 ---> -(2+3)\n    if (Node.Type.isOperator(numerator)) {\n      numerator = Node.Creator.parenthesis(numerator);\n    }\n    const changeType = Negative.isNegative(numerator) ?\n      ChangeTypes.RESOLVE_DOUBLE_MINUS :\n      ChangeTypes.DIVISION_BY_NEGATIVE_ONE;\n    numerator = Negative.negate(numerator);\n    return Node.Status.nodeChanged(changeType, node, numerator);\n  }\n  else if (parseFloat(denominator.value) === 1) {\n    return Node.Status.nodeChanged(\n      ChangeTypes.DIVISION_BY_ONE, node, numerator);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\nmodule.exports = removeDivisionByOne;\n","const checks = require('../../checks');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is of the form 1^x, reduces it to a node of the form 1.\n// Returns a Node.Status object.\nfunction removeExponentBaseOne(node) {\n  if (node.op === '^' &&                         // an exponent with\n      checks.resolvesToConstant(node.args[1]) && // a power not a symbol and\n      Node.Type.isConstant(node.args[0]) &&      // a constant base\n      node.args[0].value === 1) {              // of value 1\n    const newNode = node.args[0].cloneDeep();\n    return Node.Status.nodeChanged(\n      ChangeTypes.REMOVE_EXPONENT_BASE_ONE, node, newNode);\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = removeExponentBaseOne;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is of the form x^1, reduces it to a node of the form x.\n// Returns a Node.Status object.\nfunction removeExponentByOne(node) {\n  if (node.op === '^' &&                   // exponent of anything\n      Node.Type.isConstant(node.args[1]) && // to a constant\n      node.args[1].value === 1) {        // of value 1\n    const newNode = node.args[0].cloneDeep();\n    return Node.Status.nodeChanged(\n      ChangeTypes.REMOVE_EXPONENT_BY_ONE, node, newNode);\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = removeExponentByOne;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\n\n// If `node` is a multiplication node with -1 as one of its operands,\n// and a non constant as the next operand, remove -1 from the operands\n// list and make the next term have a unary minus.\n// Returns a Node.Status object.\nfunction removeMultiplicationByNegativeOne(node) {\n  if (node.op !== '*') {\n    return Node.Status.noChange(node);\n  }\n  const minusOneIndex = node.args.findIndex(arg => {\n    return Node.Type.isConstant(arg) && arg.value === -1;\n  });\n  const minusOneIndex2 = node.args.findIndex(arg => {\n    return Node.Type.isUnaryMinus(arg) && Node.Type.isConstant(arg.args[0]) && arg.args[0].value === 1;\n  });\n  if (minusOneIndex < 0 && minusOneIndex2 < 0) {\n    return Node.Status.noChange(node);\n  }\n\n  const minusOneIndexToUse = minusOneIndex >= 0 ? minusOneIndex : minusOneIndex2;\n\n\n  // We might merge/combine the negative one into another node. This stores\n  // the index of that other node in the arg list.\n  let nodeToCombineIndex;\n  // If minus one is the last term, maybe combine with the term before\n  if (minusOneIndexToUse + 1 === node.args.length) {\n    nodeToCombineIndex = minusOneIndexToUse - 1;\n  }\n  else {\n    nodeToCombineIndex = minusOneIndexToUse + 1;\n  }\n\n  let nodeToCombine = node.args[nodeToCombineIndex];\n  // If it's a constant, the combining of those terms is handled elsewhere.\n  if (Node.Type.isConstant(nodeToCombine)) {\n    return Node.Status.noChange(node);\n  }\n\n  let newNode = node.cloneDeep();\n\n  // Get rid of the -1\n  nodeToCombine = Negative.negate(nodeToCombine.cloneDeep());\n\n  // replace the node next to -1 and remove -1\n  newNode.args[nodeToCombineIndex] = nodeToCombine;\n  newNode.args.splice(minusOneIndexToUse, 1);\n\n  // if there's only one operand left, move it up the tree\n  if (newNode.args.length === 1) {\n    newNode = newNode.args[0];\n  }\n  return Node.Status.nodeChanged(\n    ChangeTypes.REMOVE_MULTIPLYING_BY_NEGATIVE_ONE, node, newNode);\n}\n\nmodule.exports = removeMultiplicationByNegativeOne;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If `node` is a multiplication node with 1 as one of its operands,\n// remove 1 from the operands list. Returns a Node.Status object.\nfunction removeMultiplicationByOne(node) {\n  if (node.op !== '*') {\n    return Node.Status.noChange(node);\n  }\n  const oneIndex = node.args.findIndex(arg => {\n    return Node.Type.isConstant(arg) && arg.value === 1;\n  });\n  if (oneIndex >= 0) {\n    let newNode = node.cloneDeep();\n    // remove the 1 node\n    newNode.args.splice(oneIndex, 1);\n    // if there's only one operand left, there's nothing left to multiply it\n    // to, so move it up the tree\n    if (newNode.args.length === 1) {\n      newNode = newNode.args[0];\n    }\n    return Node.Status.nodeChanged(\n      ChangeTypes.REMOVE_MULTIPLYING_BY_ONE, node, newNode);\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = removeMultiplicationByOne;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// Simplifies two unary minuses in a row by removing both of them.\n// e.g. -(- 4) --> 4\nfunction simplifyDoubleUnaryMinus(node) {\n  if (Node.Type.isOperator(node) && node.op ==='*' && Node.Type.isUnaryMinus(node.args[0]) && Node.Type.isConstant(node.args[0].args[0])) {\n    const newNode = node.cloneDeep();\n    newNode.args[0] = Node.Creator.constant(node.args[0].args[0].value * -1);\n    return Node.Status.nodeChanged(\n      ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n  }\n  if (!Node.Type.isUnaryMinus(node)) {\n    return Node.Status.noChange(node);\n  }\n  const unaryArg = node.args[0];\n  // e.g. in - -x, -x is the unary arg, and we'd want to reduce to just x\n  if (Node.Type.isUnaryMinus(unaryArg)) {\n    const newNode = unaryArg.args[0].cloneDeep();\n    return Node.Status.nodeChanged(\n      ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n  }\n  // e.g. - -4, -4 could be a constant with negative value\n  else if (Node.Type.isConstant(unaryArg)) {\n    const newNode = unaryArg.cloneDeep();\n    newNode.value = -1 * newNode.value; // negate the value\n    return Node.Status.nodeChanged(\n      ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n  }\n  // e.g. -(-(5+2)) -> 5 + 2\n  //      -(-5)  -> 5\n  //      -(-x)  -> x\n  else if (Node.Type.isParenthesis(unaryArg)) {\n    const parenthesisNode = unaryArg;\n    const parenthesisContent = parenthesisNode.content;\n    if (Node.Type.isUnaryMinus(parenthesisContent) && Node.Type.isParenthesis(parenthesisContent.args[0])) {\n      const newNode = Node.Creator.parenthesis(parenthesisContent.args[0].content);\n      return Node.Status.nodeChanged(\n        ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n    } else if (Node.Type.isUnaryMinus(parenthesisContent)) {\n      const newNode = Node.Creator.parenthesis(parenthesisContent.args[0]);\n      return Node.Status.nodeChanged(\n        ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n    } else if (Node.Type.isConstant(parenthesisContent)) {\n      const newNode = Node.Creator.constant(parenthesisContent.value * -1)\n      return Node.Status.nodeChanged(\n        ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n    } else if (Node.Type.isSymbol(parenthesisContent)) {\n      const newNode = Node.Creator.symbol(parenthesisContent.name)\n      return Node.Status.nodeChanged(\n        ChangeTypes.RESOLVE_DOUBLE_MINUS, node, newNode);\n    }\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = simplifyDoubleUnaryMinus;\n","/*\n * Performs simpifications that are more basic and overaching like (...)^0 => 1\n * These are always the first simplifications that are attempted.\n */\n\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\nconst convertMixedNumberToImproperFraction = require('./convertMixedNumberToImproperFraction');\nconst rearrangeCoefficient = require('./rearrangeCoefficient');\nconst reduceExponentByZero = require('./reduceExponentByZero');\nconst reduceMultiplicationByZero = require('./reduceMultiplicationByZero');\nconst reduceZeroDividedByAnything = require('./reduceZeroDividedByAnything');\nconst removeAdditionOfZero = require('./removeAdditionOfZero');\nconst removeDivisionByOne = require('./removeDivisionByOne');\nconst removeExponentBaseOne = require('./removeExponentBaseOne');\nconst removeExponentByOne = require('./removeExponentByOne');\nconst removeMultiplicationByNegativeOne = require('./removeMultiplicationByNegativeOne');\nconst removeMultiplicationByOne = require('./removeMultiplicationByOne');\nconst simplifyDoubleUnaryMinus = require('./simplifyDoubleUnaryMinus');\n\nconst SIMPLIFICATION_FUNCTIONS = [\n  // convert mixed numbers to improper fractions\n  convertMixedNumberToImproperFraction,\n  // multiplication by 0 yields 0\n  reduceMultiplicationByZero,\n  // division of 0 by something yields 0\n  reduceZeroDividedByAnything,\n  // ____^0 --> 1\n  reduceExponentByZero,\n  // Check for x^1 which should be reduced to x\n  removeExponentByOne,\n  // Check for 1^x which should be reduced to 1\n  // if x can be simplified to a constant\n  removeExponentBaseOne,\n  // - - becomes +\n  simplifyDoubleUnaryMinus,\n  // If this is a + node and one of the operands is 0, get rid of the 0\n  removeAdditionOfZero,\n  // If this is a * node and one of the operands is 1, get rid of the 1\n  removeMultiplicationByOne,\n  // In some cases, remove multiplying by -1\n  removeMultiplicationByNegativeOne,\n  // If this is a / node and the denominator is 1 or -1, get rid of it\n  removeDivisionByOne,\n  // e.g. x*5 -> 5x\n  rearrangeCoefficient,\n];\n\nconst search = TreeSearch.preOrder(basics);\n\n// Look for basic step(s) to perform on a node. Returns a Node.Status object.\nfunction basics(node) {\n  for (let i = 0; i < SIMPLIFICATION_FUNCTIONS.length; i++) {\n    const nodeStatus = SIMPLIFICATION_FUNCTIONS[i](node);\n    if (nodeStatus.hasChanged()) {\n      return nodeStatus;\n    }\n    else {\n      node = nodeStatus.newNode;\n    }\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = search;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\n// Breaks up any fraction (deeper nodes getting priority) that has a numerator\n// that is a sum. e.g. (2+x)/5 -> (2/5 + x/5)\n// This step must happen after things have been collected and combined, or\n// else things will infinite loop, so it's a tree search of its own.\n// Returns a Node.Status object\nconst search = TreeSearch.postOrder(breakUpNumerator);\n\n// If `node` is a fraction with a numerator that is a sum, breaks up the\n// fraction e.g. (2+x)/5 -> (2/5 + x/5)\n// Returns a Node.Status object\nfunction breakUpNumerator(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n  let numerator = node.args[0];\n  if (Node.Type.isParenthesis(numerator)) {\n    numerator = numerator.content;\n  }\n  if (!Node.Type.isOperator(numerator) || numerator.op !== '+') {\n    return Node.Status.noChange(node);\n  }\n\n  // At this point, we know that node is a fraction and its numerator is a sum\n  // of terms that can't be collected or combined, so we should break it up.\n  const fractionList = [];\n  const denominator = node.args[1];\n  numerator.args.forEach(arg => {\n    const newFraction = Node.Creator.operator('/', [arg, denominator]);\n    newFraction.changeGroup = 1;\n    fractionList.push(newFraction);\n  });\n\n  let newNode = Node.Creator.operator('+', fractionList);\n  // Wrap in parens for cases like 2*(2+3)/5 => 2*(2/5 + 3/5)\n  newNode = Node.Creator.parenthesis(newNode);\n  node.changeGroup = 1;\n  return Node.Status.nodeChanged(\n    ChangeTypes.BREAK_UP_FRACTION, node, newNode, false);\n}\n\nmodule.exports = search;\n","const math = require('../../node/MathjsInstance');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst evaluate = require('../../util/evaluate');\nconst Node = require('../../node');\n\n// Simplifies a fraction (with constant numerator and denominator) by dividing\n// the top and bottom by the GCD, if possible.\n// e.g. 2/4 --> 1/2    10/5 --> 2x\n// Also simplified negative signs\n// e.g. -1/-3 --> 1/3   4/-5 --> -4/5\n// Note that -4/5 doesn't need to be simplified.\n// Note that our goal is for the denominator to always be positive. If it\n// isn't, we can simplify signs.\n// Returns a Node.Status object\nfunction divideByGCD(fraction) {\n  if (!Node.Type.isOperator(fraction) || fraction.op !== '/') {\n    return Node.Status.noChange(fraction);\n  }\n  // If it's not an integer fraction, all we can do is simplify signs\n  if (!Node.Type.isIntegerFraction(fraction, true)) {\n    return Node.Status.noChange(fraction);\n  }\n\n  const substeps = [];\n  let newNode = fraction.cloneDeep();\n\n  const numeratorValue = parseInt(evaluate(fraction.args[0]));\n  const denominatorValue = parseInt(evaluate(fraction.args[1]));\n\n  // The gcd is what we're dividing the numerator and denominator by.\n  let gcd = math.gcd(numeratorValue, denominatorValue);\n  // A greatest common denominator is technically defined as always positive,\n  // but since our goal is to reduce negative signs or move them to the\n  // numerator, a negative denominator always means we want to flip signs\n  // of both numerator and denominator.\n  // e.g. -1/-3 --> 1/3   4/-5 --> -4/5\n  if (denominatorValue < 0) {\n    gcd *= -1;\n  }\n\n  if (gcd === 1) {\n    return Node.Status.noChange(fraction);\n  }\n\n  // STEP 1: Find GCD\n  // e.g. 15/6 -> (5*3)/(2*3)\n  let status = findGCD(newNode, gcd, numeratorValue, denominatorValue);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // STEP 2: Cancel GCD\n  // (5*3)/(2*3) -> 5/2\n  status = cancelGCD(newNode, gcd, numeratorValue, denominatorValue);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  return Node.Status.nodeChanged(\n      ChangeTypes.SIMPLIFY_FRACTION, fraction, newNode, true, substeps);\n}\n\n// Returns a substep where the GCD is factored out of numerator and denominator\n// e.g. 15/6 -> (5*3)/(2*3)\nfunction findGCD(node, gcd, numeratorValue, denominatorValue) {\n  let newNode = node.cloneDeep();\n\n  // manually set change group of the GCD nodes to be the same\n  const gcdNode = Node.Creator.constant(gcd);\n  gcdNode.changeGroup = 1;\n\n  const intermediateNumerator = Node.Creator.parenthesis(Node.Creator.operator(\n    '*', [Node.Creator.constant(numeratorValue/gcd), gcdNode]));\n  const intermediateDenominator = Node.Creator.parenthesis(Node.Creator.operator(\n    '*', [Node.Creator.constant(denominatorValue/gcd), gcdNode]));\n  newNode = Node.Creator.operator(\n    '/', [intermediateNumerator, intermediateDenominator]);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.FIND_GCD, node, newNode, false);\n}\n\n// Returns a substep where the GCD is cancelled out of numerator and denominator\n// e.g. (5*3)/(2*3) -> 5/2\nfunction cancelGCD(node, gcd, numeratorValue, denominatorValue) {\n  let newNode;\n  const newNumeratorNode = Node.Creator.constant(numeratorValue/gcd);\n  const newDenominatorNode = Node.Creator.constant(denominatorValue/gcd);\n\n  if (parseFloat(newDenominatorNode.value) === 1) {\n    newNode = newNumeratorNode;\n  }\n  else {\n    newNode = Node.Creator.operator(\n      '/', [newNumeratorNode, newDenominatorNode]);\n  }\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.CANCEL_GCD, node, newNode, false);\n}\n\nmodule.exports = divideByGCD;\n","const divideByGCD = require('./divideByGCD');\nconst math = require('../../node/MathjsInstance');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst evaluate = require('../../util/evaluate');\nconst Node = require('../../node');\n\n// Adds constant fractions -- can start from either step 1 or 2\n// 1A. Find the LCD if denominators are different and multiplies to make\n//     denominators equal, e.g. 2/3 + 4/6 --> (2*2)/(3*2) + 4/6\n// 1B. Multiplies out to make constant fractions again\n//     e.g. (2*2)/(3*2) + 4/6 -> 4/6 + 4/6\n// 2A. Combines numerators, e.g. 4/6 + 4/6 ->  e.g. 2/5 + 4/5 --> (2+4)/5\n// 2B. Adds numerators together, e.g. (2+4)/5 -> 6/5\n// Returns a Node.Status object with substeps\nfunction addConstantFractions(node) {\n  let newNode = node.cloneDeep();\n\n  if (!Node.Type.isOperator(node) || node.op !== '+') {\n    return Node.Status.noChange(node);\n  }\n  if (!node.args.every(n => Node.Type.isIntegerFraction(n, true))) {\n    return Node.Status.noChange(node);\n  }\n  const denominators = node.args.map(fraction => {\n    return parseFloat(evaluate(fraction.args[1]));\n  });\n\n  const substeps = [];\n  let status;\n\n  // 1A. First create the common denominator if needed\n  // e.g. 2/6 + 1/4 -> (2*2)/(6*2) + (1*3)/(4*3)\n  if (!denominators.every(denominator => denominator === denominators[0])) {\n    status = makeCommonDenominator(newNode);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n\n    // 1B. Multiply out the denominators\n    status = evaluateDenominators(newNode);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n\n    // 1B. Multiply out the numerators\n    status = evaluateNumerators(newNode);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // 2A. Now that they all have the same denominator, combine the numerators\n  // e.g. 2/3 + 5/3 -> (2+5)/3\n  status = combineNumeratorsAboveCommonDenominator(newNode);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // 2B. Finally, add the numerators together\n  status = addNumeratorsTogether(newNode);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // 2C. If the numerator is 0, simplify to just 0\n  status = reduceNumerator(newNode);\n  if (status.hasChanged()) {\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // 2D. If we can simplify the fraction, do so\n  status = divideByGCD(newNode);\n  if (status.hasChanged()) {\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.ADD_FRACTIONS, node, newNode, true, substeps);\n}\n\n// Given a + operation node with a list of fraction nodes as args that all have\n// the same denominator, add them together. e.g. 2/3 + 5/3 -> (2+5)/3\n// Returns the new node.\nfunction combineNumeratorsAboveCommonDenominator(node) {\n  let newNode = node.cloneDeep();\n\n  const commonDenominator = newNode.args[0].args[1];\n  const numeratorArgs = [];\n  newNode.args.forEach(fraction => {\n    numeratorArgs.push(fraction.args[0]);\n  });\n  const newNumerator = Node.Creator.parenthesis(\n    Node.Creator.operator('+', numeratorArgs));\n\n  newNode = Node.Creator.operator('/', [newNumerator, commonDenominator]);\n  return Node.Status.nodeChanged(\n    ChangeTypes.COMBINE_NUMERATORS, node, newNode);\n}\n\n// Given a node with a numerator that is an addition node, will add\n// all the numerators and return the result\nfunction addNumeratorsTogether(node) {\n  const newNode = node.cloneDeep();\n\n  newNode.args[0] = Node.Creator.constant(evaluate(newNode.args[0]));\n  return Node.Status.nodeChanged(\n    ChangeTypes.ADD_NUMERATORS, node, newNode);\n}\n\nfunction reduceNumerator(node) {\n  let newNode = node.cloneDeep();\n\n  if (newNode.args[0].value === '0') {\n    newNode = Node.Creator.constant(0);\n    return Node.Status.nodeChanged(\n      ChangeTypes.REDUCE_ZERO_NUMERATOR, node, newNode);\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// Takes `node`, a sum of fractions, and returns a node that's a sum of\n// fractions with denominators that evaluate to the same common denominator\n// e.g. 2/6 + 1/4 -> (2*2)/(6*2) + (1*3)/(4*3)\n// Returns the new node.\nfunction makeCommonDenominator(node) {\n  const newNode = node.cloneDeep();\n\n  const denominators = newNode.args.map(fraction => {\n    return parseFloat(fraction.args[1].value);\n  });\n  const commonDenominator = math.lcm(...denominators);\n\n  newNode.args.forEach((child, i) => {\n    // missingFactor is what we need to multiply the top and bottom by\n    // so that the denominator is the LCD\n    const missingFactor = commonDenominator / denominators[i];\n    if (missingFactor !== 1) {\n      const missingFactorNode = Node.Creator.constant(missingFactor);\n      const newNumerator = Node.Creator.parenthesis(\n        Node.Creator.operator('*', [child.args[0], missingFactorNode]));\n      const newDeominator = Node.Creator.parenthesis(\n        Node.Creator.operator('*', [child.args[1], missingFactorNode]));\n      newNode.args[i] = Node.Creator.operator('/', [newNumerator, newDeominator]);\n    }\n  });\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.COMMON_DENOMINATOR, node, newNode);\n}\n\nfunction evaluateDenominators(node) {\n  const newNode = node.cloneDeep();\n\n  newNode.args.map(fraction => {\n    fraction.args[1] = Node.Creator.constant(evaluate(fraction.args[1]));\n  });\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.MULTIPLY_DENOMINATORS, node, newNode);\n}\n\nfunction evaluateNumerators(node) {\n  const newNode = node.cloneDeep();\n\n  newNode.args.map(fraction => {\n    fraction.args[0] = Node.Creator.constant(evaluate(fraction.args[0]));\n  });\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.MULTIPLY_NUMERATORS, node, newNode);\n}\n\nmodule.exports = addConstantFractions;\n","const addConstantFractions = require('./addConstantFractions');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst evaluate = require('../../util/evaluate');\nconst Node = require('../../node');\n\n// Adds a constant to a fraction by:\n// - collapsing the fraction to decimal if the constant is not an integer\n//   e.g. 5.3 + 1/2 -> 5.3 + 0.2\n// - turning the constant into a fraction with the same denominator if it is\n//   an integer, e.g. 5 + 1/2 -> 10/2 + 1/2\nfunction addConstantAndFraction(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '+' || node.args.length !== 2) {\n    return Node.Status.noChange(node);\n  }\n\n  const firstArg = node.args[0];\n  const secondArg = node.args[1];\n  let constNode, fractionNode;\n  if (Node.Type.isConstant(firstArg)) {\n    if (Node.Type.isIntegerFraction(secondArg)) {\n      constNode = firstArg;\n      fractionNode = secondArg;\n    }\n    else {\n      return Node.Status.noChange(node);\n    }\n  }\n  else if (Node.Type.isConstant(secondArg)) {\n    if (Node.Type.isIntegerFraction(firstArg)) {\n      constNode = secondArg;\n      fractionNode = firstArg;\n    }\n    else {\n      return Node.Status.noChange(node);\n    }\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n\n  let newNode = node.cloneDeep();\n  let substeps = [];\n  // newConstNode and newFractionNode will end up both constants, or both\n  // fractions. I'm naming them based on their original form so we can keep\n  // track of which is which.\n  let newConstNode, newFractionNode;\n  let changeType;\n  if (Number.isInteger(parseFloat(constNode.value))) {\n    const denominatorNode = fractionNode.args[1];\n    const denominatorValue = parseInt(denominatorNode);\n    const constNodeValue = parseInt(constNode.value);\n    const newNumeratorNode = Node.Creator.constant(\n      constNodeValue * denominatorValue);\n    newConstNode = Node.Creator.operator(\n      '/', [newNumeratorNode, denominatorNode]);\n    newFractionNode = fractionNode;\n    changeType = ChangeTypes.CONVERT_INTEGER_TO_FRACTION;\n  }\n  else {\n    // round to 4 decimal places\n    let dividedValue = evaluate(fractionNode);\n    if (dividedValue < 1) {\n      dividedValue = parseFloat(dividedValue.toPrecision(4));\n    }\n    else {\n      dividedValue = parseFloat(dividedValue.toFixed(4));\n    }\n    newFractionNode = Node.Creator.constant(dividedValue);\n    newConstNode = constNode;\n    changeType = ChangeTypes.DIVIDE_FRACTION_FOR_ADDITION;\n  }\n\n  if (Node.Type.isConstant(firstArg)) {\n    newNode.args[0] = newConstNode;\n    newNode.args[1] = newFractionNode;\n  }\n  else {\n    newNode.args[0] = newFractionNode;\n    newNode.args[1] = newConstNode;\n  }\n\n  substeps.push(Node.Status.nodeChanged(changeType, node, newNode));\n  newNode = Node.Status.resetChangeGroups(newNode);\n\n  // If we changed an integer to a fraction, we need to add the steps for\n  // adding the fractions.\n  if (changeType === ChangeTypes.CONVERT_INTEGER_TO_FRACTION) {\n    const addFractionStatus = addConstantFractions(newNode);\n    substeps = substeps.concat(addFractionStatus.substeps);\n  }\n  // Otherwise, add the two constants\n  else {\n    const evalNode = Node.Creator.constant(evaluate(newNode));\n    substeps.push(Node.Status.nodeChanged(\n      ChangeTypes.SIMPLIFY_ARITHMETIC, newNode, evalNode));\n  }\n\n  const lastStep = substeps[substeps.length - 1];\n  newNode = Node.Status.resetChangeGroups(lastStep.newNode);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.SIMPLIFY_ARITHMETIC, node, newNode, true, substeps);\n}\n\nmodule.exports = addConstantAndFraction;\n","const addConstantAndFraction = require('../fractionsSearch/addConstantAndFraction');\nconst addConstantFractions = require('../fractionsSearch/addConstantFractions');\nconst arithmeticSearch = require('../arithmeticSearch');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// Evaluates a sum of constant numbers and integer fractions to a single\n// constant number or integer fraction. e.g. e.g. 2/3 + 5 + 5/2 => 49/6\n// Returns a Node.Status object.\nfunction evaluateConstantSum(node) {\n  if (Node.Type.isParenthesis(node)) {\n    node = node.content;\n  }\n  if (!Node.Type.isOperator(node) || node.op !== '+') {\n    return Node.Status.noChange(node);\n  }\n  if (node.args.some(node => !Node.Type.isConstantOrConstantFraction(node))) {\n    return Node.Status.noChange(node);\n  }\n\n  // functions needed to evaluate the sum\n  const summingFunctions = [\n    arithmeticSearch,\n    addConstantFractions,\n    addConstantAndFraction,\n  ];\n  for (let i = 0; i < summingFunctions.length; i++) {\n    const status = summingFunctions[i](node);\n    if (status.hasChanged()) {\n      if (Node.Type.isConstantOrConstantFraction(status.newNode)) {\n        return status;\n      }\n    }\n  }\n\n  let newNode = node.cloneDeep();\n  const substeps = [];\n  let status;\n\n  // STEP 1: group fractions and constants separately\n  status = groupConstantsAndFractions(newNode);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  const constants = newNode.args[0];\n  const fractions = newNode.args[1];\n\n  // STEP 2A: evaluate arithmetic IF there's > 1 constant\n  // (which is the case if it's a list surrounded by parenthesis)\n  if (Node.Type.isParenthesis(constants)) {\n    const constantList = constants.content;\n    const evaluateStatus = arithmeticSearch(constantList);\n    status = Node.Status.childChanged(newNode, evaluateStatus, 0);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // STEP 2B: add fractions IF there's > 1 fraction\n  // (which is the case if it's a list surrounded by parenthesis)\n  if (Node.Type.isParenthesis(fractions)) {\n    const fractionList = fractions.content;\n    const evaluateStatus = addConstantFractions(fractionList);\n    status = Node.Status.childChanged(newNode, evaluateStatus, 1);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // STEP 3: combine the evaluated constant and fraction\n  // the fraction might have simplified to a constant (e.g. 1/3 + 2/3 -> 2)\n  // so we just call evaluateConstantSum again to cycle through\n  status = evaluateConstantSum(newNode);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.SIMPLIFY_ARITHMETIC, node, newNode, true, substeps);\n}\n\n// If we can't combine using one of those functions, there's a mix of > 2\n// fractions and constants. So we need to group them together so we can later\n// add them.\n// Expects a node that is a sum of integer fractions and constants.\n// Returns a Node.Status object.\n// e.g. 2/3 + 5 + 5/2 => (2/3 + 5/2) + 5\nfunction groupConstantsAndFractions(node) {\n  let fractions = node.args.filter(Node.Type.isIntegerFraction);\n  let constants = node.args.filter(Node.Type.isConstant);\n\n  if (fractions.length === 0 || constants.length === 0) {\n    throw Error('expected both integer fractions and constants, got ' + node);\n  }\n\n  if (fractions.length + constants.length !== node.args.length) {\n    throw Error('can only evaluate integer fractions and constants');\n  }\n\n  constants = constants.map(node => {\n    // set the changeGroup - this affects both the old and new node\n    node.changeGroup = 1;\n    // clone so that node and newNode aren't stored in the same memory\n    return node.cloneDeep();\n  });\n  // wrap in parenthesis if there's more than one, to group them\n  if (constants.length > 1) {\n    constants = Node.Creator.parenthesis(Node.Creator.operator('+', constants));\n  }\n  else {\n    constants = constants[0];\n  }\n\n  fractions = fractions.map(node => {\n    // set the changeGroup - this affects both the old and new node\n    node.changeGroup = 2;\n    // clone so that node and newNode aren't stored in the same memory\n    return node.cloneDeep();\n  });\n  // wrap in parenthesis if there's more than one, to group them\n  if (fractions.length > 1) {\n    fractions = Node.Creator.parenthesis(Node.Creator.operator('+', fractions));\n  }\n  else {\n    fractions = fractions[0];\n  }\n\n  const newNode = Node.Creator.operator('+', [constants, fractions]);\n  return Node.Status.nodeChanged(\n    ChangeTypes.COLLECT_LIKE_TERMS, node, newNode);\n}\n\nmodule.exports = evaluateConstantSum;\n","const checks = require('../../checks');\nconst evaluateConstantSum = require('./evaluateConstantSum');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\n\n// If possible, adds together a list of nodes . Returns a Node.Status object.\nfunction addLikeTerms(node, polynomialOnly=false) {\n  if (!Node.Type.isOperator(node)) {\n    return Node.Status.noChange(node);\n  }\n  let status;\n\n  if (!polynomialOnly) {\n    status = evaluateConstantSum(node);\n    if (status.hasChanged()) {\n      return status;\n    }\n  }\n\n  status = addLikePolynomialTerms(node);\n  if (status.hasChanged()) {\n    return status;\n  }\n\n  status = addLikeNthRootTerms(node);\n  if (status.hasChanged()) {\n    return status;\n  }\n\n  return Node.Status.noChange(node);\n}\n\n// If possible, adds together a list of polynomial term nodes.\nfunction addLikePolynomialTerms(node) {\n  if (!checks.canAddLikeTerms.canAddLikeTermPolynomialNodes(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  return addLikeTermNodes(\n    node, Node.PolynomialTerm, ChangeTypes.ADD_POLYNOMIAL_TERMS);\n}\n\n// If possible, adds together a list of nth root term nodes.\nfunction addLikeNthRootTerms(node) {\n  if (!checks.canAddLikeTerms.canAddLikeTermNthRootNodes(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  return addLikeTermNodes(\n    node, Node.NthRootTerm, ChangeTypes.ADD_NTH_ROOTS);\n}\n\n// Helper function for adding together a list of nodes\n// belonging to a subclass of Term\nfunction addLikeTermNodes(node, termSubclass, changeType) {\n  const substeps = [];\n  let newNode = node.cloneDeep();\n\n  // STEP 1: If any nodes have no coefficient, make it have coefficient 1\n  // (this step only happens under certain conditions and later steps might\n  // happen even if step 1 does not)\n  let status = addPositiveOneCoefficient(newNode, termSubclass);\n  if (status.hasChanged()) {\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // STEP 2: If any nodes have a unary minus, make it have coefficient -1\n  // (this step only happens under certain conditions and later steps might\n  // happen even if step 2 does not)\n  status = addNegativeOneCoefficient(newNode, termSubclass);\n  if (status.hasChanged()) {\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // STEP 3: group the coefficients in a sum\n  status = groupCoefficientsForAdding(newNode, termSubclass);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // STEP 4: evaluate the sum (could include fractions)\n  status = evaluateCoefficientSum(newNode, termSubclass);\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  return Node.Status.nodeChanged(\n    changeType, node, newNode, true, substeps);\n}\n\n// Given a sum of like terms, changes any term with no coefficient\n// into a term with an explicit coefficient of 1. This is for pedagogy, and\n// makes the adding coefficients step clearer.\n// e.g. 2x + x -> 2x + 1x\n// Returns a Node.Status object.\nfunction addPositiveOneCoefficient(node, termSubclass) {\n  const newNode = node.cloneDeep();\n  let change = false;\n\n  let changeGroup = 1;\n  newNode.args.forEach((child, i) => {\n    const term = new termSubclass(child);\n    if (term.getCoeffValue() === 1) {\n      newNode.args[i] = Node.Creator.term(\n        term.getBaseNode(),\n        term.getExponentNode(),\n        Node.Creator.constant(1),\n        true /* explicit coefficient */);\n\n      newNode.args[i].changeGroup = changeGroup;\n      node.args[i].changeGroup = changeGroup; // note that this is the \"oldNode\"\n\n      change = true;\n      changeGroup++;\n    }\n  });\n\n  if (change) {\n    return Node.Status.nodeChanged(\n        ChangeTypes.ADD_COEFFICIENT_OF_ONE, node, newNode, false);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Given a sum of like terms, changes any term with a unary minus\n// coefficient into a term with an explicit coefficient of -1. This is for\n// pedagogy, and makes the adding coefficients step clearer.\n// e.g. 2x - x -> 2x - 1x\n// Returns a Node.Status object.\nfunction addNegativeOneCoefficient(node, termSubclass) {\n  const newNode = node.cloneDeep();\n  let change = false;\n\n  let changeGroup = 1;\n  newNode.args.forEach((child, i) => {\n    const term = new termSubclass(child);\n    if (term.getCoeffValue() === -1) {\n      newNode.args[i] = Node.Creator.term(\n        term.getBaseNode(),\n        term.getExponentNode(),\n        term.getCoeffNode(),\n        true /* explicit -1 coefficient */);\n\n      node.args[i].changeGroup = changeGroup; // note that this is the \"oldNode\"\n      newNode.args[i].changeGroup = changeGroup;\n\n      change = true;\n      changeGroup++;\n    }\n  });\n\n  if (change) {\n    return Node.Status.nodeChanged(\n      ChangeTypes.UNARY_MINUS_TO_NEGATIVE_ONE, node, newNode, false);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Given a sum of like terms, groups the coefficients\n// e.g. 2x^2 + 3x^2 + 5x^2 -> (2+3+5)x^2\n// Returns a Node.Status object.\nfunction groupCoefficientsForAdding(node, termSubclass) {\n  let newNode = node.cloneDeep();\n\n  const termList = newNode.args.map(n => new termSubclass(n));\n  const coefficientList = termList.map(term => term.getCoeffNode(true));\n  const sumOfCoefficents = Node.Creator.parenthesis(\n    Node.Creator.operator('+', coefficientList));\n  // TODO: changegroups should also be on the before node, on all the\n  // coefficients, but changegroups with term gets messy so let's tackle\n  // that later.\n  sumOfCoefficents.changeGroup = 1;\n\n  // terms that can be added together must share the same base\n  // name and exponent. Get that base and exponent from the first term\n  const firstTerm = termList[0];\n  const exponentNode = firstTerm.getExponentNode();\n  const baseNode = firstTerm.getBaseNode();\n  newNode = Node.Creator.term(\n    baseNode, exponentNode, sumOfCoefficents);\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.GROUP_COEFFICIENTS, node, newNode, false);\n}\n\n// Given a node of the form (2 + 4 + 5)x -- ie the coefficients have been\n// grouped for adding -- add the coefficients together to make a new coeffient\n// that is a constant or constant fraction.\nfunction evaluateCoefficientSum(node) {\n  // the node is now always a * node with the left child the coefficent sum\n  // e.g. (2 + 4 + 5) and the right node the symbol part e.g. x or y^2\n  // so we want to evaluate args[0]\n  const coefficientSum = node.cloneDeep().args[0];\n  const childStatus = evaluateConstantSum(coefficientSum);\n  return Node.Status.childChanged(node, childStatus, 0);\n}\n\nmodule.exports = addLikeTerms;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\n// If `node` is a product of terms where:\n// 1) at least one is a fraction\n// 2) either none are polynomial terms, OR\n//    at least one has a symbol in the denominator\n// then multiply them together.\n// e.g. 2 * 5/x -> (2*5)/x\n// e.g. 3 * 1/5 * 5/9 = (3*1*5)/(5*9)\n// e.g. 2x * 1/x -> (2x*1) / x\n// NOTE: The reason we exclude the case of polynomial terms is because\n// we do not want to combine 9/2 * x -> 9x / 2 (which is less readable).\n// Cases like 5/2 * x * y/5 will be handled in collect and combine.\n// TODO: add a step somewhere to remove common terms in numerator and\n// denominator (so the 5s would cancel out on the next step after this)\n// This step must happen after things have been distributed, or else the answer\n// will be formatted badly, so it's a tree search of its own.\n// Returns a Node.Status object.\nconst search = TreeSearch.postOrder(multiplyFractions);\n\nfunction multiplyFractions(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '*') {\n    return Node.Status.noChange(node);\n  }\n\n  // we need to use the verbose syntax for `some` here because isFraction\n  // can take more than one parameter\n  const atLeastOneFraction = node.args.some(\n    arg => Node.CustomType.isFraction(arg));\n  const hasPolynomialTerms = node.args.some(Node.PolynomialTerm.isPolynomialTerm);\n  const hasPolynomialInDenominatorTerms = node.args.some(hasPolynomialInDenominator);\n\n  if (!atLeastOneFraction || (hasPolynomialTerms && !hasPolynomialInDenominatorTerms)) {\n    return Node.Status.noChange(node);\n  }\n\n  const numeratorArgs = [];\n  const denominatorArgs = [];\n  node.args.forEach(operand => {\n    if (Node.CustomType.isFraction(operand)) {\n      const fraction = Node.CustomType.getFraction(operand);\n      numeratorArgs.push(fraction.args[0]);\n      denominatorArgs.push(fraction.args[1]);\n    }\n    else {\n      numeratorArgs.push(operand);\n    }\n  });\n\n  const newNumerator = Node.Creator.parenthesis(\n    Node.Creator.operator('*', numeratorArgs));\n  const newDenominator = denominatorArgs.length === 1\n    ? denominatorArgs[0]\n    : Node.Creator.parenthesis(Node.Creator.operator('*', denominatorArgs));\n\n  const newNode = Node.Creator.operator('/', [newNumerator, newDenominator]);\n  return Node.Status.nodeChanged(\n    ChangeTypes.MULTIPLY_FRACTIONS, node, newNode);\n}\n\n// Returns true if `node` has a polynomial in the denominator,\n// e.g. 5/x or 1/2x^2\nfunction hasPolynomialInDenominator(node) {\n  if (!(Node.CustomType.isFraction(node))) {\n    return false;\n  }\n\n  const fraction = Node.CustomType.getFraction(node);\n  const denominator = fraction.args[1];\n  return Node.PolynomialTerm.isPolynomialTerm(denominator);\n}\n\nmodule.exports = search;\n","const arithmeticSearch = require('../arithmeticSearch');\nconst checks = require('../../checks');\nconst ConstantOrConstantPower = require('./ConstantOrConstantPower');\nconst multiplyFractionsSearch = require('../multiplyFractionsSearch');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\nconst NthRoot = require('../functionsSearch/nthRoot');\n\n// Multiplies a list of nodes that are polynomial or constant power like terms.\n// Returns a node.\n// The polynomial nodes should *not* have coefficients. (multiplying\n// coefficients is handled in collecting like terms for multiplication)\nfunction multiplyLikeTerms(node, polynomialOnly=false) {\n  if (!Node.Type.isOperator(node)) {\n    return Node.Status.noChange(node);\n  }\n  let status;\n\n  if (!polynomialOnly && !checks.canMultiplyLikeTermConstantNodes(node)) {\n    status = arithmeticSearch(node);\n    if (status.hasChanged()) {\n      status.changeType = ChangeTypes.MULTIPLY_COEFFICIENTS;\n      return status;\n    }\n\n    status = multiplyFractionsSearch(node);\n    if (status.hasChanged()) {\n      status.changeType = ChangeTypes.MULTIPLY_COEFFICIENTS;\n      return status;\n    }\n  }\n\n  status = multiplyPolynomialTerms(node);\n  if (status.hasChanged()) {\n    status.changeType = ChangeTypes.MULTIPLY_COEFFICIENTS;\n    return status;\n  }\n\n  status = multiplyNthRoots(node);\n  if (status.hasChanged()) {\n    return status;\n  }\n\n  return Node.Status.noChange(node);\n}\n\nfunction multiplyNthRoots(node) {\n  if (!checks.canMultiplyLikeTermsNthRoots(node)){\n    return Node.Status.noChange(node);\n  }\n\n  let newNode = node.cloneDeep();\n\n  // Array of radicands of all the nthRoot terms being multiplied\n  const radicands = node.args.map(term => NthRoot.getRadicandNode(term));\n\n  // Multiply them\n  const newRadicandNode = Node.Creator.operator('*', radicands);\n\n  // All the args at this point have the same root,\n  // so we arbitrarily take the first one\n  const firstArg = node.args[0];\n  const rootNode = NthRoot.getRootNode(firstArg);\n\n  newNode = Node.Creator.nthRoot(newRadicandNode, rootNode);\n\n  return Node.Status.nodeChanged(ChangeTypes.MULTIPLY_NTH_ROOTS, node, newNode, false);\n}\n\nfunction multiplyPolynomialTerms(node) {\n  if (!checks.canMultiplyLikeTermPolynomialNodes(node) &&\n      !checks.canMultiplyLikeTermConstantNodes(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  const substeps = [];\n  let newNode = node.cloneDeep();\n\n  // STEP 1: If any term has no exponent, make it have exponent 1\n  // e.g. x -> x^1 (this is for pedagogy reasons)\n  // (this step only happens under certain conditions and later steps might\n  // happen even if step 1 does not)\n  let status = addOneExponent(newNode);\n  if (status.hasChanged()) {\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  // STEP 2: collect exponents to a single exponent sum\n  // e.g. x^1 * x^3 -> x^(1+3)\n  // e.g. 10^2 * 10^3 -> 10^(2+3)\n  if (checks.canMultiplyLikeTermConstantNodes(node)) {\n    status = collectConstantExponents(newNode);\n  }\n  else {\n    status = collectPolynomialExponents(newNode);\n  }\n  substeps.push(status);\n  newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // STEP 3: add exponents together.\n  // NOTE: This might not be a step if the exponents aren't all constants,\n  // but this case isn't that common and can be caught in other steps.\n  // e.g. x^(2+4+z)\n  // TODO: handle fractions, combining and collecting like terms, etc, here\n  const exponentSum = newNode.args[1].content;\n  const sumStatus = arithmeticSearch(exponentSum);\n  if (sumStatus.hasChanged()) {\n    status = Node.Status.childChanged(newNode, sumStatus, 1);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n  }\n\n  if (substeps.length === 1) { // possible if only step 2 happens\n    return substeps[0];\n  }\n  else {\n    return Node.Status.nodeChanged(\n      ChangeTypes.MULTIPLY_POLYNOMIAL_TERMS,\n      node, newNode, true, substeps);\n  }\n}\n\n// Given a product of polynomial or constant terms, changes any\n// term with no exponent\n// into a term with an explicit exponent of 1. This is for pedagogy, and\n// makes the adding exponents step clearer.\n// e.g. x^2 * x -> x^2 * x^1\n// e.g. 10^2 * 10 -> 10^2 * 10^1\n// Returns a Node.Status object.\nfunction addOneExponent(node) {\n  const newNode = node.cloneDeep();\n  let change = false;\n\n  let changeGroup = 1;\n  if (checks.canMultiplyLikeTermConstantNodes(node)) {\n    newNode.args.forEach((child, i) => {\n      if (Node.Type.isConstant(child)) { // true if child is a constant node, e.g 3\n        const base = ConstantOrConstantPower.getBaseNode(child);\n        const exponent = Node.Creator.constant(1);\n        newNode.args[i] = Node.Creator.operator('^', [base, exponent]);\n\n        newNode.args[i].changeGroup = changeGroup;\n        node.args[i].changeGroup = changeGroup; // note that this is the \"oldNode\"\n\n        change = true;\n        changeGroup++;\n      }\n    });\n  }\n  else {\n    newNode.args.forEach((child, i) => {\n      const polyTerm = new Node.PolynomialTerm(child);\n      if (!polyTerm.getExponentNode()) {\n        newNode.args[i] = Node.Creator.polynomialTerm(\n          polyTerm.getSymbolNode(),\n          Node.Creator.constant(1),\n          polyTerm.getCoeffNode());\n\n        newNode.args[i].changeGroup = changeGroup;\n        node.args[i].changeGroup = changeGroup; // note that this is the \"oldNode\"\n\n        change = true;\n        changeGroup++;\n      }\n    });\n  }\n\n  if (change) {\n    return Node.Status.nodeChanged(\n      ChangeTypes.ADD_EXPONENT_OF_ONE, node, newNode, false);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Given a product of constant terms, groups the exponents into a sum\n// e.g. 10^2 * 10^3 -> 10^(2+3)\n// Returns a Node.Status object.\nfunction collectConstantExponents(node) {\n  // If we're multiplying constant nodes together, they all share the same\n  // base. Get that from the first node.\n  const baseNode = ConstantOrConstantPower.getBaseNode(node.args[0]);\n  // The new exponent will be a sum of exponents (an operation, wrapped in\n  // parens) e.g. 10^(3+4+5)\n  const exponentNodeList = node.args.map(\n    ConstantOrConstantPower.getExponentNode);\n  const newExponent = Node.Creator.parenthesis(\n    Node.Creator.operator('+', exponentNodeList));\n  const newNode = Node.Creator.operator('^', [baseNode, newExponent]);\n  return Node.Status.nodeChanged(\n    ChangeTypes.COLLECT_CONSTANT_EXPONENTS, node, newNode);\n}\n\n// Given a product of polynomial terms, groups the exponents into a sum\n// e.g. x^2 * x^3 * x^1 -> x^(2 + 3 + 1)\n// Returns a Node.Status object.\nfunction collectPolynomialExponents(node) {\n  const polynomialTermList = node.args.map(n => new Node.PolynomialTerm(n));\n\n  // If we're multiplying polynomial nodes together, they all share the same\n  // symbol. Get that from the first node.\n  const symbolNode = polynomialTermList[0].getSymbolNode();\n\n  // The new exponent will be a sum of exponents (an operation, wrapped in\n  // parens) e.g. x^(3+4+5)\n  const exponentNodeList = polynomialTermList.map(p => p.getExponentNode(true));\n  const newExponent = Node.Creator.parenthesis(\n    Node.Creator.operator('+', exponentNodeList));\n  const newNode = Node.Creator.polynomialTerm(symbolNode, newExponent, null);\n  return Node.Status.nodeChanged(\n    ChangeTypes.COLLECT_POLYNOMIAL_EXPONENTS, node, newNode);\n}\n\nmodule.exports = multiplyLikeTerms;\n","// Collects and combines like terms\n\nconst addLikeTerms = require('./addLikeTerms');\nconst checks = require('../../checks');\nconst multiplyLikeTerms = require('./multiplyLikeTerms');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst LikeTermCollector = require('./LikeTermCollector');\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\nconst termCollectorFunctions = {\n  '+': addLikeTerms,\n  '*': multiplyLikeTerms\n};\n\n// Iterates through the tree looking for like terms to collect and combine.\n// Will prioritize deeper expressions. Returns a Node.Status object.\nconst search = TreeSearch.postOrder(collectAndCombineLikeTerms);\n\n// Given an operator node, maybe collects and then combines if possible\n// e.g. 2x + 4x + y => 6x + y\n// e.g. 2x * x^2 * 5x => 10 x^4\nfunction collectAndCombineLikeTerms(node) {\n  if (node.op === '+') {\n    const status = collectAndCombineOperation(node);\n    if (status.hasChanged()) {\n      return status;\n    }\n    // we might also be able to just combine if they're all the same term\n    // e.g. 2x + 4x + x (doesn't need collecting)\n    return addLikeTerms(node, true);\n  }\n  else if (node.op === '*') {\n    // collect and combine involves there being coefficients pulled the front\n    // e.g. 2x * x^2 * 5x => (2*5) * (x * x^2 * x) => ... => 10 x^4\n    if (checks.canMultiplyLikeTermConstantNodes(node)) {\n      return multiplyLikeTerms(node, true);\n    }\n    const status = collectAndCombineOperation(node);\n    if (status.hasChanged()) {\n      // make sure there's no * between the coefficient and the symbol part\n      status.newNode.implicit = true;\n      return status;\n    }\n    // we might also be able to just combine polynomial terms\n    // e.g. x * x^2 * x => ... => x^4\n    return multiplyLikeTerms(node, true);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Collects and combines (if possible) the arguments of an addition or\n// multiplication\nfunction collectAndCombineOperation(node) {\n  let substeps = [];\n\n  const status = LikeTermCollector.collectLikeTerms(node.cloneDeep());\n  if (!status.hasChanged()) {\n    return status;\n  }\n\n  // STEP 1: collect like terms, e.g. 2x + 4x^2 + 5x => 4x^2 + (2x + 5x)\n  substeps.push(status);\n  let newNode = Node.Status.resetChangeGroups(status.newNode);\n\n  // STEP 2 onwards: combine like terms for each group that can be combined\n  // e.g. (x + 3x) + (2 + 2) has two groups\n  const combineSteps = combineLikeTerms(newNode);\n  if (combineSteps.length > 0) {\n    substeps = substeps.concat(combineSteps);\n    const lastStep = combineSteps[combineSteps.length - 1];\n    newNode = Node.Status.resetChangeGroups(lastStep.newNode);\n  }\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.COLLECT_AND_COMBINE_LIKE_TERMS,\n    node, newNode, true, substeps);\n}\n\n// step 2 onwards for collectAndCombineOperation\n// combine like terms for each group that can be combined\n// e.g. (x + 3x) + (2 + 2) has two groups\n// returns a list of combine steps\nfunction combineLikeTerms(node) {\n  const steps = [];\n  let newNode = node.cloneDeep();\n\n  for (let i = 0; i < node.args.length; i++) {\n    let child = node.args[i];\n    // All groups of terms will be surrounded by parenthesis\n    if (!Node.Type.isParenthesis(child)) {\n      continue;\n    }\n    child = child.content;\n    const childStatus = termCollectorFunctions[newNode.op](child);\n    if (childStatus.hasChanged()) {\n      const status = Node.Status.childChanged(newNode, childStatus, i);\n      steps.push(status);\n      newNode = Node.Status.resetChangeGroups(status.newNode);\n    }\n  }\n\n  return steps;\n}\n\nmodule.exports = search;\n","const arithmeticSearch = require('../arithmeticSearch');\nconst collectAndCombineSearch = require('../collectAndCombineSearch');\nconst rearrangeCoefficient = require('../basicsSearch/rearrangeCoefficient');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\nconst search = TreeSearch.postOrder(distribute);\n\n// Distributes through parenthesis.\n// e.g. 2(x+3) -> (2*x + 2*3)\n// e.g. -(x+5) -> (-x + -5)\n// Returns a Node.Status object.\nfunction distribute(node) {\n  if (Node.Type.isUnaryMinus(node)) {\n    return distributeUnaryMinus(node);\n  }\n  else if (Node.Type.isOperator(node, '*')) {\n    return distributeAndSimplifyMultiplication(node);\n  }\n  else if (Node.Type.isOperator(node, '^')) {\n    return expandBase(node);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Expand a power node with a non-constant base and a positive exponent > 1\n// e.g. (nthRoot(x, 2))^2 -> nthRoot(x, 2) * nthRoot(x, 2)\n// e.g. (2x + 3)^2 -> (2x + 3) (2x + 3)\nfunction expandBase (node) {\n  // Must be a power node and the exponent must be a constant\n  // Base must either be an nthRoot or sum of terms\n  if (!Node.Type.isOperator(node, '^')) {\n    return Node.Status.noChange(node);\n  }\n  const base = Node.Type.isParenthesis(node.args[0])\n        ? node.args[0].content\n        : node.args[0];\n\n  const exponent = Node.Type.isParenthesis(node.args[1])\n        ? node.args[1].content\n        : node.args[1];\n\n  const exponentValue = parseFloat(exponent.value);\n\n  // Exponent should be a positive integer\n  if (!(Number.isInteger(exponentValue) && exponentValue > 1)) {\n    return Node.Status.noChange(node);\n  }\n\n  if (!Node.Type.isFunction(base, 'nthRoot') && !(Node.Type.isOperator(base, '+') || Node.Type.isOperator(base, '*') || Node.Type.isOperator(base, '/'))) {\n    return Node.Status.noChange(node);\n  }\n\n  // If the base is an nthRoot node, it doesn't need the parenthesis\n  const expandedBase = Node.Type.isFunction(base, 'nthRoot')\n        ? base\n        : node.args[0];\n  let expandedNode\n  const substeps = [];\n  let status;\n\n\n  if (Node.Type.isFunction(base, 'nthRoot')) {\n    expandedNode = Node.Creator.operator('*', Array(parseFloat(exponent.value)).fill(expandedBase));\n    return Node.Status.nodeChanged(\n      ChangeTypes.EXPAND_EXPONENT, node, expandedNode, false);\n  } else if (Node.Type.isOperator(base, '+')) {\n    // fpiou (modification du code pour permettre le dveloppement (a+b)^2 = a^2+2*a*b+b^2))\n    acarre = Node.Creator.operator('^',[base.args[0],exponent])\n    bcarre = Node.Creator.operator('^',[base.args[1],exponent]) \n    doubleproduit = Node.Creator.operator('*',[ Node.Creator.constant(2),Node.Creator.operator('*',base.args)])\n    expandedNode = Node.Creator.operator('+',[acarre,doubleproduit,bcarre])\n    status = Node.Status.nodeChanged(\n      ChangeTypes.EXPAND_EXPONENT, node, expandedNode, false)\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n    const childStatus = simplify(newNode);\n    if (childStatus.hasChanged()) {\n      status = Node.Status.childChanged(newNode, childStatus);\n      substeps.push(status);\n      newNode = Node.Status.resetChangeGroups(status.newNode);\n    }\n    if (substeps.length === 1) {\n      return substeps[0];\n    }\n    return Node.Status.nodeChanged(\n      ChangeTypes.DISTRIBUTE, node, newNode, false, substeps);\n  } else if (Node.Type.isOperator(base, '*')) {\n    // fpiou (modification du code pour permettre le \"dveloppement\" (a*b)^2 = a^2*b^2))\n    for (let i=0;i<base.args.length;i++) {\n      base.args[i] = Node.Creator.operator('^',[base.args[i],exponent])\n    }\n    return Node.Status.nodeChanged(\n      ChangeTypes.EXPAND_EXPONENT, node, base, false);\n  } else if (Node.Type.isOperator(base, '/')) {\n    for (let i=0;i<2;i++) {\n      base.args[i] = Node.Creator.operator('^',[base.args[i],exponent])\n    }\n    return Node.Status.nodeChanged(\n      ChangeTypes.EXPAND_EXPONENT, node, base, false);\n  }\n}\n\n// Distributes unary minus into a parenthesis node.\n// e.g. -(4*9*x^2) --> (-4 * 9  * x^2)\n// e.g. -(x + y - 5) --> (-x + -y + 5)\n// Returns a Node.Status object.\nfunction distributeUnaryMinus(node) {\n  if (!Node.Type.isUnaryMinus(node)) {\n    return Node.Status.noChange(node);\n  }\n  const unaryContent = node.args[0];\n  if (!Node.Type.isParenthesis(unaryContent)) {\n    return Node.Status.noChange(node);\n  }\n  const content = unaryContent.content;\n  if (!Node.Type.isOperator(content)) {\n    return Node.Status.noChange(node);\n  }\n  const newContent = content.cloneDeep();\n  node.changeGroup = 1;\n  // For multiplication and division, we can push the unary minus in to\n  // the first argument.\n  // e.g. -(2/3) -> (-2/3)    -(4*9*x^2) --> (-4 * 9  * x^2)\n  if (content.op === '*' || content.op === '/') {\n    newContent.args[0] = Negative.negate(newContent.args[0]);\n    newContent.args[0].changeGroup = 1;\n    const newNode = Node.Creator.parenthesis(newContent);\n    return Node.Status.nodeChanged(\n      ChangeTypes.DISTRIBUTE_NEGATIVE_ONE, node, newNode, false);\n  }\n  else if (content.op === '+') {\n    // Now we know `node` is of the form -(x + y + ...).\n    // We want to now return (-x + -y + ....)\n    // If any term is negative, we make it positive it right away\n    // e.g. -(2-4) => -2 + 4\n    const newArgs = newContent.args.map(arg => {\n      const newArg = Negative.negate(arg);\n      newArg.changeGroup = 1;\n      return newArg;\n    });\n    newContent.args = newArgs;\n    const newNode = Node.Creator.parenthesis(newContent);\n    return Node.Status.nodeChanged(\n      ChangeTypes.DISTRIBUTE_NEGATIVE_ONE, node, newNode, false);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Distributes a pair of terms in a multiplication operation, if a pair\n// can be distributed. To be distributed, there must be two terms beside\n// each other, and at least one of them must be a parenthesis node.\n// e.g. 2*(3+x) or (4+x^2+x^3)*(x+3)\n// Returns a Node.Status object with substeps\nfunction distributeAndSimplifyMultiplication(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '*') {\n    return Node.Status.noChange(node);\n  }\n\n  // STEP 1: distribute with `distributeTwoNodes`\n  // e.g. x*(2+x) -> x*2 + x*x\n  // STEP 2: simplifications of each operand in the new sum with `simplify`\n  // e.g. x*2 + x*x -> ... -> 2x + x^2\n  for (let i = 0; i+1 < node.args.length; i++) {\n    if (!isParenthesisOfAddition(node.args[i]) &&\n        !isParenthesisOfAddition(node.args[i+1])) {\n      continue;\n    }\n    let newNode = node.cloneDeep();\n    const substeps = [];\n    let status;\n\n    const combinedNode = distributeTwoNodes(newNode.args[i], newNode.args[i+1]);\n    node.args[i].changeGroup = 1;\n    node.args[i+1].changeGroup = 1;\n    combinedNode.changeGroup = 1;\n\n    if (newNode.args.length > 2) {\n      newNode.args.splice(i, 2, combinedNode);\n      newNode.args[i].changeGroup = 1;\n    }\n    else {\n      newNode = combinedNode;\n      newNode.changeGroup = 1;\n    }\n\n    status = Node.Status.nodeChanged(\n      ChangeTypes.DISTRIBUTE, node, newNode, false);\n    substeps.push(status);\n    newNode = Node.Status.resetChangeGroups(status.newNode);\n\n    // case 1: there were more than two operands in this multiplication\n    // e.g. 3*7*(2+x)*(3+x)*(4+x) is a multiplication node with 5 children\n    // and the new node will be 3*(14+7x)*(3+x)*(4+x) with 4 children.\n    if (Node.Type.isOperator(newNode, '*')) {\n      const childStatus = simplifyWithParens(newNode.args[i]);\n      if (childStatus.hasChanged()) {\n        status = Node.Status.childChanged(newNode, childStatus, i);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n      }\n    }\n    // case 2: there were only two operands and we multiplied them together.\n    // e.g. 7*(2+x) -> (7*2 + 7*x)\n    // Now we can just simplify it.\n    else if (Node.Type.isParenthesis(newNode)){\n      status = simplifyWithParens(newNode);\n      if (status.hasChanged()) {\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n      }\n    }\n    else {\n      throw Error('Unsupported node type for distribution: ' + node);\n    }\n\n    if (substeps.length === 1) {\n      return substeps[0];\n    }\n\n    return Node.Status.nodeChanged(\n      ChangeTypes.DISTRIBUTE, node, newNode, false, substeps);\n  }\n  return Node.Status.noChange(node);\n}\n\n// Distributes two nodes together. At least one node must be parenthesis node\n// e.g. 2*(x+3) -> (2*x + 2*3)       (5+x)*x -> 5*x + x*x\n// e.g. (5+x)*(x+3) -> (5*x + 5*3 + x*x + x*3)\n// Returns a node.\nfunction distributeTwoNodes(firstNode, secondNode) {\n  // lists of terms we'll be multiplying together from each node\n  let firstArgs, secondArgs;\n  if (isParenthesisOfAddition(firstNode)) {\n    firstArgs = firstNode.content.args;\n  }\n  else {\n    firstArgs = [firstNode];\n  }\n\n  if (isParenthesisOfAddition(secondNode)) {\n    secondArgs = secondNode.content.args;\n  }\n  else {\n    secondArgs = [secondNode];\n  }\n  // the new operands under addition, now products of terms\n  const newArgs = [];\n\n  // if exactly one group contains at least one fraction, multiply the\n  // non-fraction group into the numerators of the fraction group\n  if ([firstArgs, secondArgs].filter(hasFraction).length === 1) {\n    const firstArgsHasFraction = hasFraction(firstArgs);\n    const fractionNodes = firstArgsHasFraction ? firstArgs : secondArgs;\n    const nonFractionTerm = firstArgsHasFraction ? secondNode : firstNode;\n    fractionNodes.forEach((node) => {\n      let arg;\n      if (isFraction(node)) {\n        let numerator = Node.Creator.operator('*', [node.args[0], nonFractionTerm]);\n        numerator = Node.Creator.parenthesis(numerator);\n        arg = Node.Creator.operator('/', [numerator, node.args[1]]);\n      }\n      else {\n        arg = Node.Creator.operator('*', [node, nonFractionTerm]);\n      }\n      arg.changeGroup = 1;\n      newArgs.push(arg);\n    });\n  }\n  // e.g. (4+x)(x+y+z) will become 4(x+y+z) + x(x+y+z) as an intermediate\n  // step.\n  else if (firstArgs.length > 1 && secondArgs.length > 1) {\n    firstArgs.forEach(leftArg => {\n      const arg = Node.Creator.operator('*', [leftArg, secondNode]);\n      arg.changeGroup = 1;\n      newArgs.push(arg);\n    });\n  }\n  else {\n    // a list of all pairs of nodes between the two arg lists\n    firstArgs.forEach(leftArg => {\n      secondArgs.forEach(rightArg => {\n        const arg = Node.Creator.operator('*', [leftArg, rightArg]);\n        arg.changeGroup = 1;\n        newArgs.push(arg);\n      });\n    });\n  }\n  return Node.Creator.parenthesis(Node.Creator.operator('+', newArgs));\n}\n\nfunction hasFraction(args) {\n  return args.filter(isFraction).length > 0;\n}\n\nfunction isFraction(node) {\n  return Node.Type.isOperator(node, '/');\n}\n\n// Simplifies a sum of terms (a result of distribution) that's in parens\n// (note that all results of distribution are in parens)\n// e.g. 2x*(4 + x) distributes to (2x*4 + 2x*x)\n// This is a separate function from simplify to make the flow more readable,\n// but this is literally just a wrapper around 'simplify'.\n// Returns a Node.Status object\nfunction simplifyWithParens(node) {\n  if (!Node.Type.isParenthesis(node)) {\n    throw Error('expected ' + node + ' to be a parenthesis node');\n  }\n\n  const status = simplify(node.content);\n  if (status.hasChanged()) {\n    return Node.Status.childChanged(node, status);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\n// Simplifies a sum of terms that are a result of distribution.\n// e.g. (2x+3)*(4x+5) -distribute-> 2x*(4x+5) + 3*(4x+5) <- 2 terms to simplify\n// e.g. 2x*(4x+5) --distribute--> 2x*4x + 2x*5 --simplify--> 8x^2 + 10x\n// Returns a Node.Status object.\nfunction simplify(node) {\n  const substeps = [];\n  const simplifyFunctions = [\n    arithmeticSearch,                       // e.g. 2*9 -> 18\n    rearrangeCoefficient,  // e.g. x*5 -> 5x\n    collectAndCombineSearch,                        // e.g 2x*4x -> 8x^2\n    distributeAndSimplifyMultiplication, // e.g. (2+x)(3+x) -> 2*(3+x) recurses\n    expandBase\n  ];\n\n  let newNode = node.cloneDeep();\n  for (let i = 0; i < newNode.args.length; i++) {\n    for (let j = 0; j < simplifyFunctions.length; j++) {\n      const childStatus = simplifyFunctions[j](newNode.args[i]);\n      if (childStatus.hasChanged()) {\n        const status = Node.Status.childChanged(newNode, childStatus, i);\n        substeps.push(status);\n        newNode = Node.Status.resetChangeGroups(status.newNode);\n      }\n    }\n  }\n\n  // possible in cases like 2(x + y) -> 2x + 2y -> doesn't need simplifying\n  if (substeps.length === 0) {\n    return Node.Status.noChange(node);\n  }\n  else {\n    return Node.Status.nodeChanged(\n      ChangeTypes.SIMPLIFY_TERMS, node, newNode, false, substeps);\n  }\n}\n\n// returns true if `node` is of the type (node + node + ...)\nfunction isParenthesisOfAddition(node) {\n  if (!Node.Type.isParenthesis(node)) {\n    return false;\n  }\n  const content = node.content;\n  return Node.Type.isOperator(content, '+');\n}\n\nmodule.exports = search;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\n// Searches for and simplifies any chains of division or nested division.\n// Returns a Node.Status object\nconst search = TreeSearch.preOrder(division);\n\nfunction division(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n  // e.g. 2/(x/6) => 2 * 6/x\n  let nodeStatus =  multiplyByInverse(node);\n  if (nodeStatus.hasChanged()) {\n    return nodeStatus;\n  }\n  // e.g. 2/x/6 -> 2/(x*6)\n  nodeStatus = simplifyDivisionChain(node);\n  if (nodeStatus.hasChanged()) {\n    return nodeStatus;\n  }\n  return Node.Status.noChange(node);\n}\n\n// If `node` is a fraction with a denominator that is also a fraction, multiply\n// by the inverse.\n// e.g. x/(2/3) -> x * 3/2\nfunction multiplyByInverse(node) {\n  let denominator = node.args[1];\n  if (Node.Type.isParenthesis(denominator)) {\n    denominator = denominator.content;\n  }\n  if (!Node.Type.isOperator(denominator) || denominator.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n  // At this point, we know that node is a fraction and denonimator is the\n  // fraction we need to inverse.\n  const inverseNumerator = denominator.args[1];\n  const inverseDenominator = denominator.args[0];\n  const inverseFraction = Node.Creator.operator(\n    '/', [inverseNumerator, inverseDenominator]);\n\n  const newNode = Node.Creator.operator('*', [node.args[0], inverseFraction]);\n  return Node.Status.nodeChanged(\n    ChangeTypes.MULTIPLY_BY_INVERSE, node, newNode);\n}\n\n// Simplifies any chains of division into a single division operation.\n// e.g. 2/x/6 -> 2/(x*6)\n// Returns a Node.Status object\nfunction simplifyDivisionChain(node) {\n  // check for a chain of division\n  const denominatorList = getDenominatorList(node);\n  // one for the numerator, and at least two terms in the denominator\n  if (denominatorList.length > 2) {\n    const numerator = denominatorList.shift();\n    // the new single denominator is all the chained denominators\n    // multiplied together, in parentheses.\n    const denominator = Node.Creator.parenthesis(\n      Node.Creator.operator('*', denominatorList));\n    const newNode = Node.Creator.operator('/', [numerator, denominator]);\n    return Node.Status.nodeChanged(\n      ChangeTypes.SIMPLIFY_DIVISION, node, newNode);\n  }\n  return Node.Status.noChange(node);\n}\n\n// Given a the denominator of a division node, returns all the nested\n// denominator nodess. e.g. 2/3/4/5 would return [2,3,4,5]\n// (note: all the numbers in the example are actually constant nodes)\nfunction getDenominatorList(denominator) {\n  let node = denominator;\n  const denominatorList = [];\n  while (node.op === '/') {\n    // unshift the denominator to the front of the list, and recurse on\n    // the numerator\n    denominatorList.unshift(node.args[1]);\n    node = node.args[0];\n  }\n  // unshift the final node, which wasn't a / node\n  denominatorList.unshift(node);\n  return denominatorList;\n}\n\nmodule.exports = search;\n","const divideByGCD = require('./divideByGCD');\nconst print = require('../../util/print');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\n\n// Used for cancelTerms to return a (possibly updated) numerator and denominator\nclass CancelOutStatus {\n  constructor(numerator, denominator, hasChanged=false) {\n    this.numerator = numerator;\n    this.denominator = denominator;\n    this.hasChanged = hasChanged;\n  }\n}\n\n// Cancels like terms in a fraction node\n// e.g. (2x^2 * 5) / 2x^2 => 5 / 1\n// Returns a Node.Status object\nfunction cancelLikeTerms(node) {\n  if (!Node.Type.isOperator(node) || node.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n\n  let newNode = node.cloneDeep();\n  const numerator = newNode.args[0];\n  const denominator = newNode.args[1];\n\n  // case 1: neither the numerator or denominator is a multiplication of terms\n  if (!isMultiplicationOfTerms(numerator) &&\n      !isMultiplicationOfTerms(denominator)) {\n    const cancelStatus = cancelTerms(numerator, denominator);\n\n    if (cancelStatus.hasChanged) {\n      newNode.args[0] = cancelStatus.numerator || Node.Creator.constant(1);\n      if (cancelStatus.denominator) {\n        newNode.args[1] = cancelStatus.denominator;\n      }\n      else {\n        // If we cancelled out the denominator, the node is now its numerator\n        // e.g. (2x*y) / 2x => y (note y isn't a fraction)\n        newNode = newNode.args[0];\n      }\n      return Node.Status.nodeChanged(\n        ChangeTypes.CANCEL_TERMS, node, newNode);\n    }\n    else {\n      return Node.Status.noChange(node);\n    }\n  }\n\n  // case 2: numerator is a multiplication of terms and denominator is not\n  // e.g. (2x^2 * 5) / 2x^2 => 5 / 1\n  // e.g. (x^2*y) / x  => x^(2 - 1) * y (<-- note that the denominator goes\n  // away because we always adjust the exponent in the numerator)\n  else if (isMultiplicationOfTerms(numerator) &&\n           !isMultiplicationOfTerms(denominator)) {\n    const numeratorArgs = Node.Type.isParenthesis(numerator) ?\n          numerator.content.args : numerator.args;\n    for (let i = 0; i < numeratorArgs.length; i++) {\n      const cancelStatus = cancelTerms(numeratorArgs[i], denominator);\n      if (cancelStatus.hasChanged) {\n        if (cancelStatus.numerator) {\n          numeratorArgs[i] = cancelStatus.numerator;\n        }\n        // if the cancelling out got rid of the numerator node, we remove it from\n        // the list\n        else {\n          numeratorArgs.splice(i, 1);\n          // if the numerator is now a \"multiplication\" of only one term,\n          // change it to just that term\n          if (numeratorArgs.length === 1) {\n            newNode.args[0] = numeratorArgs[0];\n          }\n        }\n        if (cancelStatus.denominator) {\n          newNode.args[1] = cancelStatus.denominator;\n        }\n        else {\n          // If we cancelled out the denominator, the node is now its numerator\n          // e.g. (2x*y) / 2x => y (note y isn't a fraction)\n          newNode = newNode.args[0];\n        }\n        return Node.Status.nodeChanged(\n          ChangeTypes.CANCEL_TERMS, node, newNode);\n      }\n    }\n    return Node.Status.noChange(node);\n  }\n\n  // case 3: denominator is a multiplication of terms and numerator is not\n  // e.g. 2x^2 / (2x^2 * 5) => 1 / 5\n  // e.g. x / (x^2*y) => x^(1-2) / y\n  else if (isMultiplicationOfTerms(denominator)\n           && !isMultiplicationOfTerms(numerator)) {\n    const denominatorArgs = Node.Type.isParenthesis(denominator) ?\n      denominator.content.args : denominator.args;\n    for (let i = 0; i < denominatorArgs.length; i++) {\n      const cancelStatus = cancelTerms(numerator, denominatorArgs[i]);\n      if (cancelStatus.hasChanged) {\n        newNode.args[0] = cancelStatus.numerator || Node.Creator.constant(1);\n        if (cancelStatus.denominator) {\n          denominatorArgs[i] = cancelStatus.denominator;\n        }\n        // if the cancelling out got rid of the denominator node, we remove it\n        // from the list\n        else {\n          denominatorArgs.splice(i, 1);\n          // if the denominator is now a \"multiplication\" of only one term,\n          // change it to just that term\n          if (denominatorArgs.length === 1) {\n            newNode.args[1] = denominatorArgs[0];\n          }\n        }\n        return Node.Status.nodeChanged(\n          ChangeTypes.CANCEL_TERMS, node, newNode);\n      }\n    }\n    return Node.Status.noChange(node);\n  }\n\n  // case 4: the numerator and denominator are both multiplications of terms\n  else {\n    const numeratorArgs = Node.Type.isParenthesis(numerator) ?\n      numerator.content.args : numerator.args;\n    const denominatorArgs = Node.Type.isParenthesis(denominator) ?\n      denominator.content.args : denominator.args;\n    for (let i = 0; i < numeratorArgs.length; i++) {\n      for (let j = 0; j < denominatorArgs.length; j++) {\n        const cancelStatus = cancelTerms(numeratorArgs[i], denominatorArgs[j]);\n        if (cancelStatus.hasChanged) {\n          if (cancelStatus.numerator) {\n            numeratorArgs[i] = cancelStatus.numerator;\n          }\n          // if the cancelling out got rid of the numerator node, we remove it\n          // from the list\n          else {\n            numeratorArgs.splice(i, 1);\n            // if the numerator is now a \"multiplication\" of only one term,\n            // change it to just that term\n            if (numeratorArgs.length === 1) {\n              newNode.args[0] = numeratorArgs[0];\n            }\n          }\n          if (cancelStatus.denominator) {\n            denominatorArgs[j] = cancelStatus.denominator;\n          }\n          // if the cancelling out got rid of the denominator node, we remove it\n          // from the list\n          else {\n            denominatorArgs.splice(j, 1);\n            // if the denominator is now a \"multiplication\" of only one term,\n            // change it to just that term\n            if (denominatorArgs.length === 1) {\n              newNode.args[1] = denominatorArgs[0];\n            }\n          }\n          return Node.Status.nodeChanged(\n            ChangeTypes.CANCEL_TERMS, node, newNode);\n        }\n      }\n    }\n    return Node.Status.noChange(node);\n  }\n}\n\n// Given a term in the numerator and a term in the denominator, cancels out\n// like terms if possible. See the cases below for possible things that can\n// be cancelled out and how they are cancelled out.\n// Returns the new nodes for numerator and denominator with the common terms\n// removed. If the entire numerator or denominator is cancelled out, it is\n// returned as null. e.g. 4, 4x => null, x\nfunction cancelTerms(numerator, denominator) {\n  // Deal with unary minuses by recursing on the argument\n  if (Node.Type.isUnaryMinus(numerator)) {\n    const cancelStatus = cancelTerms(numerator.args[0], denominator);\n    if (!cancelStatus.numerator) {\n      numerator = Node.Creator.constant(-1);\n    }\n    else if (Negative.isNegative(cancelStatus.numerator)) {\n      numerator = Negative.negate(cancelStatus.numerator);\n    }\n    else {\n      numerator.args[0] = cancelStatus.numerator;\n    }\n    denominator = cancelTerms.denominator;\n    return new CancelOutStatus(numerator, denominator, cancelStatus.hasChanged);\n  }\n  if (Node.Type.isUnaryMinus(denominator)) {\n    const cancelStatus = cancelTerms(numerator, denominator.args[0]);\n    numerator = cancelStatus.numerator;\n    if (cancelStatus.denominator) {\n      denominator.args[0] = cancelStatus.denominator;\n    }\n    else {\n      denominator = cancelStatus.denominator;\n      if (numerator) {\n        numerator = Negative.negate(numerator);\n      }\n      else {\n        numerator = Node.Creator.constant(-1);\n      }\n    }\n    return new CancelOutStatus(numerator, denominator, cancelStatus.hasChanged);\n  }\n\n  // Deal with parens similarily\n  if (Node.Type.isParenthesis(numerator)) {\n    const cancelStatus = cancelTerms(numerator.content, denominator);\n    if (cancelStatus.numerator) {\n      numerator.content = cancelStatus.numerator;\n    }\n    else {\n      // if the numerator was cancelled out, the numerator should be null\n      // and not null in parens.\n      numerator = cancelStatus.numerator;\n    }\n    denominator = cancelStatus.denominator;\n    return new CancelOutStatus(numerator, denominator, cancelStatus.hasChanged);\n  }\n  if (Node.Type.isParenthesis(denominator)) {\n    const cancelStatus = cancelTerms(numerator, denominator.content);\n    if (cancelStatus.denominator) {\n      denominator.content = cancelStatus.denominator;\n    }\n    else {\n      // if the denominator was cancelled out, the denominator should be null\n      // and not null in parens.\n      denominator = cancelStatus.denominator;\n    }\n    numerator = cancelStatus.numerator;\n    return new CancelOutStatus(numerator, denominator, cancelStatus.hasChanged);\n  }\n\n  // Now for the term cancelling ----\n\n  // case 1: the numerator term and denominator term are the same, so we cancel\n  // them out. e.g. (x+5)^100 / (x+5)^100 => null / null\n  if (print.ascii(numerator) === print.ascii(denominator)) {\n    return new CancelOutStatus(null, null, true);\n  }\n  // case 2: they're both exponent nodes with the same base\n  // e.g. (2x+5)^8 and (2x+5)^2\n  if (Node.Type.isOperator(numerator, '^') &&\n      Node.Type.isOperator(denominator, '^') &&\n      print.ascii(numerator.args[0]) === print.ascii(denominator.args[0])) {\n    const numeratorExponent = numerator.args[1];\n    let denominatorExponent =  denominator.args[1];\n    // wrap the denominatorExponent in parens, in case it's complicated.\n    // If the parens aren't needed, they'll be removed with\n    // removeUnnecessaryParens at the end of this step.\n    denominatorExponent = Node.Creator.parenthesis(denominatorExponent);\n    const newExponent = Node.Creator.parenthesis(\n      Node.Creator.operator('-', [numeratorExponent, denominatorExponent]));\n    numerator.args[1] = newExponent;\n    return new CancelOutStatus(numerator, null, true);\n  }\n  // case 3: they're both polynomial terms, check if they have the same symbol\n  // e.g. 4x^2 / 5x^2 => 4 / 5\n  // e.g. 4x^3 / 5x^2 => 4x^(3-2) / 5\n  // case 3.1: they're both polynomial terms with different symbols but with coefficients\n  // e.g 20x / 40y => x / 2y\n  // e.g 60x / 40y => 3x / 2y\n  // e.g 4x / 2y => 2x / y\n  if (Node.PolynomialTerm.isPolynomialTerm(numerator) &&\n      Node.PolynomialTerm.isPolynomialTerm(denominator)) {\n    const numeratorTerm = new Node.PolynomialTerm(numerator);\n    const denominatorTerm = new Node.PolynomialTerm(denominator);\n    if (numeratorTerm.getSymbolName() !== denominatorTerm.getSymbolName()) {\n      if (Node.Type.isOperator(numerator, '*') && Node.Type.isOperator(denominator, '*')) {\n        // case 3.1\n        return cancelCoeffs(numerator, denominator);\n      }\n      else {\n        return new CancelOutStatus(numerator, denominator);\n      }\n    }\n    const numeratorExponent = numeratorTerm.getExponentNode(true);\n    let denominatorExponent =  denominatorTerm.getExponentNode(true);\n    if (print.ascii(numeratorExponent) === print.ascii(denominatorExponent)) {\n      // note this returns null if there's no coefficient (ie it's 1)\n      numerator = numeratorTerm.getCoeffNode();\n    }\n    else {\n      // wrap the denominatorExponent in parens, in case it's complicated.\n      // If the parens aren't needed, they'll be removed with\n      // removeUnnecessaryParens at the end of this step.\n      denominatorExponent = Node.Creator.parenthesis(denominatorExponent);\n      const newExponent = Node.Creator.parenthesis(\n        Node.Creator.operator('-', [numeratorExponent, denominatorExponent]));\n      numerator = Node.Creator.polynomialTerm(\n        numeratorTerm.getSymbolNode(),\n        newExponent,\n        numeratorTerm.getCoeffNode());\n    }\n    denominator = denominatorTerm.getCoeffNode();\n    return new CancelOutStatus(numerator, denominator, true);\n  }\n\n  // case 4: the numerator is a constant and denominator is a polynomial term that has a coefficient\n  // or is multiplication node\n  // e.g. 2 / 4x -> 1 / 2x\n  // e.g. ignore cases like:  2 / a and 2 / x^2\n  if (Node.Type.isConstant(numerator)\n      && Node.Type.isOperator(denominator, '*')\n      && Node.PolynomialTerm.isPolynomialTerm(denominator)) {\n    const denominatorTerm = new Node.PolynomialTerm(denominator);\n\n    const coeff = denominatorTerm.getCoeffNode();\n    const variable = denominatorTerm.getSymbolNode();\n    const exponent = denominatorTerm.getExponentNode();\n\n    // simplify a constant fraction (e.g 2 / 4)\n    const frac = Node.Creator.operator('/', [numerator, coeff]);\n\n    let newCoeff = coeff.cloneDeep();\n    const reduceStatus = divideByGCD(frac);\n\n    if (!reduceStatus.hasChanged()) {\n      return new CancelOutStatus(numerator, denominator, false);\n    }\n\n    // Sometimes the fraction reduces to a constant e.g. 6 / 2 -> 3,\n    // in which case `newCoeff` (the denominator coefficient) should be null\n    if (Node.Type.isConstant(reduceStatus.newNode)) {\n      numerator = reduceStatus.newNode;\n      newCoeff = null;\n    }\n    else {\n      [numerator, newCoeff] = reduceStatus.newNode.args;\n    }\n    denominator = Node.Creator.polynomialTerm(variable, exponent, newCoeff);\n\n    return new CancelOutStatus(numerator, denominator, true);\n  }\n\n  // case 5: both numerator and denominator are numbers within a more complicated fraction\n  // e.g. (35 * nthRoot (7)) / (5 * nthRoot(5)) -> (7 * nthRoot(7)) / nthRoot(5)\n  if (Node.Type.isConstant(numerator) && Node.Type.isConstant(denominator)) {\n    const frac = Node.Creator.operator('/', [numerator, denominator]);\n    const reduceStatus = divideByGCD(frac);\n    if (!reduceStatus.hasChanged()) {\n      return new CancelOutStatus(numerator, denominator, false);\n    }\n    if (Node.Type.isConstant(reduceStatus.newNode)) {\n      // Denominator is a factor of numerator (e.g 4 / 2 -> 2)\n      return new CancelOutStatus(reduceStatus.newNode, null, true);\n    }\n\n    // Sometimes the fraction reduces to a constant e.g. 6 / 2 -> 3,\n    // in which case `newCoeff` (the denominator coefficient) should be null\n    if (Node.Type.isConstant(reduceStatus.newNode)) {\n      numerator = reduceStatus.newNode;\n      denominator = null;\n    }\n    else {\n      [numerator, denominator] = reduceStatus.newNode.args;\n    }\n\n    return new CancelOutStatus(numerator, denominator, true);\n  }\n\n  return new CancelOutStatus(numerator, denominator);\n}\n\n// Returns true if node is a multiplication of terms that can be cancelled out\n// e.g. 2 * 6^y => true\n// e.g. 2 + 6 => false\n// e.g. (2 * 6^y) => true\n// e.g. 2x^2 => false (polynomial terms are considered as one single term)\nfunction isMultiplicationOfTerms(node) {\n  if (Node.Type.isParenthesis(node)) {\n    return isMultiplicationOfTerms(node.content);\n  }\n  return (Node.Type.isOperator(node, '*') &&\n          !Node.PolynomialTerm.isPolynomialTerm(node));\n}\n\nfunction cancelCoeffs(numerator, denominator){\n  const denominatorTerm = new Node.PolynomialTerm(denominator);\n  const numeratorTerm = new Node.PolynomialTerm(numerator);\n\n  const denominatorCoeff = denominatorTerm.getCoeffNode();\n  const denominatorVariable = denominatorTerm.getSymbolNode();\n  const denominatorExponent = denominatorTerm.getExponentNode();\n\n  const numeratorCoeff = numeratorTerm.getCoeffNode();\n  const numeratorVariable = numeratorTerm.getSymbolNode();\n  const numeratorExponent = numeratorTerm.getExponentNode();\n\n  // simplify a constant fraction (e.g 2 / 4)\n  const frac = Node.Creator.operator('/', [numeratorCoeff, denominatorCoeff]);\n\n  const reduceStatus = divideByGCD(frac);\n\n  if (!reduceStatus.hasChanged()) {\n    return new CancelOutStatus(numerator, denominator, false);\n  }\n\n  // Sometimes the fraction reduces to a constant e.g. 6 / 2 -> 3,\n  // in which case the denominator coefficient should be null\n  let newDenominatorCoeff = null;\n  let newNumerator = null;\n  if (Node.Type.isConstant(reduceStatus.newNode)) {\n    newNumerator = Node.Creator.polynomialTerm(numeratorVariable, numeratorExponent, reduceStatus.newNode);\n    newDenominatorCoeff = null;\n  }\n  else {\n    newNumerator = Node.Creator.polynomialTerm(numeratorVariable, numeratorExponent, reduceStatus.newNode.args[0]);\n    newDenominatorCoeff = reduceStatus.newNode.args[1];\n  }\n  const newDenominator = Node.Creator.polynomialTerm(denominatorVariable, denominatorExponent, newDenominatorCoeff);\n\n  return new CancelOutStatus(newNumerator, newDenominator, true);\n}\n\nmodule.exports = cancelLikeTerms;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\n\n// Simplifies negative signs if possible\n// e.g. -1/-3 --> 1/3   4/-5 --> -4/5\n// Note that -4/5 doesn't need to be simplified.\n// Note that our goal is for the denominator to always be positive. If it\n// isn't, we can simplify signs.\n// Returns a Node.Status object\nfunction simplifySigns(fraction) {\n  if (!Node.Type.isOperator(fraction) || fraction.op !== '/') {\n    return Node.Status.noChange(fraction);\n  }\n  const oldFraction = fraction.cloneDeep();\n  let numerator = fraction.args[0];\n  let denominator = fraction.args[1];\n  // The denominator should never be negative.\n  if (Negative.isNegative(denominator)) {\n    denominator = Negative.negate(denominator);\n    const changeType = Negative.isNegative(numerator) ?\n      ChangeTypes.CANCEL_MINUSES :\n      ChangeTypes.SIMPLIFY_SIGNS;\n    numerator = Negative.negate(numerator);\n    const newFraction = Node.Creator.operator('/', [numerator, denominator]);\n    return Node.Status.nodeChanged(changeType, oldFraction, newFraction);\n  }\n  else {\n    return Node.Status.noChange(fraction);\n  }\n}\n\nmodule.exports = simplifySigns;\n","const arithmeticSearch = require('../arithmeticSearch');\nconst divideByGCD = require('./divideByGCD');\nconst Node = require('../../node');\n\n// Simplifies a polynomial term with a fraction as its coefficients.\n// e.g. 2x/4 --> x/2    10x/5 --> 2x\n// Also simplified negative signs\n// e.g. -y/-3 --> y/3   4x/-5 --> -4x/5\n// returns the new simplified node in a Node.Status object\nfunction simplifyPolynomialFraction(node) {\n  if (!Node.PolynomialTerm.isPolynomialTerm(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  const polyNode = new Node.PolynomialTerm(node.cloneDeep());\n  if (!polyNode.hasFractionCoeff()) {\n    return Node.Status.noChange(node);\n  }\n\n  const coefficientSimplifications = [\n    divideByGCD, // for integer fractions\n    arithmeticSearch, // for decimal fractions\n  ];\n\n  for (let i = 0; i < coefficientSimplifications.length; i++) {\n    const coefficientFraction = polyNode.getCoeffNode(); // a division node\n    const newCoeffStatus = coefficientSimplifications[i](coefficientFraction);\n    if (newCoeffStatus.hasChanged()) {\n      // we need to reset change groups because we're creating a new node\n      let newCoeff = Node.Status.resetChangeGroups(newCoeffStatus.newNode);\n      if (newCoeff.value === '1') {\n        newCoeff = null;\n      }\n      const exponentNode = polyNode.getExponentNode();\n      const newNode = Node.Creator.polynomialTerm(\n          polyNode.getSymbolNode(), exponentNode, newCoeff);\n      return Node.Status.nodeChanged(newCoeffStatus.changeType, node, newNode);\n    }\n  }\n\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = simplifyPolynomialFraction;\n","/*\n * Performs simpifications on fractions: adding and cancelling out.\n *\n * Note: division is represented in mathjs as an operator node with op '/'\n * and two args, where arg[0] is the numerator and arg[1] is the denominator\n\n// This module manipulates fractions with constants in the numerator and\n// denominator. For more complex/general fractions, see Fraction.js\n\n */\n\nconst addConstantAndFraction = require('./addConstantAndFraction');\nconst addConstantFractions = require('./addConstantFractions');\nconst cancelLikeTerms = require('./cancelLikeTerms');\nconst divideByGCD = require('./divideByGCD');\nconst simplifyFractionSigns = require('./simplifyFractionSigns');\nconst simplifyPolynomialFraction = require('./simplifyPolynomialFraction');\n\n\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\n\nconst SIMPLIFICATION_FUNCTIONS = [\n  // e.g. 2/3 + 5/6\n  addConstantFractions,\n  // e.g. 4 + 5/6 or 4.5 + 6/8\n  addConstantAndFraction,\n  // e.g. 2/-9  ->  -2/9      e.g. -2/-9  ->  2/9\n  simplifyFractionSigns,\n  // e.g. 8/12  ->  2/3 (divide by GCD 4)\n  divideByGCD,\n  // e.g. 2x/4 -> x/2 (divideByGCD but for coefficients of polynomial terms)\n  simplifyPolynomialFraction,\n  // e.g. (2x * 5) / 2x  ->  5\n  cancelLikeTerms,\n];\n\nconst search = TreeSearch.preOrder(simplifyFractions);\n\n// Look for step(s) to perform on a node. Returns a Node.Status object.\nfunction simplifyFractions(node) {\n  for (let i = 0; i < SIMPLIFICATION_FUNCTIONS.length; i++) {\n    const nodeStatus = SIMPLIFICATION_FUNCTIONS[i](node);\n    if (nodeStatus.hasChanged()) {\n      return nodeStatus;\n    }\n    else {\n      node = nodeStatus.newNode;\n    }\n  }\n  return Node.Status.noChange(node);\n}\n\n\nmodule.exports = search;\n","const math = require('../../node/MathjsInstance');\n\nconst ChangeTypes = require('../../ChangeTypes');\nconst evaluate = require('../../util/evaluate');\nconst Node = require('../../node');\n\n// Evaluates abs() function if it's on a single constant value.\n// Returns a Node.Status object.\nfunction absoluteValue(node) {\n  if (!Node.Type.isFunction(node, 'abs')) {\n    return Node.Status.noChange(node);\n  }\n  if (node.args.length > 1) {\n    return Node.Status.noChange(node);\n  }\n  let newNode = node.cloneDeep();\n  const argument = newNode.args[0];\n  if (Node.Type.isConstant(argument, true)) {\n    newNode = Node.Creator.constant(math.abs(evaluate(argument)));\n    return Node.Status.nodeChanged(\n      ChangeTypes.ABSOLUTE_VALUE, node, newNode);\n  }\n  else if (Node.Type.isConstantFraction(argument, true)) {\n    const newNumerator = Node.Creator.constant(\n      math.abs(evaluate(argument.args[0])));\n    const newDenominator =  Node.Creator.constant(\n      math.abs(evaluate(argument.args[1])));\n    newNode = Node.Creator.operator('/', [newNumerator, newDenominator]);\n    return Node.Status.nodeChanged(\n      ChangeTypes.ABSOLUTE_VALUE, node, newNode);\n  }\n  else {\n    return Node.Status.noChange(node);\n  }\n}\n\nmodule.exports = absoluteValue;\n","const absoluteValue = require('./absoluteValue');\n\nconst Node = require('../../node');\nconst NthRoot = require('./nthRoot');\nconst TreeSearch = require('../../TreeSearch');\n\nconst FUNCTIONS = [\n  NthRoot.nthRoot,\n  absoluteValue\n];\n\n// Searches through the tree, prioritizing deeper nodes, and evaluates\n// functions (e.g. abs(-4)) if possible.\n// Returns a Node.Status object.\nconst search = TreeSearch.postOrder(functions);\n\n// Evaluates a function call if possible. Returns a Node.Status object.\nfunction functions(node) {\n  if (!Node.Type.isFunction(node)) {\n    return Node.Status.noChange(node);\n  }\n\n  for (let i = 0; i < FUNCTIONS.length; i++) {\n    const nodeStatus = FUNCTIONS[i](node);\n    if (nodeStatus.hasChanged()) {\n      return nodeStatus;\n    }\n  }\n  return Node.Status.noChange(node);\n}\n\nmodule.exports = search;\n","const checks = require('../checks');\nconst Node = require('../node');\nconst Status = require('../node/Status');\n\nconst arithmeticSearch = require('./arithmeticSearch');\nconst basicsSearch = require('./basicsSearch');\nconst breakUpNumeratorSearch = require('./breakUpNumeratorSearch');\nconst collectAndCombineSearch = require('./collectAndCombineSearch');\nconst distributeSearch = require('./distributeSearch');\nconst divisionSearch = require('./divisionSearch');\nconst fractionsSearch = require('./fractionsSearch');\nconst functionsSearch = require('./functionsSearch');\nconst multiplyFractionsSearch = require('./multiplyFractionsSearch');\n\nconst flattenOperands = require('../util/flattenOperands');\nconst print = require('../util/print');\nconst removeUnnecessaryParens = require('../util/removeUnnecessaryParens');\n\n// Given a mathjs expression node, steps through simplifying the expression.\n// Returns a list of details about each step.\nfunction stepThrough(node, debug=false) {\n  if (debug) {\n    // eslint-disable-next-line\n    console.log('\\n\\nSimplifying: ' + print.ascii(node, false, true));\n  }\n\n  if (checks.hasUnsupportedNodes(node)) {\n    return [];\n  }\n\n  let nodeStatus;\n  const steps = [];\n\n  const originalExpressionStr = print.ascii(node);\n  const MAX_STEP_COUNT = 20;\n  let iters = 0;\n\n  // Now, step through the math expression until nothing changes\n  nodeStatus = step(node);\n  while (nodeStatus.hasChanged()) {\n    if (debug) {\n      logSteps(nodeStatus);\n    }\n    steps.push(removeUnnecessaryParensInStep(nodeStatus));\n\n    node = Status.resetChangeGroups(nodeStatus.newNode);\n    nodeStatus = step(node);\n\n    if (iters++ === MAX_STEP_COUNT) {\n      // eslint-disable-next-line\n      console.error('Math error: Potential infinite loop for expression: ' +\n                    originalExpressionStr + ', returning no steps');\n      return [];\n    }\n  }\n\n  return steps;\n}\n\n// Given a mathjs expression node, performs a single step to simplify the\n// expression. Returns a Node.Status object.\nfunction step(node) {\n  let nodeStatus;\n\n  node = flattenOperands(node);\n  node = removeUnnecessaryParens(node, true);\n\n  const simplificationTreeSearches = [\n    // Basic simplifications that we always try first e.g. (...)^0 => 1\n    basicsSearch,\n    // Simplify any division chains so there's at most one division operation.\n    // e.g. 2/x/6 -> 2/(x*6)        e.g. 2/(x/6) => 2 * 6/x\n    divisionSearch,\n    // Adding fractions, cancelling out things in fractions\n    fractionsSearch,\n    // e.g. addition of polynomial terms: 2x + 4x^2 + x => 4x^2 + 3x\n    // e.g. multiplication of polynomial terms: 2x * x * x^2 => 2x^3\n    // e.g. multiplication of constants: 10^3 * 10^2 => 10^5\n    collectAndCombineSearch,\n    // e.g. 2 + 2 => 4\n    arithmeticSearch,\n    // e.g. (2 + x) / 4 => 2/4 + x/4\n    breakUpNumeratorSearch,\n    // e.g. 3/x * 2x/5 => (3 * 2x) / (x * 5)\n    multiplyFractionsSearch,\n    // e.g. (2x + 3)(x + 4) => 2x^2 + 11x + 12\n    distributeSearch,\n    // e.g. abs(-4) => 4\n    functionsSearch,\n  ];\n\n  for (let i = 0; i < simplificationTreeSearches.length; i++) {\n    nodeStatus = simplificationTreeSearches[i](node);\n    // Always update node, since there might be changes that didn't count as\n    // a step. Remove unnecessary parens, in case one a step results in more\n    // parens than needed.\n    node = removeUnnecessaryParens(nodeStatus.newNode, true);\n    if (nodeStatus.hasChanged()) {\n      node = flattenOperands(node);\n      nodeStatus.newNode = node.cloneDeep();\n      return nodeStatus;\n    }\n    else {\n      node = flattenOperands(node);\n    }\n  }\n  return Node.Status.noChange(node);\n}\n\n// Removes unnecessary parens throughout the steps.\n// TODO: Ideally this would happen in NodeStatus instead.\nfunction removeUnnecessaryParensInStep(nodeStatus) {\n  if (nodeStatus.substeps.length > 0) {\n    nodeStatus.substeps.map(removeUnnecessaryParensInStep);\n  }\n\n  nodeStatus.oldNode = removeUnnecessaryParens(nodeStatus.oldNode, true);\n  nodeStatus.newNode = removeUnnecessaryParens(nodeStatus.newNode, true);\n  return nodeStatus;\n}\n\nfunction logSteps(nodeStatus) {\n  // eslint-disable-next-line\n  console.log(nodeStatus.changeType);\n  // eslint-disable-next-line\n  console.log(print.ascii(nodeStatus.newNode) + '\\n');\n\n  if (nodeStatus.substeps.length > 0) {\n    // eslint-disable-next-line\n    console.log('\\nsubsteps: ');\n    nodeStatus.substeps.forEach(substep => substep);\n  }\n}\n\nmodule.exports = stepThrough;\n","const math = require('../node/MathjsInstance');\nconst stepThrough = require('./stepThrough');\n\nfunction simplifyExpressionString(expressionString, debug=false) {\n  let exprNode;\n  try {\n    exprNode = math.parse(expressionString);\n  }\n  catch (err) {\n    return [];\n  }\n  if (exprNode) {\n    return stepThrough(exprNode, debug);\n  }\n  return [];\n}\n\nmodule.exports = simplifyExpressionString;\n","const ChangeTypes = require('../ChangeTypes');\nconst Equation = require('./Equation');\nconst Node = require('../node');\n\n// This represents the current equation we're solving.\n// As we move step by step, an equation might be updated. Functions return this\n// status object to pass on the updated equation and information on if/how it was\n// changed.\nclass Status {\n  constructor(changeType, oldEquation, newEquation, substeps=[]) {\n    if (!newEquation) {\n      throw Error('new equation isn\\'t defined');\n    }\n    if (changeType === undefined || typeof(changeType) !== 'string') {\n      throw Error('changetype isn\\'t valid');\n    }\n\n    this.changeType = changeType;\n    this.oldEquation = oldEquation;\n    this.newEquation = newEquation;\n    this.substeps = substeps;\n  }\n\n  hasChanged() {\n    return this.changeType !== ChangeTypes.NO_CHANGE;\n  }\n}\n\n// A wrapper around the Status constructor for the case where equation\n// hasn't been changed.\nStatus.noChange = function(equation) {\n  return new Status(ChangeTypes.NO_CHANGE, null, equation);\n};\n\nStatus.addLeftStep = function(equation, leftStep) {\n  const substeps = [];\n  leftStep.substeps.forEach(substep => {\n    substeps.push(Status.addLeftStep(equation, substep));\n  });\n  let oldEquation = null;\n  if (leftStep.oldNode) {\n    oldEquation = equation.clone();\n    oldEquation.leftNode = leftStep.oldNode;\n  }\n  const newEquation = equation.clone();\n  newEquation.leftNode = leftStep.newNode;\n  return new Status(\n    leftStep.changeType, oldEquation, newEquation, substeps);\n};\n\nStatus.addRightStep = function(equation, rightStep) {\n  const substeps = [];\n  rightStep.substeps.forEach(substep => {\n    substeps.push(Status.addRightStep(equation, substep));\n  });\n  let oldEquation = null;\n  if (rightStep.oldNode) {\n    oldEquation = equation.clone();\n    oldEquation.rightNode = rightStep.oldNode;\n  }\n  const newEquation = equation.clone();\n  newEquation.rightNode = rightStep.newNode;\n  return new Status(\n    rightStep.changeType, oldEquation, newEquation, substeps);\n};\n\nStatus.resetChangeGroups = function(equation) {\n  const leftNode = Node.Status.resetChangeGroups(equation.leftNode);\n  const rightNode = Node.Status.resetChangeGroups(equation.rightNode);\n  return new Equation(leftNode, rightNode, equation.comparator);\n};\n\nmodule.exports = Status;\n","// Operations on equation nodes\n\nconst ChangeTypes = require('../ChangeTypes');\nconst { canCrossMultiplication } = require('../checks');\nconst Equation = require('../equation/Equation');\nconst EquationStatus = require('../equation/Status');\nconst Negative = require('../Negative');\nconst Node = require('../node');\nconst Symbols = require('../Symbols');\n\nconst COMPARATOR_TO_INVERSE = {\n  '>': '<',\n  '>=': '<=',\n  '<': '>',\n  '<=': '>=',\n  '=': '='\n};\n\nconst EquationOperations = {};\n\n// Ensures that the given equation has the given symbolName on the left side,\n// by swapping the right and left sides if it is only in the right side.\n// So 3 = x would become x = 3.\nEquationOperations.ensureSymbolInLeftNode = function(equation, symbolName) {\n  const leftSideSymbolTerm = Symbols.getLastSymbolTerm(\n    equation.leftNode, symbolName);\n  const rightSideSymbolTerm = Symbols.getLastSymbolTerm(\n    equation.rightNode, symbolName);\n\n  if (!leftSideSymbolTerm) {\n    if (rightSideSymbolTerm) {\n      const comparator = COMPARATOR_TO_INVERSE[equation.comparator];\n      const oldEquation = equation;\n      const newEquation = new Equation(\n        equation.rightNode, equation.leftNode, comparator);\n      // no change groups are set for this step because everything changes, so\n      // they wouldn't be pedagogically helpful.\n      return new EquationStatus(\n        ChangeTypes.SWAP_SIDES, oldEquation, newEquation);\n    }\n    else {\n      throw Error('No term with symbol: ' + symbolName);\n    }\n  }\n  return EquationStatus.noChange(equation);\n};\n\n/**\n * \n * @param {*} equation \n * @param {*} symbolName \n * @returns \n */\nEquationOperations.crossMultiply = function(equation, symbolName) {\n  const cross = canCrossMultiplication(equation);\n\n  if (!cross) {\n    return EquationStatus.noChange(equation);\n  }\n\n  const left = equation.leftNode.cloneDeep();\n  const right = equation.rightNode.cloneDeep();\n\n  const oldEquation = equation;\n\n  if (Node.Type.isConstantOrConstantFraction(left.args[0]) &&\n      Node.PolynomialTerm.isPolynomialTerm(left.args[1]) &&\n      Node.Type.isConstantOrConstantFraction(right.args[0]) &&\n      Node.Type.isConstantOrConstantFraction(right.args[1])){\n    const newleft = Node.Creator.operator('*', [right.args[0], left.args[1]]);\n    left.args[1].changeGroup = 1\n    const newright = Node.Creator.operator('*', [right.args[1], left.args[0]]);\n    const newEquation = new Equation(\n        newleft, newright, equation.comparator);\n    return new EquationStatus(\n        ChangeTypes.CROSS_PRODUCT_EQUALITY, oldEquation, newEquation);\n  } else if (Node.Type.isConstantOrConstantFraction(left.args[0]) &&\n         Node.Type.isConstantOrConstantFraction(left.args[1]) &&\n         Node.Type.isConstantOrConstantFraction(right.args[0]) &&\n         Node.PolynomialTerm.isPolynomialTerm(right.args[1])) {\n    // Handle fractions\n    const newleft = Node.Creator.operator('*', [left.args[1], right.args[0]]);\n    right.args[0].changeGroup = 1\n    const newright = Node.Creator.operator('*', [left.args[0], right.args[1]]);\n    const newEquation = new Equation(\n      newleft, newright, equation.comparator);\n    return new EquationStatus(\n        ChangeTypes.CROSS_PRODUCT_EQUALITY, oldEquation, newEquation);\n  } else {\n    throw Error('No CROSS_PRODUCT_EQUALITY: ' + oldEquation.ascii());\n  }\n};\n\n\n// Ensures that a symbol is not in the denominator by multiplying\n// both sides by the denominator if there is a symbol present.\nEquationOperations.removeSymbolFromDenominator = function(equation, symbolName) {\n  // Can't multiply a symbol across non-equal comparators\n  // because you don't know if it's negative and need to flip the sign\n  if (equation.comparator !== '=') {\n    return EquationStatus.noChange(equation);\n  }\n  const leftNode = equation.leftNode;\n  const denominator = Symbols.getLastDenominatorWithSymbolTerm(leftNode, symbolName);\n  if (denominator) {\n    return performTermOperationOnEquation(\n      equation, '*', denominator, ChangeTypes.MULTIPLY_TO_BOTH_SIDES);\n  }\n  return EquationStatus.noChange(equation);\n};\n\n// Removes the given symbolName from the right side by adding or subtracting\n// it from both sides as appropriate.\n// e.g. 2x = 3x + 5 --> 2x - 3x = 5\n// There are actually no cases where we'd remove symbols from the right side\n// by multiplying or dividing by a symbol term.\n// TODO: support inverting functions e.g. sqrt, ^, log etc.\nEquationOperations.removeSymbolFromRightSide = function(equation, symbolName) {\n  const rightNode = equation.rightNode;\n  let symbolTerm = Symbols.getLastSymbolTerm(rightNode, symbolName);\n\n  let inverseOp, inverseTerm, changeType;\n  if (!symbolTerm){\n    return EquationStatus.noChange(equation);\n  }\n\n  // Clone it so that any operations on it don't affect the node already\n  // in the equation\n  symbolTerm = symbolTerm.cloneDeep();\n\n  if (Node.PolynomialTerm.isPolynomialTerm(rightNode)) {\n    if (Negative.isNegative(symbolTerm)) {\n      inverseOp = '+';\n      changeType = ChangeTypes.ADD_TO_BOTH_SIDES;\n      inverseTerm = Negative.negate(symbolTerm);\n    }\n    else {\n      inverseOp = '-';\n      changeType = ChangeTypes.SUBTRACT_FROM_BOTH_SIDES;\n      inverseTerm = symbolTerm;\n    }\n  }\n  else if (Node.Type.isOperator(rightNode)) {\n    if (rightNode.op === '+') {\n      if (Negative.isNegative(symbolTerm)) {\n        inverseOp = '+';\n        changeType = ChangeTypes.ADD_TO_BOTH_SIDES;\n        inverseTerm = Negative.negate(symbolTerm);\n      }\n      else {\n        inverseOp = '-';\n        changeType = ChangeTypes.SUBTRACT_FROM_BOTH_SIDES;\n        inverseTerm = symbolTerm;\n      }\n    }\n    else {\n      // Note that operator '-' won't show up here because subtraction is\n      // flattened into adding the negative. See 'TRICKY catch' in the README\n      // for more details.\n      throw Error('Unsupported operation: ' + symbolTerm.op);\n    }\n  }\n  else if (Node.Type.isUnaryMinus(rightNode)) {\n    inverseOp = '+';\n    changeType = ChangeTypes.ADD_TO_BOTH_SIDES;\n    inverseTerm = symbolTerm.args[0];\n  }\n  else {\n    throw Error('Unsupported node type: ' + rightNode.type);\n  }\n  return performTermOperationOnEquation(\n      equation, inverseOp, inverseTerm, changeType);\n};\n\n// Isolates the given symbolName to the left side by adding, multiplying, subtracting\n// or dividing all other symbols and constants from both sides appropriately\n// TODO: support inverting functions e.g. sqrt, ^, log etc.\nEquationOperations.isolateSymbolOnLeftSide = function(equation, symbolName) {\n  let leftNode = equation.leftNode;\n\n  if (Node.Type.isParenthesis(leftNode)) {\n    // if entire left node is a parenthesis, we can ignore the parenthesis\n    leftNode = leftNode.content;\n  }\n\n  let nonSymbolTerm = Symbols.getLastNonSymbolTerm(leftNode, symbolName);\n  let inverseOp, inverseTerm, changeType;\n\n  if (!nonSymbolTerm) {\n    return EquationStatus.noChange(equation);\n  }\n\n  // Clone it so that any operations on it don't affect the node already\n  // in the equation\n  nonSymbolTerm = nonSymbolTerm.cloneDeep();\n\n  if (Node.Type.isOperator(leftNode)) {\n    if (leftNode.op === '+') {\n      if (Negative.isNegative(nonSymbolTerm)) {\n        inverseOp = '+';\n        changeType = ChangeTypes.ADD_TO_BOTH_SIDES;\n        inverseTerm = Negative.negate(nonSymbolTerm);\n      }\n      else {\n        inverseOp = '-';\n        changeType = ChangeTypes.SUBTRACT_FROM_BOTH_SIDES;\n        inverseTerm = nonSymbolTerm;\n      }\n    }\n    else if (leftNode.op === '*') {\n      if (Node.Type.isConstantFraction(nonSymbolTerm)) {\n        inverseOp = '*';\n        changeType = ChangeTypes.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION;\n        inverseTerm = Node.Creator.operator(\n          '/', [nonSymbolTerm.args[1], nonSymbolTerm.args[0]]);\n      }\n      else {\n        inverseOp = '/';\n        changeType = ChangeTypes.DIVIDE_FROM_BOTH_SIDES;\n        inverseTerm = nonSymbolTerm;\n      }\n    }\n    else if (leftNode.op === '/') {\n      // The non symbol term is always a fraction because it's the\n      // coefficient of our symbol term.\n      // If the numerator is 1, we multiply both sides by the denominator,\n      // otherwise we multiply by the inverse\n      if (['1', '-1'].indexOf(nonSymbolTerm.args[0].value) !== -1) {\n        inverseOp = '*';\n        changeType = ChangeTypes.MULTIPLY_TO_BOTH_SIDES;\n        inverseTerm = nonSymbolTerm.args[1];\n      }\n      else {\n        inverseOp = '*';\n        changeType = ChangeTypes.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION;\n        inverseTerm = Node.Creator.operator(\n          '/', [nonSymbolTerm.args[1], nonSymbolTerm.args[0]]);\n      }\n    }\n    else if (leftNode.op === '^') {\n      // TODO: support roots\n      return EquationStatus.noChange(equation);\n    }\n    else {\n      throw Error('Unsupported operation: ' + leftNode.op);\n    }\n  }\n  else if (Node.Type.isUnaryMinus(leftNode)) {\n    inverseOp = '*';\n    changeType = ChangeTypes.MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE;\n    inverseTerm =  Node.Creator.constant(-1);\n  }\n  else {\n    throw Error('Unsupported node type: ' + leftNode.type);\n  }\n\n  return performTermOperationOnEquation(\n      equation, inverseOp, inverseTerm, changeType);\n};\n\n// Modifies the left and right sides of an equation by `op`-ing `term`\n// to both sides. Returns an Status object.\nfunction performTermOperationOnEquation(equation, op, term, changeType) {\n  const oldEquation = equation.clone();\n\n  const leftTerm = term.cloneDeep();\n  const rightTerm = term.cloneDeep();\n  const leftNode = performTermOperationOnExpression(\n    equation.leftNode, op, leftTerm);\n  const rightNode = performTermOperationOnExpression(\n    equation.rightNode, op, rightTerm);\n\n  let comparator = equation.comparator;\n  if (Negative.isNegative(term) && (op === '*' || op === '/')) {\n    comparator = COMPARATOR_TO_INVERSE[comparator];\n  }\n\n  const newEquation = new Equation(leftNode, rightNode, comparator);\n  return new EquationStatus(changeType, oldEquation, newEquation);\n}\n\n// Performs an operation of a term on an entire given expression\nfunction performTermOperationOnExpression(expression, op, term) {\n  let node = (Node.Type.isOperator(expression) ?\n    Node.Creator.parenthesis(expression) : expression);\n\n  if (Node.Type.isOperator(expression) && expression.op === '*' && op==='/') {\n    // eg 2x/5 parenthesis not needed\n    node = expression\n  }\n\n  term.changeGroup = 1;\n  term = (Node.Type.isOperator(term) ? Node.Creator.parenthesis(term) : term);\n  const newNode = Node.Creator.operator(op, [node, term]);\n\n  return newNode;\n}\n\nmodule.exports = EquationOperations;\n","const ChangeTypes = require('../ChangeTypes');\nconst checks = require('../checks');\nconst Equation = require('../equation/Equation');\nconst EquationOperations = require('./EquationOperations');\nconst EquationStatus = require('../equation/Status');\nconst evaluate = require('../util/evaluate');\nconst factor = require('../factor/stepThrough');\nconst flattenOperands = require('../util/flattenOperands');\nconst Node = require('../node');\nconst removeUnnecessaryParens = require('../util/removeUnnecessaryParens');\nconst simplifyExpressionNode = require('../simplifyExpression/stepThrough');\nconst Symbols = require('../Symbols');\n\nconst COMPARATOR_TO_FUNCTION = {\n  '=': function(left, right) { return left === right; },\n  '>': function(left, right) { return left > right; },\n  '>=': function(left, right) { return left >= right; },\n  '<': function(left, right) { return left < right; },\n  '<=': function(left, right) { return left <= right; },\n};\n\n// Given a leftNode, rightNode and a comparator, will return the steps to get\n// the solution. Possible solutions include:\n// - solving for a variable (e.g. 'x=3' for '3x=4+5')\n// - the result of comparing values (e.g. 'true' for 3 = 3, 'false' for 3 < 2)\nfunction stepThrough(leftNode, rightNode, comparator, debug=false) {\n  let equation = new Equation(leftNode, rightNode, comparator);\n\n  if (debug) {\n    // eslint-disable-next-line\n    console.log('\\n\\nSolving: ' + equation.ascii(false, true));\n  }\n\n  // we can't solve/find steps if there are any unsupported nodes\n  if (checks.hasUnsupportedNodes(equation.leftNode) ||\n      checks.hasUnsupportedNodes(equation.rightNode)) {\n    return [];\n  }\n\n  const symbolSet = Symbols.getSymbolsInEquation(equation);\n\n  if (symbolSet.size === 0) {\n    return solveConstantEquation(equation, debug);\n  }\n  const symbolName = symbolSet.values().next().value;\n\n  let equationStatus;\n  let steps = [];\n\n  const originalEquationStr = equation.ascii();\n  const MAX_STEP_COUNT = 20;\n  let iters = 0;\n\n  // Remove unnecessary parentheses here, before doing the find roots check\n  // If we have roots, we return early and do not go through simplification,\n  // so we can't rely on that flow for parentheses removal\n  // e.g. x^(2) = 0 -> x^2 = 0\n  equation.leftNode = removeUnnecessaryParens(equation.leftNode);\n  equation.rightNode = removeUnnecessaryParens(equation.rightNode);\n\n  // Checks if there are roots in the original equation before we\n  // do any simplification.\n  // E.g. (33 + 89) (x - 99) = 0\n  if (checks.canFindRoots(equation)) {\n    steps.push(getRootsStatus(equation));\n    return steps;\n  }\n\n  // Step through the math equation until nothing changes\n  do {\n    steps = addSimplificationSteps(steps, equation, debug);\n\n    if (steps.length > 0) {\n      const lastStep = steps[steps.length - 1];\n      equation = Equation.createEquationFromString(\n        lastStep.newEquation.ascii(false, true), equation.comparator);\n    }\n\n    equation.leftNode = flattenOperands(equation.leftNode);\n    equation.rightNode = flattenOperands(equation.rightNode);\n\n    // at this point, the symbols might have cancelled out.\n    if (Symbols.getSymbolsInEquation(equation).size === 0) {\n      return solveConstantEquation(equation, debug, steps);\n    }\n\n    // The left side of the equation is either factored or simplified.\n    // If it is factor and we can find roots, return them.\n    // e.g. x^2 + 3x + 2 = 0 -> (x + 1) (x + 2) = 0 -> x = -1\n    if (checks.canFindRoots(equation)) {\n      steps.push(getRootsStatus(equation));\n      return steps;\n    }\n\n    try {\n      equationStatus = step(equation, symbolName);\n    }\n    catch (e) {\n      // This error happens for some math that we don't support\n      if (e.message.startsWith('No term with symbol: ')) {\n        // eslint-disable-next-line\n        console.error('Math error: ' + e.message + ', returning no steps');\n        return [];\n      }\n      else {\n        throw e; // bubble up\n      }\n    }\n\n    if (equationStatus.hasChanged()) {\n      if (equationStatus.newEquation.ascii().length > 300) {\n        // eslint-disable-next-line\n        throw Error('Math error: Potential infinite loop for equation ' +\n                    originalEquationStr +  '. It reached over 300 characters '+\n                    ' long, so returning no steps');\n      }\n      if (debug) {\n        logSteps(equationStatus);\n      }\n      steps.push(equationStatus);\n    }\n\n    equation = EquationStatus.resetChangeGroups(equationStatus.newEquation);\n    if (iters++ === MAX_STEP_COUNT) {\n      // eslint-disable-next-line\n      console.error('Math error: Potential infinite loop for equation: ' +\n                    originalEquationStr + ', returning no steps');\n      return [];\n    }\n  } while (equationStatus.hasChanged());\n\n  return steps;\n}\n\n/*\n  Helper function to return the roots to a factor of an equation\n  e.g. (x + 2) (x - 2) = 0 -> getRootsStatus (x + 2 = 0) will return\n  a new EquationStatus with x = -2 as the roots\n  Similarly getRootsStatus(x - 2 = 0) will return x = 2\n*/\nfunction getRootsStatus(equation) {\n  const [solutions, symbol] = getSolutionsAndSymbol(equation);\n\n  let allSolutions;\n\n  if (solutions.length > 1) {\n    const flattenSolutionsList = [];\n    solutions.forEach(s => s.items\n                      ? flattenSolutionsList.push(...s.items)\n                      : flattenSolutionsList.push(s));\n    allSolutions =  Node.Creator.list(flattenSolutionsList);\n  }\n  else if (solutions.length === 1) {\n    allSolutions = solutions[0];\n  }\n  else {\n    allSolutions = Node.Creator.list([]);\n  }\n\n  const roots = new Equation(symbol, allSolutions, '=');\n\n  return new EquationStatus(ChangeTypes.FIND_ROOTS, equation, roots);\n}\n\n/*\n  Helper function that returns the roots and symbol of an input equation\n  that has roots to be found. (We check if the equation has roots first)\n  For every factor on the left hand side, solve a new equation that is factor = 0\n  for the symbol.\n  TODO: handle multiple variable solutions e.g (x + 2) (y + 2) = 0\n*/\n\nfunction getSolutionsAndSymbol (equation) {\n  const leftNode = equation.leftNode;\n\n  const solutions = [];\n\n  let symbol, steps, factorsWithSymbols;\n\n  // If left hand side is a power node and it does not resolve to a constant\n  // then it is a factor. (e.g. 2^7 resolves to a constant so it is not a factor, but\n  // x^2 would have factors x = 0)\n  // If left hand side is a multiplication node, return a list of all the valid factors.\n  if (Node.Type.isOperator(leftNode, '^') && !checks.resolvesToConstant(leftNode)){\n    factorsWithSymbols = [leftNode];\n  }\n  else {\n    factorsWithSymbols = equation.leftNode.args.filter(arg => !checks.resolvesToConstant(arg));\n  }\n\n  /*\n    For each factor, solve the equation factor = 0 for the symbol\n    If the factor is a power node, solve the equation base = 0 for the symbol\n    Show duplicate roots when factor is a power node\n    e.g. (x + 1)^2 -> x = [-1, -1]\n  */\n\n  for (var f in factorsWithSymbols) {\n    let factor = factorsWithSymbols[f];\n    let exponent = 1;\n\n    if (Node.Type.isOperator(factor, '^')) {\n      exponent = parseFloat(factor.args[1].value);\n      factor = factor.args[0];\n    }\n\n    const leftNode = Node.Type.isParenthesis(factor)\n          ? factor.content\n          : factor;\n\n    steps = stepThrough(leftNode, equation.rightNode, '=');\n\n    if (steps.length === 0 && Node.Type.isSymbol(leftNode)) {\n      // e.g. x = 0\n      symbol = leftNode;\n\n      // Push the solution multiple times when we have duplicate roots\n      // e.g. (x + 1)^2 -> x = [-1, -1]\n      solutions.push(...Array(exponent).fill(equation.rightNode));\n    }\n    else if (steps.length !== 0) {\n      // Solving for the variable on one side may sometimes\n      // result in more than one step\n      // e.g. x - 2 = 0\n      const lastStep = steps.slice(-1)[0];\n\n      // Append to a list of roots\n      if (Node.Type.isSymbol(lastStep.newEquation.leftNode)) {\n        symbol = lastStep.newEquation.leftNode;\n        solutions.push(...Array(exponent).fill(lastStep.newEquation.rightNode));\n      }\n    }\n  }\n\n  return [solutions, symbol];\n}\n\n// Given an equation of constants, will simplify both sides, returning\n// the steps and the result of the equation e.g. 'True' or 'False'\nfunction solveConstantEquation(equation, debug, steps=[]) {\n  const compareFunction = COMPARATOR_TO_FUNCTION[equation.comparator];\n\n  if (!compareFunction) {\n    throw Error('Unexpected comparator');\n  }\n\n  steps = addSimplificationSteps(steps, equation, true, debug);\n  if (steps.length > 0) {\n    const lastStep = steps[steps.length - 1];\n    equation = Equation.createEquationFromString(\n      lastStep.newEquation.ascii(), equation.comparator);\n  }\n\n  // If the left or right side didn't have any steps, unnecessary parens\n  // might not have been removed, so do that now.\n  equation.leftNode = removeUnnecessaryParens(equation.leftNode);\n  equation.rightNode = removeUnnecessaryParens(equation.rightNode);\n\n  if (!Node.Type.isConstantOrConstantFraction(equation.leftNode, true) ||\n      !Node.Type.isConstantOrConstantFraction(equation.rightNode, true)) {\n    throw Error('Expected both nodes to be constants, instead got: ' +\n                equation.ascii());\n  }\n\n  const leftValue = evaluate(equation.leftNode);\n  const rightValue = evaluate(equation.rightNode);\n  let changeType;\n  if (compareFunction(leftValue, rightValue)) {\n    changeType = ChangeTypes.STATEMENT_IS_TRUE;\n  }\n  else {\n    changeType = ChangeTypes.STATEMENT_IS_FALSE;\n  }\n\n  // there's no oldEquation or change groups because nothing actually changes\n  // here, it's just a final step that states the solution\n  const equationStatus = new EquationStatus(changeType, null, equation);\n  if (debug) {\n    logSteps(equationStatus);\n  }\n  steps.push(equationStatus);\n  return steps;\n}\n\n// Given a symbol and an equation, performs a single step to\n// solve for the symbol. Returns an Status object.\nfunction step(equation, symbolName) {\n  const solveFunctions = [\n    // ensure the symbol is always on the left node\n    EquationOperations.ensureSymbolInLeftNode,\n    // check if we can cross multiply and solve \n    EquationOperations.crossMultiply,\n    // get rid of denominators that have the symbol\n    EquationOperations.removeSymbolFromDenominator,\n    // remove the symbol from the right side\n    EquationOperations.removeSymbolFromRightSide,\n    // isolate the symbol on the left side\n    EquationOperations.isolateSymbolOnLeftSide,\n  ];\n\n  for (let i = 0; i < solveFunctions.length; i++) {\n    const equationStatus = solveFunctions[i](equation, symbolName);\n\n    if (equationStatus.hasChanged()) {\n      return equationStatus;\n    }\n  }\n  return EquationStatus.noChange(equation);\n}\n\n// Simplifies the equation and returns the simplification steps\nfunction addSimplificationSteps(steps, equation, debug=false) {\n  let oldEquation = equation.clone();\n\n  /*\n    1. On the left side, we should first simplify,\n    and add all those simplify substeps to a list of leftSteps.\n    2. Then we should factor the simplified equation, and add all\n    those factoring substeps to the leftSteps list.\n    3. On the right side, there should be no need to factor,\n    because we always move everything to the left side first\n    e.g. x^2 + 3x + 2 = 0 <- factor the left side\n    e.g. x + 4 + 2 = 0 <- simplify the left side\n    e.g. 0 = x^2 + 3x + 2 -> x^2 + 3x + 2 = 0 <- swap to the left side\n  */\n  const leftSimplifySteps = simplifyExpressionNode(equation.leftNode, false);\n  const simplifiedLeftNode = leftSimplifySteps.length !== 0\n        ? leftSimplifySteps.slice(-1)[0].newNode\n        : equation.leftNode;\n  const leftFactorSteps = factor(simplifiedLeftNode, false);\n\n  const leftSubSteps = [];\n\n  for (let i = 0; i < leftSimplifySteps.length; i++) {\n    const step = leftSimplifySteps[i];\n    leftSubSteps.push(EquationStatus.addLeftStep(equation, step));\n  }\n\n  for (let i = 0; i < leftFactorSteps.length; i++) {\n    const step = leftFactorSteps[i];\n    leftSubSteps.push(EquationStatus.addLeftStep(equation, step));\n  }\n\n  if (leftSubSteps.length === 1) {\n    const step = leftSubSteps[0];\n    if (debug) {\n      logSteps(step);\n    }\n    steps.push(step);\n  }\n  else if (leftSubSteps.length > 1) {\n    const lastStep = leftSubSteps[leftSubSteps.length - 1];\n    const finalEquation = EquationStatus.resetChangeGroups(lastStep.newEquation);\n    // no change groups are set here - too much is changing for it to be useful\n    const simplifyStatus = new EquationStatus(\n      ChangeTypes.SIMPLIFY_LEFT_SIDE,\n      oldEquation, finalEquation, leftSubSteps);\n    if (debug) {\n      logSteps(simplifyStatus);\n    }\n    steps.push(simplifyStatus);\n  }\n\n  // update `equation` to have the new simplified left node\n  if (steps.length > 0) {\n    equation = EquationStatus.resetChangeGroups(\n      steps[steps.length - 1].newEquation);\n  }\n\n  // the updated equation from simplifing the left side is the old equation\n  // (ie the \"before\" of the before and after) for simplifying the right side.\n  oldEquation = equation.clone();\n\n  const rightSteps = simplifyExpressionNode(equation.rightNode, false);\n  const rightSubSteps = [];\n\n  for (let i = 0; i < rightSteps.length; i++) {\n    const step = rightSteps[i];\n    rightSubSteps.push(EquationStatus.addRightStep(equation, step));\n  }\n\n  if (rightSubSteps.length === 1) {\n    const step = rightSubSteps[0];\n    if (debug) {\n      logSteps(step);\n    }\n    steps.push(step);\n  }\n  else if (rightSubSteps.length > 1) {\n    const lastStep = rightSubSteps[rightSubSteps.length - 1];\n    const finalEquation = EquationStatus.resetChangeGroups(lastStep.newEquation);\n    // no change groups are set here - too much is changing for it to be useful\n    const simplifyStatus = new EquationStatus(\n      ChangeTypes.SIMPLIFY_RIGHT_SIDE,\n      oldEquation, finalEquation, rightSubSteps);\n    if (debug) {\n      logSteps(simplifyStatus);\n    }\n    steps.push(simplifyStatus);\n  }\n\n  return steps;\n}\n\nfunction logSteps(equationStatus) {\n  // eslint-disable-next-line\n  console.log('\\n' + equationStatus.changeType);\n  // eslint-disable-next-line\n  console.log(equationStatus.newEquation.ascii());\n  if (equationStatus.substeps.length > 0) {\n    // eslint-disable-next-line\n    console.log('\\n substeps: ');\n    equationStatus.substeps.forEach(logSteps);\n  }\n}\n\n\nmodule.exports = stepThrough;\n","const math = require('../node/MathjsInstance');\n\nconst stepThrough = require('./stepThrough');\n\nfunction solveEquationString(equationString, debug=false) {\n  const comparators = ['<=', '>=', '=', '<', '>'];\n\n  for (let i = 0; i < comparators.length; i++) {\n    const comparator = comparators[i];\n    const sides = equationString.split(comparator);\n    if (sides.length !== 2) {\n      continue;\n    }\n    let leftNode, rightNode;\n    const leftSide = sides[0].trim();\n    const rightSide = sides[1].trim();\n\n    if (!leftSide || !rightSide) {\n      return [];\n    }\n\n    try {\n      leftNode = math.parse(leftSide);\n      rightNode = math.parse(rightSide);\n    }\n    catch (err) {\n      return [];\n    }\n    if (leftNode && rightNode) {\n      return stepThrough(leftNode, rightNode, comparator, debug);\n    }\n  }\n\n  return [];\n}\n\nmodule.exports = solveEquationString;\n","const ChangeTypes = require('../../ChangeTypes');\nconst Negative = require('../../Negative');\nconst Node = require('../../node');\n\n// Simplifies negative signs if possible\n// e.g. -1/-3 --> \\frac{1}/{3}   4/-5 --> -\\\\frac{4}/\\frac{5}\n// Returns a Node.Status object\nfunction simplifySignsBefore(fraction) {\n  if (!Node.Type.isOperator(fraction)) {\n    return Node.Status.noChange(fraction);\n  }\n  if (fraction.op === '/') {\n    const oldFraction = fraction.cloneDeep();\n    let numerator = fraction.args[0];\n    let denominator = fraction.args[1];\n    // The denominator should never be negative.\n    if (Negative.isNegative(denominator) && Negative.isNegative(numerator)) {\n      // -4/-5 devient 4/5\n      denominator = Negative.negate(denominator);\n      numerator = Negative.negate(numerator);\n      const changeType = ChangeTypes.CANCEL_MINUSES;\n      const newFraction = Node.Creator.operator('/', [numerator, denominator]);\n      return Node.Status.nodeChanged(changeType, oldFraction, newFraction);\n    } else if (Negative.isNegative(denominator) && !Negative.isNegative(numerator)) {\n      // 4/-5 devient -4/5\n      denominator = Negative.negate(denominator);\n      const changeType = ChangeTypes.SIMPLIFY_SIGNS_BEFORE;\n      const newFraction = Node.Creator.operator('/', [numerator, denominator]);\n      const unaryMinus = Node.Creator.unaryMinus(newFraction);\n      return Node.Status.nodeChanged(changeType, oldFraction, unaryMinus);\n    }  else if (!Negative.isNegative(denominator) && Negative.isNegative(numerator)) {\n      // {-4}/5 devient - {4/5}\n      numerator = Negative.negate(numerator);\n      const changeType = ChangeTypes.SIMPLIFY_SIGNS_BEFORE;\n      const newFraction = Node.Creator.operator('/', [numerator, denominator]);\n      const unaryMinus = Node.Creator.unaryMinus(newFraction);\n      return Node.Status.nodeChanged(changeType, oldFraction, unaryMinus);\n    } else {\n      return Node.Status.noChange(fraction);\n    }\n  } else if (fraction.op === '-' && fraction.args.length === 2 && Node.Type.isOperator(fraction.args[1]) && fraction.args[1].op === '/') {\n    const subFraction = fraction.args[1];\n    let numerator = subFraction.args[0];\n    let denominator = subFraction.args[1];\n    let op = '-'\n    if (Negative.isNegative(numerator) && Negative.isNegative(denominator)) {\n      // -4/-5 devient 4/5\n      numerator = Negative.negate(numerator);\n      denominator = Negative.negate(denominator);\n      op = '-'\n    } else if (Negative.isNegative(denominator) && !Negative.isNegative(numerator)) {\n      // 4/-5 devient 4/5\n      denominator = Negative.negate(denominator);\n      op = '+'\n    } else if (!Negative.isNegative(denominator) && Negative.isNegative(numerator)) {\n      // -4/5 devient 4/5\n      numerator = Negative.negate(numerator);\n      op = '+'\n    }\n    const changeType = ChangeTypes.SIMPLIFY_SIGNS_BEFORE;\n    const newSubFraction = Node.Creator.operator(op, [fraction.args[0], Node.Creator.operator('/', [numerator, denominator])]);\n    return Node.Status.nodeChanged(changeType, fraction, newSubFraction);\n  } else if (fraction.op === '+' && fraction.args.length === 2 && Node.Type.isOperator(fraction.args[1]) && fraction.args[1].op === '/') {\n    const subFraction = fraction.args[1];\n    let numerator = subFraction.args[0];\n    let denominator = subFraction.args[1];\n    let op = '+'\n    if (Negative.isNegative(numerator) && Negative.isNegative(denominator)) {\n      // -4/-5 devient 4/5\n      numerator = Negative.negate(numerator);\n      denominator = Negative.negate(denominator);\n      op = '+'\n    } else if (Negative.isNegative(denominator) && !Negative.isNegative(numerator)) {\n      // 4/-5 devient 4/5\n      denominator = Negative.negate(denominator);\n      op = '-'\n    } else if (!Negative.isNegative(denominator) && Negative.isNegative(numerator)) {\n      // -4/5 devient 4/5\n      numerator = Negative.negate(numerator);\n      op = '-'\n    }\n    const changeType = ChangeTypes.SIMPLIFY_SIGNS_BEFORE;\n    const newSubFraction = Node.Creator.operator(op, [fraction.args[0], Node.Creator.operator('/', [numerator, denominator])]);\n    return Node.Status.nodeChanged(changeType, fraction, newSubFraction);\n  } else{\n    return Node.Status.noChange(fraction);\n  }\n}\n\nmodule.exports = simplifySignsBefore;","/*\n * Performs simpifications that are more basic and overaching like (...)^0 => 1\n * These are always the first simplifications that are attempted.\n */\n\nconst Node = require('../../node');\nconst TreeSearch = require('../../TreeSearch');\nconst removeUnnecessaryParens = require('../../util/removeUnnecessaryParens');\nconst simplifyFractionSigns = require('../fractionsSearch/simplifyFractionSigns');\nconst simplifyFractionSignsBefore = require('../fractionsSearch/simplifyFractionSignsBefore');\n\nconst convertMixedNumberToImproperFraction = require('./convertMixedNumberToImproperFraction');\nconst rearrangeCoefficient = require('./rearrangeCoefficient');\nconst reduceExponentByZero = require('./reduceExponentByZero');\nconst reduceMultiplicationByZero = require('./reduceMultiplicationByZero');\nconst reduceZeroDividedByAnything = require('./reduceZeroDividedByAnything');\nconst removeAdditionOfZero = require('./removeAdditionOfZero');\nconst removeDivisionByOne = require('./removeDivisionByOne');\nconst removeExponentBaseOne = require('./removeExponentBaseOne');\nconst removeExponentByOne = require('./removeExponentByOne');\nconst removeMultiplicationByNegativeOne = require('./removeMultiplicationByNegativeOne');\nconst removeMultiplicationByOne = require('./removeMultiplicationByOne');\nconst simplifyDoubleUnaryMinus = require('./simplifyDoubleUnaryMinus');\n\nconst SIMPLIFICATION_FUNCTIONS = {\n  // convert mixed numbers to improper fractions\n  convertMixedNumberToImproperFraction,\n  // multiplication by 0 yields 0\n  reduceMultiplicationByZero,\n  // division of 0 by something yields 0\n  reduceZeroDividedByAnything,\n  // ____^0 --> 1\n  reduceExponentByZero,\n  // Check for x^1 which should be reduced to x\n  removeExponentByOne,\n  // Check for 1^x which should be reduced to 1\n  // if x can be simplified to a constant\n  removeExponentBaseOne,\n  // - - becomes +\n  simplifyDoubleUnaryMinus,\n  // If this is a + node and one of the operands is 0, get rid of the 0\n  removeAdditionOfZero,\n  // If this is a * node and one of the operands is 1, get rid of the 1\n  removeMultiplicationByOne,\n  // In some cases, remove multiplying by -1\n  removeMultiplicationByNegativeOne,\n  // If this is a / node and the denominator is 1 or -1, get rid of it\n  removeDivisionByOne,\n  // e.g. x*5 -> 5x\n  rearrangeCoefficient,\n  // supprime les parenthses non ncessaires\n  removeUnnecessaryParens,\n  // simplifie signes des fractions\n  simplifyFractionSigns,\n  // simplifie les fractions\n  simplifyFractionSignsBefore,\n  \n};\n\nmodule.exports = {\n  SIMPLIFICATION_FUNCTIONS,\n  TreeSearch\n};\n","const ChangeTypes = require('./lib/ChangeTypes');\nconst factor = require('./lib/factor');\nconst simplifyExpression = require('./lib/simplifyExpression');\nconst solveEquation = require('./lib/solveEquation');\nconst printMS = require('./lib/util/print');\nconst Node = require('./lib/node');\nconst Negative = require('./lib/Negative')\nconst flatten = require('./lib/util/flattenOperands');\nconst {SIMPLIFICATION_FUNCTIONS, TreeSearch} = require('./lib/simplifyExpression/basicsSearch/indexSimplifyOneRule');\nconst Equation = require('./lib/equation/Equation');\n\nmodule.exports = {\n  factor,\n  simplifyExpression,\n  solveEquation,\n  Node,\n  Negative,\n  printMS,\n  flatten,\n  ChangeTypes,\n  SIMPLIFICATION_FUNCTIONS,\n  TreeSearch,\n  Equation\n};\n"],"names":["ChangeTypes","create","NodeDependencies","lcmDependencies","nthRootDependencies","gcdDependencies","fractionDependencies","parseDependencies","evaluateDependencies","simplifyDependencies","formatDependencies","require$$0","config","math","MathjsInstance","NodeType","node","operator","functionName","allowUnaryMinus","n","numerator","denominator","Type","require$$1","NodeCreator","op","args","implicit","content","val","name","base","exponent","coeff","explicitCoeff","term","symbol","radicandNode","rootNode","Creator","evaluate","evaluate_1","require$$2","Term$3","Term","baseNodeFunc","onlyImplicitMultiplication","values","defaultOne","baseNode","coeffNode","nonCoefficientTerm","denominatorNode","numeratorNode","numeratorConstantNode","arg","termNode","negativeCoefficient","numeratorValue","Term_1","PolynomialTerm","PolynomialTerm_1","Negative","denominatorValue","polyNode","naive","newCoeff","oldCoeff","Negative_1","NodeCustomType","isTypeFunc","allowParens","moveUnaryMinus","newNumerator","CustomType","isMixedNumber","numeratorFirstArg","numeratorSecondArg","isNegativeMixedNumber","getWholeNumberValue","wholeNumberNode","getNumeratorValue","getDenominatorValue","MixedNumber","NthRootTerm","NthRootTerm_1","Status$3","changeType","oldNode","newNode","substeps","Status","change","defaultChangeGroup","steps","childStatus","childArgIndex","updateSubsteps","fn","step","Status_1","require$$3","require$$4","require$$5","require$$6","require$$7","Node","canAddLikeTermNodes","termSubclass","termList","firstTerm","sharedBase","sharedExponentNode","haveSameBase","haveSameExponent","canAddLikeTermNthRootNodes","canAddLikeTermPolynomialNodes","canAddLikeTerms","resolvesToConstant","child","resolvesToConstant_1","canFindRoots","equation","left","right","zeroRightSide","isMulOrPower","canFindRoots_1","getBaseNode","getExponentNode","isConstantOrConstantPower","ConstantOrConstantPower","ConstantOrPowerTerm","canMultiplyLikeTermConstantNodes","constantTermBaseList","canMultiplyLikeTermConstantNodes_1","canMultiplyLikeTermPolynomialNodes","polynomialTermList","polyTerm","canMultiplyLikeTermPolynomialNodes_1","ConstantFactors","number","factors","root","candidate","bound","divisor","quotient","ConstantFactors_1","flattenOperands","constNode","parentOp","flattenSupportedOperation","i","flattenedNode","flattenedFn","flattenedArg","operands","getOperands","hasMultiplicationBesideDivision","isPolynomialTermMultiplication","maybeFlattenPolynomialTerm","flattenDivision","secondOperand","negativeSecondOperand","lastOperand","nextOperand","divisionNode","flattenOperands_1","cloneDeepWithChangeGroup","cloned","originalList","cloneList","src","dst","cloneDeepWithChangGroup","setImplicityMultiplySign","copy","nodeChild","path","parent","setImplicitMultiply","isNegatifTerm","addParenthesis","paren","addParenthesis_1","flatten","printAscii","showPlusMinus","forceMultiplySign","flattenUsed","forceAddParenthesis","string","printTreeTraversal","parentNode","coeffTerm","coeffStr","nonCoeffTerm","nonCoeffStr","opString","str","printLatex","postAction","action","nodeTex","print","nthRoot","getRadicandNode","nthRootExponent","nthRootMultiplication","nthRootConstant","getRootNode","exponentNode","rootValue","exponentValue","newRootValue","newRootNode","newExponentValue","newExponentNode","status","factorMultiplicands","groupTermsByRoot","convertMultiplicationToExponent","distributeNthRoot","evaluateNthRootForChildren","combineRoots","children","factored","polyTermNoCoeff","factorNodes","getFactorNodes","value","sortNodes","termStrings","count","argString","newTerms","key","leftover","times","remainder","acc","newBase","isMultiplicationOfEqualNodes","grandChild","childNodeStatus","radicandArgs","radicandValue","nthRootValue","roundedNthRootValue","nodeStatus","a","b","nthRoot_1","NthRoot","canMultiplyLikeTermsNthRoots","canMultiplyLikeTermsNthRoots_1","canRearrangeCoefficient","canRearrangeCoefficient_1","canSimplifyPolynomialTerms","canSimplifyPolynomialTerms_1","hasUnsupportedNodes","hasUnsupportedNodes_1","Symbols","leftSymbols","rightSymbols","expression","symbols","symbolName","isSymbolTerm","isPolynomialTermWithSymbol","hasDenominatorSymbol","Symbols_1","isQuadratic","secondDegreeTerms","isPolynomialTermOfDegree","firstDegreeTerms","constantTerms","degree","isQuadratic_1","printNode","Equation$4","Equation","leftNode","rightNode","comparator","leftSide","rightSide","newLeft","newRight","sides","Equation_1","canCrossMultiplication","canCrossMuliplication","require$$8","require$$9","require$$10","checks","FACTOR_FUNCTIONS","factorSymbol","factorDifferenceOfSquares","factorPerfectSquare","factorSumProductRule","factorQuadratic","aValue","bValue","cValue","negate","gcd","gcdNode","aNode","bNode","factoredNode","aRootValue","cRootValue","aRootNode","cRootNode","firstParen","secondParen","perfectProduct","product","factorPairs","pair","c","ax2","bx","pValue","qValue","p","q","px","qx","secondTerm","u","r","s","ux","rx","firstFactoredGroup","vValue","v","secondFactoredGroup","factorQuadratic_1","Util","dict","Util_1","CONSTANT","CONSTANT_FRACTION","NTH_ROOT","OTHER","LikeTermCollector","terms","getTermsForCollectingAddition","getTermsForCollectingMultiplication","termTypes","filteredTermTypes","x","termTypesSorted","sortTerms","newOperands","changeGroup","termType","termsOfType","singleTerm","getTermName","termName","fraction","addToTermsforPolynomialMultiplication","addToTermsforNthRootMultiplication","rootNodeValue","coefficient","termWithoutCoefficient","symbA","expA","symbB","expB","LikeTermCollector_1","removeUnnecessaryParens","removeUnnecessaryParensSearch","removeUnnecessaryParensInOperatorNode","removeUnnecessaryParensInFunctionNode","removeUnnecessaryParensInParenthesisNode","canCollectOrCombine","removeUnnecessaryParens_1","stepThrough","debug","stepThrough_1","factorString","expressionString","factor","TreeSearch","simplificationFunction","search","preOrder","TreeSearch_1","arithmetic","evaluatedValue","evaluateAndRound","result","arithmeticSearch","convertMixedNumberToImproperFraction","wholeNumber","convertToUnsimplifiedImproperFraction","simplifyMultiplicationInImproperFraction","simplifyAdditionInImproperFraction","newNumeratorMultiplication","newDenominator","convertMixedNumberToImproperFraction_1","rearrangeCoefficient","rearrangeCoefficient_1","reduceExponentByZero","reduceExponentByZero_1","reduceMultiplicationByZero","reduceMultiplicationByZero_1","reduceZeroDividedByAnything","reduceZeroDividedByAnything_1","removeAdditionOfZero","zeroIndex","removeAdditionOfZero_1","removeDivisionByOne","removeDivisionByOne_1","removeExponentBaseOne","removeExponentBaseOne_1","removeExponentByOne","removeExponentByOne_1","removeMultiplicationByNegativeOne","minusOneIndex","minusOneIndex2","minusOneIndexToUse","nodeToCombineIndex","nodeToCombine","removeMultiplicationByNegativeOne_1","removeMultiplicationByOne","oneIndex","removeMultiplicationByOne_1","simplifyDoubleUnaryMinus","unaryArg","parenthesisContent","simplifyDoubleUnaryMinus_1","require$$11","require$$12","require$$13","SIMPLIFICATION_FUNCTIONS","basics","basicsSearch","breakUpNumerator","fractionList","newFraction","breakUpNumeratorSearch","divideByGCD","findGCD","cancelGCD","intermediateNumerator","intermediateDenominator","newNumeratorNode","newDenominatorNode","divideByGCD_1","addConstantFractions","denominators","makeCommonDenominator","evaluateDenominators","evaluateNumerators","combineNumeratorsAboveCommonDenominator","addNumeratorsTogether","reduceNumerator","commonDenominator","numeratorArgs","missingFactor","missingFactorNode","newDeominator","addConstantFractions_1","addConstantAndFraction","firstArg","secondArg","fractionNode","newConstNode","newFractionNode","constNodeValue","dividedValue","addFractionStatus","evalNode","lastStep","addConstantAndFraction_1","evaluateConstantSum","summingFunctions","groupConstantsAndFractions","constants","fractions","constantList","evaluateStatus","evaluateConstantSum_1","addLikeTerms","polynomialOnly","addLikePolynomialTerms","addLikeNthRootTerms","addLikeTermNodes","addPositiveOneCoefficient","addNegativeOneCoefficient","groupCoefficientsForAdding","evaluateCoefficientSum","coefficientList","sumOfCoefficents","coefficientSum","addLikeTerms_1","multiplyFractions","atLeastOneFraction","hasPolynomialTerms","hasPolynomialInDenominatorTerms","hasPolynomialInDenominator","denominatorArgs","operand","multiplyFractionsSearch","multiplyLikeTerms","multiplyPolynomialTerms","multiplyNthRoots","radicands","newRadicandNode","addOneExponent","collectConstantExponents","collectPolynomialExponents","exponentSum","sumStatus","exponentNodeList","newExponent","symbolNode","multiplyLikeTerms_1","termCollectorFunctions","collectAndCombineLikeTerms","collectAndCombineOperation","combineSteps","combineLikeTerms","collectAndCombineSearch","distribute","distributeUnaryMinus","distributeAndSimplifyMultiplication","expandBase","expandedBase","expandedNode","simplify","unaryContent","newContent","newArgs","newArg","isParenthesisOfAddition","combinedNode","distributeTwoNodes","simplifyWithParens","firstNode","secondNode","firstArgs","secondArgs","hasFraction","firstArgsHasFraction","fractionNodes","nonFractionTerm","isFraction","leftArg","rightArg","simplifyFunctions","j","distributeSearch","division","multiplyByInverse","simplifyDivisionChain","inverseNumerator","inverseDenominator","inverseFraction","denominatorList","getDenominatorList","divisionSearch","CancelOutStatus","hasChanged","cancelLikeTerms","isMultiplicationOfTerms","cancelStatus","cancelTerms","numeratorExponent","denominatorExponent","numeratorTerm","denominatorTerm","cancelCoeffs","variable","frac","reduceStatus","denominatorCoeff","denominatorVariable","numeratorCoeff","numeratorVariable","newDenominatorCoeff","cancelLikeTerms_1","simplifySigns","oldFraction","simplifyFractionSigns","simplifyPolynomialFraction","coefficientSimplifications","coefficientFraction","newCoeffStatus","simplifyPolynomialFraction_1","simplifyFractions","fractionsSearch","absoluteValue","argument","absoluteValue_1","FUNCTIONS","functions","functionsSearch","require$$14","originalExpressionStr","MAX_STEP_COUNT","iters","logSteps","removeUnnecessaryParensInStep","simplificationTreeSearches","substep","simplifyExpressionString","exprNode","simplifyExpression","oldEquation","newEquation","leftStep","rightStep","EquationStatus","COMPARATOR_TO_INVERSE","EquationOperations","leftSideSymbolTerm","rightSideSymbolTerm","newleft","newright","performTermOperationOnEquation","symbolTerm","inverseOp","inverseTerm","nonSymbolTerm","leftTerm","rightTerm","performTermOperationOnExpression","EquationOperations_1","simplifyExpressionNode","COMPARATOR_TO_FUNCTION","symbolSet","solveConstantEquation","equationStatus","originalEquationStr","getRootsStatus","addSimplificationSteps","e","solutions","getSolutionsAndSymbol","allSolutions","flattenSolutionsList","roots","factorsWithSymbols","f","compareFunction","leftValue","rightValue","solveFunctions","leftSimplifySteps","simplifiedLeftNode","leftFactorSteps","leftSubSteps","finalEquation","simplifyStatus","rightSteps","rightSubSteps","solveEquationString","equationString","comparators","solveEquation","simplifySignsBefore","unaryMinus","subFraction","newSubFraction","simplifyFractionSignsBefore","require$$15","require$$16","indexSimplifyOneRule","printMS","mathsteps"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81]}
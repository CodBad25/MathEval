{"version":3,"mappings":";4TAGA,SAASA,GAAyBC,EAAG,CACpC,OAAOA,GAAKA,EAAE,YAAc,OAAO,UAAU,eAAe,KAAKA,EAAG,SAAS,EAAIA,EAAE,QAAaA,CACjG,CAEA,IAAIC,EAAmB,CAAC,QAAS,EAAE,EAEnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GASA,IAAIC,EAAiB,SAASC,EAAGC,EAAG,CACnC,IAAIC,EAAGC,EACLC,EAAQ,EACRC,EAAO,EACPC,EAAO,EACPC,EAAW,OAAO,SAEpB,SAASC,EAAQC,EAAKC,EAAKC,EAAM,CAChC,GAAIA,EAAM,CACT,IAAKT,EAAIQ,EAAKC,EAAOH,EAAQC,EAAKP,CAAC,EAAGS,EAAO,IAAMA,EAAO,IAAK,EAAET,EACjE,MAAO,CAACO,EAAI,MAAMC,EAAM,EAAGR,CAAC,CAC7B,CACA,OAAAS,EAAOJ,GAAYA,EAAS,QAAQE,EAAI,OAAOC,CAAG,CAAC,EAC5CC,EAAO,GAAKA,EAAO,IAAOA,EAAOF,EAAI,WAAWC,CAAG,GAAK,EAAIC,EAAO,IAAMA,EAAO,IAAOA,EAC3FA,EAAO,GAAK,GACZA,EAAO,GAAKA,EAAO,EACnBA,EAAO,GAAKA,EAAO,GACnBA,EAAO,GAAKA,EAAO,GACnBA,EAAO,GAAKA,EAAO,GACnBA,EAAO,GAAKA,EAAO,GACnBA,EAAO,IAAMA,EAAO,EACpBA,EAAO,GACX,CAGA,IAAKX,GAAG,MAAQC,GAAG,KAAK,KAAMG,GAU7B,GATAD,EAAQK,EAAQR,EAAGK,GAAM,EACzBD,EAAQI,EAAQP,EAAGK,GAAM,EAErBH,EAAQ,IAAMC,EAAQ,IAAMD,EAAQ,IAAMC,EAAQ,KACrDD,EAAQK,EAAQR,EAAGK,EAAMA,CAAI,EAC7BD,EAAQI,EAAQP,EAAGK,EAAMD,EAAOH,CAAC,EACjCI,EAAOJ,GAGJC,GAASC,EAAO,OAAQD,EAAQC,EAAS,GAAK,EAEnD,MAAO,EACR,EAEA,GAAI,CACHN,EAAiB,QAAUC,CAC5B,MAAY,CACX,OAAO,eAAiBA,CACzB,CAEA,IAAIa,GAAwBd,EAAiB,QACzCe,GAAgCjB,GAAwBgB,EAAqB,EAEjF,SAASE,EAAWC,EAAG,CACrB,OAAOA,GAAK,IACd,CACA,SAASC,GAAYC,EAAO,CAC1B,OAAOA,IAAU,MAAQ,OAAOA,GAAU,YAAc,OAAOA,GAAU,QAC3E,CACA,SAASC,EAASC,EAAM,CACtB,OAAOA,GAAQ,MAAQ,OAAOA,GAAS,UAAY,CAAC,MAAM,QAAQA,CAAI,CACxE,CACA,SAASC,GAAiBT,EAAM,CAC9B,IAAIU,EAAY,GACZC,EAAW,KACXC,EAAiB,EACjBC,EAAe,EACfC,EAAa,KACjB,KAAOJ,GAAaV,EAAK,QAAQ,CAC/Bc,EAAad,EAAKU,CAAS,EAC3BA,IACA,MAAMK,EAAOf,EAAKU,CAAS,EAc3B,IAbqBK,IAAS,KAAOA,IAAS,KAAOA,IAAS,MAC1CD,IAAe,OAC7BH,IAAaI,EACfJ,EAAW,KACHA,IACRA,EAAWI,IAEVJ,IACCI,IAAS,KACXH,IACEG,IAAS,KACXF,KAEAD,GAAkBC,GAAgBD,IAAmBC,EACvD,OAAOH,CACX,CACA,OAAO,IACT,CAEA,IAAIM,GAAkB,IAAM,aAC5B,GAAI,CACF,KAAM,CAAE,kBAAAC,EAAmB,SAAAC,EAAU,UAAAC,CAAS,EAAK,QAAQ,QAAQ,MAAM,EACrE,MAAM,QAAQF,EAAkB,QAAQ,QAAO,CAAE,CAAC,IACpDD,GAAkB,CAACV,EAAOc,IAAY,CACpC,KAAM,CAACC,EAAOC,CAAU,EAAIL,EAAkBX,CAAK,EACnD,OAAIe,IAAUH,EACL,qBAEF,UAAUG,IAAUF,EAAY,IAAM,EAAE,IAAIC,EAAQ,QAAQE,EAAYF,CAAO,CAAC,GACzF,EAEJ,MAAkB,CAElB,CAQA,IAAIG,EAAc,GAClB,GAAI,CAEF,MAAMC,EAAW,QAAQ,MAAM,EAC/BD,EAAcC,EAAS,QAAUA,EAAS,QAAQ,OAAS,EAC7D,MAAwB,CACtBD,EAAc,EAChB,CAEA,MAAME,EAAc,QACpB,SAASC,GAAiBC,EAAQC,EAAYC,EAAc,CAC1D,MAAMC,EAAQH,EAAO,MAAMF,CAAW,EAChCM,EAAK,OAAO,KAAKJ,CAAM,EAAI,EAAI,EACrC,IAAIK,EAAQ,EACZ,GAAIJ,EAAaE,EAAM,OACrB,OAAOH,EAAO,OAChB,QAASpC,EAAI,EAAGA,EAAIqC,EAAa,EAAGrC,IAClCyC,GAASF,EAAMvC,CAAC,EAAE,OAASwC,EAC7B,OAAOC,EAAQH,CACjB,CACA,SAASI,GAAmBN,EAAQO,EAAQ,CAC1C,GAAIA,EAASP,EAAO,OAClB,MAAM,IAAI,MACR,+CAA+CO,CAAM,aAAaP,EAAO,MAAM,EACrF,EAEE,MAAMG,EAAQH,EAAO,MAAMF,CAAW,EAChCM,EAAK,OAAO,KAAKJ,CAAM,EAAI,EAAI,EACrC,IAAIQ,EAAU,EACVC,EAAO,EACX,KAAOA,EAAON,EAAM,OAAQM,IAAQ,CAClC,MAAMC,EAAaP,EAAMM,CAAI,EAAE,OAASL,EACxC,GAAII,EAAUE,GAAcH,EAC1B,MACFC,GAAWE,CACb,CACA,OAAOD,EAAO,CAChB,CAIA,IAAIE,EACJA,EAAyB,0BACzB,OAAOA,EAAuB,MAAM,EAGpC,IAAIC,EAAgB,CAClB,QAAS,CACP,QACA,OACA,QACA,WACA,WACA,UACA,KACA,OACA,UACA,MACA,WACA,KACA,SACA,SACA,QACA,MACA,MACA,QACA,QACA,OACA,MACA,OACA,QACA,QACA,UACA,SACA,SACA,OACA,OACA,QACA,KACA,aACA,SACA,OACA,QACJ,EACE,OAAQ,CACN,aACA,YACA,MACA,UACA,UACA,YACA,SACA,SACA,OACJ,CACA,EAAG,IAAI,IAAIA,EAAc,OAAO,EAAG,IAAI,IAAIA,EAAc,MAAM,EAE/D,MAAMC,GAAc,CAACC,EAAKC,EAAQC,EAAaC,EAAOC,EAAMC,IAAY,CACtE,MAAMC,EAAON,EAAI,YAAW,EACtBO,EAAaD,IAAS,UAAY,GAAK,IAAIA,CAAI,GACrD,IAAIE,EAAc,GAClB,GAAIR,EAAI,KAAK,MAAM,SAAW,EAAG,CAC/B,MAAMS,EAAkBP,EAAcD,EAAO,OAC7CO,EAAc,KAAKP,EAAO,YAAY,GAAGQ,CAAe,YAAYJ,EAAQL,EAAI,KAAK,MAAOC,EAAQQ,EAAiBN,EAAOC,CAAI,CAAC,GAAGH,EAAO,IAAM,KAAO,GAAG,GAAGA,EAAO,YAAY,GAAGQ,CAAe,cAAcJ,EAAQL,EAAI,KAAK,QAASC,EAAQQ,EAAiBN,EAAOC,CAAI,CAAC,GAAGH,EAAO,IAAM,GAAK,GAAG,GAAGA,EAAO,YAAY,GAAGC,CAAW,GAC9U,CACA,MAAO,gBAAgBK,CAAU,IAAIC,CAAW,EAClD,EACME,GAAQV,GAAQA,GAAO,CAAC,CAACA,EAAI,gBAC7BW,GAAS,CAAE,UAAWZ,GAAa,KAAAW,EAAI,EAEvC,CACJ,cAAAE,GACA,WAAAC,GACA,UAAAC,GACA,aAAAC,GACA,mBAAAC,GACA,kBAAAC,EACF,EAAIC,GACJ,IAAIC,EAAU,CACZH,GACAD,GACAF,GACAD,GACAE,GACAG,GACAN,EACF,EACA,SAASS,GAAcT,EAAQ,CAC7BQ,EAAU,CAACR,CAAM,EAAE,OAAOQ,CAAO,CACnC,CACA,SAASE,IAAiB,CACxB,OAAOF,CACT,CAEA,SAASG,GAAcC,EAAUC,EAAO,CACtC,MAAO,GAAGD,CAAQ,IAAIC,CAAK,EAC7B,CACA,SAASC,GAAcC,EAAK,CAC1B,GAAI,CAAC,QAAQ,KAAKA,CAAG,EACnB,MAAM,IAAI,MAAM,uCAAuC,EACzD,OAAOA,EAAI,QAAQ,QAAS,EAAE,CAChC,CACA,SAASC,GAAgBC,EAASjD,EAAS,CACzC,MAAMkD,EAASlD,EAAQ,eACjBmD,EAAuB,OAAO,OAAO,IAAI,EAC/C,IAAIC,EAAmB,GACnBC,EAAQ,GACZ,GAAIJ,GAAW,KACb,GAAI,CACFG,EAAmBH,EACF,IAAI,SAAS,UAAWG,CAAgB,EAChDD,CAAI,CACf,MAAQ,CACR,CAGF,OAAKD,IAAW,OAASA,IAAW,QADlBE,IAEhBC,EAAQ,IACH,CAAE,KAAAF,EAAM,MAAAE,CAAK,CACtB,CACA,SAASC,GAAmBC,EAAQ,CAClC,OAAOA,EAAO,SAAS;AAAA,CAAI,EAAI;AAAA,EAC/BA,CAAM;AAAA,EACJA,CACJ,CACA,SAASC,EAAsBD,EAAQ,CACrC,OAAOA,EAAO,OAAS,GAAKA,EAAO,WAAW;AAAA,CAAI,GAAKA,EAAO,SAAS;AAAA,CAAI,EAAIA,EAAO,MAAM,EAAG,EAAE,EAAIA,CACvG,CACA,MAAME,GAAc,GACdC,GAAoB,GAC1B,SAASC,GAAUtC,EAAKuC,EAAS,EAAGC,EAAkB,GAAI,CACxD,OAAOC,EACLC,GAAO1C,EAAK,CACV,YAAAoC,GACA,OAAAG,EACA,QAASlB,GAAc,EACvB,kBAAAgB,GACA,GAAGG,CACT,CAAK,CACL,CACA,CACA,SAASG,GAAqBtF,EAAK,CACjC,OAAOA,EAAI,QAAQ,YAAa,MAAM,CACxC,CACA,SAASuF,EAAoBvF,EAAK,CAChC,MAAO,KAAKsF,GAAqBtF,CAAG,CAAC,IACvC,CACA,SAASoF,EAAkBP,EAAQ,CACjC,OAAOA,EAAO,QAAQ,WAAY;AAAA,CAAI,CACxC,CACA,eAAeW,GAAiBC,EAAaC,EAAcC,EAAc,CACvE,MAAMC,EAAY,OAAO,KAAKF,CAAY,EAAE,KAAKtF,EAAgB,EAAE,IAChEiE,GAAQ,WAAWkB,EAAoBlB,CAAG,CAAC,OAAOkB,EAAoBH,EAAkBM,EAAarB,CAAG,CAAC,CAAC,CAAC,GAChH,EACQE,EAAU,GAAGkB,EAAY,UAAS,CAAE;AAAA;AAAA,EAE1CG,EAAU,KAAK;AAAA;AAAA,CAAM,CAAC;AAAA,EAEhBC,EAAa,MAAMJ,EAAY,iBAAiBE,CAAY,EAC9CE,GAAc,MAAQA,IAAetB,GAGzD,MAAMkB,EAAY,iBAChBE,EACApB,CACJ,CACA,CACA,SAASuB,EAAgBC,EAAU,CACjC,SAASC,GAAkB,CACzB,IAAIC,EAAIC,EACR,MAAMC,EAAc,cAAc,KAAKJ,GAAY,EAAE,EAC/CK,GAAgBH,EAAKE,GAAe,KAAO,OAASA,EAAY,CAAC,IAAM,KAAO,OAASF,EAAG,OAChG,GAAIG,EACF,OAAOA,EACT,MAAMC,EAAY,WAAW,KAAKN,GAAY,EAAE,EAChD,QAASG,EAAKG,GAAa,KAAO,OAASA,EAAU,CAAC,IAAM,KAAO,OAASH,EAAG,SAAW,CAC5F,CACA,MAAMI,EAAcN,EAAe,EACnC,IAAIO,EAAkBR,GAAY,KAAO,OAASA,EAAS,KAAI,EAC/D,OAAIO,IACFC,EAAkBA,GAAmB,KAAO,OAASA,EAAgB,QAAQ,IAAI,OAAO,IAAI,IAAI,OAAOD,CAAW,CAAC,GAAI,IAAI,EAAG,EAAE,EAAE,QAAQ,OAAQ,GAAG,GAEhJC,CACT,CACA,SAASC,EAAeC,EAAS,GAAI5E,EAAS,GAAI,CAChD,MAAM6E,EAAe,MAAM,KAAKD,CAAM,EACtC,OAAA5E,EAAO,QAAQ,CAAC8E,EAAeC,IAAU,CACvC,MAAMC,EAAgBH,EAAaE,CAAK,EACpC,MAAM,QAAQH,EAAOG,CAAK,CAAC,EAC7BF,EAAaE,CAAK,EAAIJ,EAAeC,EAAOG,CAAK,EAAGD,CAAa,EACxDlG,EAASoG,CAAa,EAC/BH,EAAaE,CAAK,EAAIE,EAAkBL,EAAOG,CAAK,EAAGD,CAAa,EAEpED,EAAaE,CAAK,EAAID,CAE1B,CAAC,EACMD,CACT,CACA,SAASI,EAAkBL,EAAQ5E,EAAQ,CACzC,GAAIpB,EAASgG,CAAM,GAAKhG,EAASoB,CAAM,EAAG,CACxC,MAAM6E,EAAe,CAAE,GAAGD,CAAM,EAChC,cAAO,KAAK5E,CAAM,EAAE,QAASwC,GAAQ,CAC/B5D,EAASoB,EAAOwC,CAAG,CAAC,GAAK,CAACxC,EAAOwC,CAAG,EAAE,SAClCA,KAAOoC,EAGXC,EAAarC,CAAG,EAAIyC,EAAkBL,EAAOpC,CAAG,EAAGxC,EAAOwC,CAAG,CAAC,EAF9D,OAAO,OAAOqC,EAAc,CAAE,CAACrC,CAAG,EAAGxC,EAAOwC,CAAG,EAAG,EAG3C,MAAM,QAAQxC,EAAOwC,CAAG,CAAC,EAClCqC,EAAarC,CAAG,EAAImC,EAAeC,EAAOpC,CAAG,EAAGxC,EAAOwC,CAAG,CAAC,EAE3D,OAAO,OAAOqC,EAAc,CAAE,CAACrC,CAAG,EAAGxC,EAAOwC,CAAG,EAAG,CAEtD,CAAC,EACMqC,CACT,SAAW,MAAM,QAAQD,CAAM,GAAK,MAAM,QAAQ5E,CAAM,EACtD,OAAO2E,EAAeC,EAAQ5E,CAAM,EAEtC,OAAO4E,CACT,CAEA,MAAMM,GAAQ,GACRC,EAAQ,mEACRC,GAAY,IAAI,WAAW,EAAE,EAC7BC,EAAY,IAAI,WAAW,GAAG,EACpC,QAASzH,EAAI,EAAGA,EAAIuH,EAAM,OAAQvH,IAAK,CACnC,MAAM0H,EAAIH,EAAM,WAAWvH,CAAC,EAC5BwH,GAAUxH,CAAC,EAAI0H,EACfD,EAAUC,CAAC,EAAI1H,CACnB,CACA,SAAS2H,GAAOC,EAAU,CACtB,MAAM9F,EAAQ,IAAI,WAAW,CAAC,EACxB+F,EAAU,GAChB,IAAIV,EAAQ,EACZ,EAAG,CACC,MAAMW,EAAOC,GAAQH,EAAUT,CAAK,EAC9BtE,EAAO,GACb,IAAImF,EAAS,GACTC,EAAU,EACdnG,EAAM,CAAC,EAAI,EACX,QAAS9B,EAAImH,EAAOnH,EAAI8H,EAAM9H,IAAK,CAC/B,IAAIkI,EACJlI,EAAImI,EAAcP,EAAU5H,EAAG8B,EAAO,CAAC,EACvC,MAAMsG,EAAMtG,EAAM,CAAC,EACfsG,EAAMH,IACND,EAAS,IACbC,EAAUG,EACNC,EAAWT,EAAU5H,EAAG8H,CAAI,GAC5B9H,EAAImI,EAAcP,EAAU5H,EAAG8B,EAAO,CAAC,EACvC9B,EAAImI,EAAcP,EAAU5H,EAAG8B,EAAO,CAAC,EACvC9B,EAAImI,EAAcP,EAAU5H,EAAG8B,EAAO,CAAC,EACnCuG,EAAWT,EAAU5H,EAAG8H,CAAI,GAC5B9H,EAAImI,EAAcP,EAAU5H,EAAG8B,EAAO,CAAC,EACvCoG,EAAM,CAACE,EAAKtG,EAAM,CAAC,EAAGA,EAAM,CAAC,EAAGA,EAAM,CAAC,EAAGA,EAAM,CAAC,CAAC,GAGlDoG,EAAM,CAACE,EAAKtG,EAAM,CAAC,EAAGA,EAAM,CAAC,EAAGA,EAAM,CAAC,CAAC,GAI5CoG,EAAM,CAACE,CAAG,EAEdvF,EAAK,KAAKqF,CAAG,CACjB,CACKF,GACDM,GAAKzF,CAAI,EACbgF,EAAQ,KAAKhF,CAAI,EACjBsE,EAAQW,EAAO,CACnB,OAASX,GAASS,EAAS,QAC3B,OAAOC,CACX,CACA,SAASE,GAAQH,EAAUT,EAAO,CAC9B,MAAMoB,EAAMX,EAAS,QAAQ,IAAKT,CAAK,EACvC,OAAOoB,IAAQ,GAAKX,EAAS,OAASW,CAC1C,CACA,SAASJ,EAAcP,EAAUpH,EAAKsB,EAAO0G,EAAG,CAC5C,IAAIzH,EAAQ,EACR0H,EAAQ,EACRC,EAAU,EACd,EAAG,CACC,MAAM,EAAId,EAAS,WAAWpH,GAAK,EACnCkI,EAAUjB,EAAU,CAAC,EACrB1G,IAAU2H,EAAU,KAAOD,EAC3BA,GAAS,CACb,OAASC,EAAU,IACnB,MAAMC,EAAe5H,EAAQ,EAC7B,OAAAA,KAAW,EACP4H,IACA5H,EAAQ,YAAc,CAACA,GAE3Be,EAAM0G,CAAC,GAAKzH,EACLP,CACX,CACA,SAAS6H,EAAWT,EAAU5H,EAAG4I,EAAQ,CACrC,OAAI5I,GAAK4I,EACE,GACJhB,EAAS,WAAW5H,CAAC,IAAMsH,EACtC,CACA,SAASgB,GAAKzF,EAAM,CAChBA,EAAK,KAAKgG,EAAgB,CAC9B,CACA,SAASA,GAAiB/I,EAAGC,EAAG,CAC5B,OAAOD,EAAE,CAAC,EAAIC,EAAE,CAAC,CACrB,CAGA,MAAM+I,GAAc,iBAWdC,GAAW,2EAUXC,GAAY,kEAClB,IAAIC,GACH,SAAUA,EAAS,CAChBA,EAAQA,EAAQ,MAAW,CAAC,EAAI,QAChCA,EAAQA,EAAQ,KAAU,CAAC,EAAI,OAC/BA,EAAQA,EAAQ,MAAW,CAAC,EAAI,QAChCA,EAAQA,EAAQ,aAAkB,CAAC,EAAI,eACvCA,EAAQA,EAAQ,aAAkB,CAAC,EAAI,eACvCA,EAAQA,EAAQ,eAAoB,CAAC,EAAI,iBACzCA,EAAQA,EAAQ,SAAc,CAAC,EAAI,UACvC,GAAGA,IAAYA,EAAU,GAAG,EAC5B,SAASC,GAAcC,EAAO,CAC1B,OAAOL,GAAY,KAAKK,CAAK,CACjC,CACA,SAASC,GAAoBD,EAAO,CAChC,OAAOA,EAAM,WAAW,IAAI,CAChC,CACA,SAASE,EAAeF,EAAO,CAC3B,OAAOA,EAAM,WAAW,GAAG,CAC/B,CACA,SAASG,GAAUH,EAAO,CACtB,OAAOA,EAAM,WAAW,OAAO,CACnC,CACA,SAASI,EAAWJ,EAAO,CACvB,MAAO,SAAS,KAAKA,CAAK,CAC9B,CACA,SAASK,EAAiBL,EAAO,CAC7B,MAAMM,EAAQV,GAAS,KAAKI,CAAK,EACjC,OAAOO,EAAQD,EAAM,CAAC,EAAGA,EAAM,CAAC,GAAK,GAAIA,EAAM,CAAC,EAAGA,EAAM,CAAC,GAAK,GAAIA,EAAM,CAAC,GAAK,IAAKA,EAAM,CAAC,GAAK,GAAIA,EAAM,CAAC,GAAK,EAAE,CACtH,CACA,SAASE,GAAaR,EAAO,CACzB,MAAMM,EAAQT,GAAU,KAAKG,CAAK,EAC5BS,EAAOH,EAAM,CAAC,EACpB,OAAOC,EAAQ,QAAS,GAAID,EAAM,CAAC,GAAK,GAAI,GAAIJ,EAAeO,CAAI,EAAIA,EAAO,IAAMA,EAAMH,EAAM,CAAC,GAAK,GAAIA,EAAM,CAAC,GAAK,EAAE,CAC5H,CACA,SAASC,EAAQG,EAAQC,EAAMC,EAAMC,EAAMJ,EAAMK,EAAOC,EAAM,CAC1D,MAAO,CACH,OAAAL,EACA,KAAAC,EACA,KAAAC,EACA,KAAAC,EACA,KAAAJ,EACA,MAAAK,EACA,KAAAC,EACA,KAAMjB,EAAQ,QACtB,CACA,CACA,SAASkB,EAAShB,EAAO,CACrB,GAAIC,GAAoBD,CAAK,EAAG,CAC5B,MAAMiB,EAAMZ,EAAiB,QAAUL,CAAK,EAC5C,OAAAiB,EAAI,OAAS,GACbA,EAAI,KAAOnB,EAAQ,eACZmB,CACX,CACA,GAAIf,EAAeF,CAAK,EAAG,CACvB,MAAMiB,EAAMZ,EAAiB,iBAAmBL,CAAK,EACrD,OAAAiB,EAAI,OAAS,GACbA,EAAI,KAAO,GACXA,EAAI,KAAOnB,EAAQ,aACZmB,CACX,CACA,GAAId,GAAUH,CAAK,EACf,OAAOQ,GAAaR,CAAK,EAC7B,GAAID,GAAcC,CAAK,EACnB,OAAOK,EAAiBL,CAAK,EACjC,MAAMiB,EAAMZ,EAAiB,kBAAoBL,CAAK,EACtD,OAAAiB,EAAI,OAAS,GACbA,EAAI,KAAO,GACXA,EAAI,KAAOjB,EACLA,EAAM,WAAW,GAAG,EAChBF,EAAQ,MACRE,EAAM,WAAW,GAAG,EAChBF,EAAQ,KACRA,EAAQ,aAChBA,EAAQ,MACPmB,CACX,CACA,SAASC,GAAkBT,EAAM,CAG7B,GAAIA,EAAK,SAAS,KAAK,EACnB,OAAOA,EACX,MAAMzC,EAAQyC,EAAK,YAAY,GAAG,EAClC,OAAOA,EAAK,MAAM,EAAGzC,EAAQ,CAAC,CAClC,CACA,SAASmD,GAAWF,EAAKG,EAAM,CAC3BC,GAAcD,EAAMA,EAAK,IAAI,EAGzBH,EAAI,OAAS,IACbA,EAAI,KAAOG,EAAK,KAIhBH,EAAI,KAAOC,GAAkBE,EAAK,IAAI,EAAIH,EAAI,IAEtD,CAKA,SAASI,GAAcJ,EAAKK,EAAM,CAC9B,MAAMC,EAAMD,GAAQxB,EAAQ,aACtB0B,EAASP,EAAI,KAAK,MAAM,GAAG,EAGjC,IAAIQ,EAAU,EAGVC,EAAW,EAIXC,EAAmB,GACvB,QAAS9K,EAAI,EAAGA,EAAI2K,EAAO,OAAQ3K,IAAK,CACpC,MAAM+K,EAAQJ,EAAO3K,CAAC,EAEtB,GAAI,CAAC+K,EAAO,CACRD,EAAmB,GACnB,QACJ,CAIA,GAFAA,EAAmB,GAEfC,IAAU,IAId,IAAIA,IAAU,KAAM,CACZF,GACAC,EAAmB,GACnBD,IACAD,KAEKF,IAGLC,EAAOC,GAAS,EAAIG,GAExB,QACJ,CAGAJ,EAAOC,GAAS,EAAIG,EACpBF,IACJ,CACA,IAAIjB,EAAO,GACX,QAAS5J,EAAI,EAAGA,EAAI4K,EAAS5K,IACzB4J,GAAQ,IAAMe,EAAO3K,CAAC,GAEtB,CAAC4J,GAASkB,GAAoB,CAAClB,EAAK,SAAS,KAAK,KAClDA,GAAQ,KAEZQ,EAAI,KAAOR,CACf,CAIA,SAASoB,GAAU7B,EAAOoB,EAAM,CAC5B,GAAI,CAACpB,GAAS,CAACoB,EACX,MAAO,GACX,MAAMH,EAAMD,EAAShB,CAAK,EAC1B,IAAI8B,EAAYb,EAAI,KACpB,GAAIG,GAAQU,IAAchC,EAAQ,SAAU,CACxC,MAAMiC,EAAUf,EAASI,CAAI,EACvBY,EAAWD,EAAQ,KACzB,OAAQD,EAAS,CACb,KAAKhC,EAAQ,MACTmB,EAAI,KAAOc,EAAQ,KAEvB,KAAKjC,EAAQ,KACTmB,EAAI,MAAQc,EAAQ,MAExB,KAAKjC,EAAQ,MACb,KAAKA,EAAQ,aACTqB,GAAWF,EAAKc,CAAO,EAE3B,KAAKjC,EAAQ,aAETmB,EAAI,KAAOc,EAAQ,KACnBd,EAAI,KAAOc,EAAQ,KACnBd,EAAI,KAAOc,EAAQ,KAEvB,KAAKjC,EAAQ,eAETmB,EAAI,OAASc,EAAQ,MACrC,CACYC,EAAWF,IACXA,EAAYE,EACpB,CACAX,GAAcJ,EAAKa,CAAS,EAC5B,MAAMG,EAAYhB,EAAI,MAAQA,EAAI,KAClC,OAAQa,EAAS,CAGb,KAAKhC,EAAQ,KACb,KAAKA,EAAQ,MACT,OAAOmC,EACX,KAAKnC,EAAQ,aAAc,CAEvB,MAAMW,EAAOQ,EAAI,KAAK,MAAM,CAAC,EAC7B,OAAKR,EAEDL,EAAWgB,GAAQpB,CAAK,GAAK,CAACI,EAAWK,CAAI,EAItC,KAAOA,EAAOwB,EAElBxB,EAAOwB,EAPHA,GAAa,GAQ5B,CACA,KAAKnC,EAAQ,aACT,OAAOmB,EAAI,KAAOgB,EACtB,QACI,OAAOhB,EAAI,OAAS,KAAOA,EAAI,KAAOA,EAAI,KAAOA,EAAI,KAAOA,EAAI,KAAOgB,CACnF,CACA,CAEA,SAASC,EAAQlC,EAAOoB,EAAM,CAI1B,OAAIA,GAAQ,CAACA,EAAK,SAAS,GAAG,IAC1BA,GAAQ,KACLS,GAAU7B,EAAOoB,CAAI,CAChC,CAKA,SAASe,GAAc1B,EAAM,CACzB,GAAI,CAACA,EACD,MAAO,GACX,MAAMzC,EAAQyC,EAAK,YAAY,GAAG,EAClC,OAAOA,EAAK,MAAM,EAAGzC,EAAQ,CAAC,CAClC,CAEA,MAAMoE,EAAS,EACTC,GAAgB,EAChBC,GAAc,EACdC,GAAgB,EAChBC,GAAc,EAEpB,SAASC,GAAUhE,EAAUiE,EAAO,CAChC,MAAMC,EAAgBC,EAAwBnE,EAAU,CAAC,EACzD,GAAIkE,IAAkBlE,EAAS,OAC3B,OAAOA,EAGNiE,IACDjE,EAAWA,EAAS,MAAK,GAC7B,QAAS5H,EAAI8L,EAAe9L,EAAI4H,EAAS,OAAQ5H,EAAI+L,EAAwBnE,EAAU5H,EAAI,CAAC,EACxF4H,EAAS5H,CAAC,EAAIgM,GAAapE,EAAS5H,CAAC,EAAG6L,CAAK,EAEjD,OAAOjE,CACX,CACA,SAASmE,EAAwBnE,EAAUnF,EAAO,CAC9C,QAASzC,EAAIyC,EAAOzC,EAAI4H,EAAS,OAAQ5H,IACrC,GAAI,CAACiM,GAASrE,EAAS5H,CAAC,CAAC,EACrB,OAAOA,EAEf,OAAO4H,EAAS,MACpB,CACA,SAASqE,GAASpJ,EAAM,CACpB,QAAS2F,EAAI,EAAGA,EAAI3F,EAAK,OAAQ2F,IAC7B,GAAI3F,EAAK2F,CAAC,EAAE+C,CAAM,EAAI1I,EAAK2F,EAAI,CAAC,EAAE+C,CAAM,EACpC,MAAO,GAGf,MAAO,EACX,CACA,SAASS,GAAanJ,EAAMgJ,EAAO,CAC/B,OAAKA,IACDhJ,EAAOA,EAAK,MAAK,GACdA,EAAK,KAAKqJ,EAAc,CACnC,CACA,SAASA,GAAepM,EAAGC,EAAG,CAC1B,OAAOD,EAAEyL,CAAM,EAAIxL,EAAEwL,CAAM,CAC/B,CAEA,IAAIY,EAAQ,GAiBZ,SAASC,GAAaC,EAAUC,EAAQC,EAAKC,EAAM,CAC/C,KAAOD,GAAOC,GAAM,CAChB,MAAMC,EAAMF,GAAQC,EAAOD,GAAQ,GAC7BG,EAAML,EAASI,CAAG,EAAElB,CAAM,EAAIe,EACpC,GAAII,IAAQ,EACR,OAAAP,EAAQ,GACDM,EAEPC,EAAM,EACNH,EAAME,EAAM,EAGZD,EAAOC,EAAM,CAErB,CACA,OAAAN,EAAQ,GACDI,EAAM,CACjB,CACA,SAASI,GAAWN,EAAUC,EAAQnF,EAAO,CACzC,QAASnH,EAAImH,EAAQ,EAAGnH,EAAIqM,EAAS,QAC7BA,EAASrM,CAAC,EAAEuL,CAAM,IAAMe,EADanF,EAAQnH,IACjD,CAGJ,OAAOmH,CACX,CACA,SAASyF,GAAWP,EAAUC,EAAQnF,EAAO,CACzC,QAASnH,EAAImH,EAAQ,EAAGnH,GAAK,GACrBqM,EAASrM,CAAC,EAAEuL,CAAM,IAAMe,EADAnF,EAAQnH,IACpC,CAGJ,OAAOmH,CACX,CACA,SAAS0F,IAAgB,CACrB,MAAO,CACH,QAAS,GACT,WAAY,GACZ,UAAW,EACnB,CACA,CAKA,SAASC,GAAqBT,EAAUC,EAAQxK,EAAO8C,EAAK,CACxD,KAAM,CAAE,QAAAmI,EAAS,WAAAC,EAAY,UAAAC,CAAS,EAAKnL,EAC3C,IAAIyK,EAAM,EACNC,EAAOH,EAAS,OAAS,EAC7B,GAAIzH,IAAQmI,EAAS,CACjB,GAAIT,IAAWU,EACX,OAAAb,EAAQc,IAAc,IAAMZ,EAASY,CAAS,EAAE1B,CAAM,IAAMe,EACrDW,EAEPX,GAAUU,EAEVT,EAAMU,IAAc,GAAK,EAAIA,EAG7BT,EAAOS,CAEf,CACA,OAAAnL,EAAM,QAAU8C,EAChB9C,EAAM,WAAawK,EACXxK,EAAM,UAAYsK,GAAaC,EAAUC,EAAQC,EAAKC,CAAI,CACtE,CAEA,MAAMU,GAAgB,wDAChBC,GAAkB,0EAClBC,EAAoB,GACpBC,GAAuB,EAI7B,IAAIC,EAMAC,GACJ,MAAMC,EAAS,CACX,YAAYC,EAAKC,EAAQ,CACrB,MAAMC,EAAW,OAAOF,GAAQ,SAChC,GAAI,CAACE,GAAYF,EAAI,aACjB,OAAOA,EACX,MAAMG,EAAUD,EAAW,KAAK,MAAMF,CAAG,EAAIA,EACvC,CAAE,QAAAI,EAAS,KAAAC,EAAM,MAAAC,EAAO,WAAAC,EAAY,QAAAC,EAAS,eAAAC,CAAc,EAAKN,EACtE,KAAK,QAAUC,EACf,KAAK,KAAOC,EACZ,KAAK,MAAQC,GAAS,GACtB,KAAK,WAAaC,EAClB,KAAK,QAAUC,EACf,KAAK,eAAiBC,EACtB,MAAMC,EAAO9C,EAAQ2C,GAAc,GAAI1C,GAAcoC,CAAM,CAAC,EAC5D,KAAK,gBAAkBO,EAAQ,IAAKG,GAAM/C,EAAQ+C,GAAK,GAAID,CAAI,CAAC,EAChE,KAAM,CAAE,SAAAvG,CAAQ,EAAKgG,EACjB,OAAOhG,GAAa,UACpB,KAAK,SAAWA,EAChB,KAAK,SAAW,SAGhB,KAAK,SAAW,OAChB,KAAK,SAAWgE,GAAUhE,EAAU+F,CAAQ,GAEhD,KAAK,aAAed,GAAa,EACjC,KAAK,WAAa,OAClB,KAAK,eAAiB,MAC1B,CACJ,CAEIS,EAAmBG,GACPA,EAAI,WAAaA,EAAI,SAAW9F,GAAO8F,EAAI,QAAQ,GAE/DF,GAAsB,CAACE,EAAK,CAAE,KAAA5K,EAAM,OAAAwL,EAAQ,KAAAC,CAAI,IAAO,CAEnD,GADAzL,IACIA,EAAO,EACP,MAAM,IAAI,MAAMqK,EAAa,EACjC,GAAImB,EAAS,EACT,MAAM,IAAI,MAAMlB,EAAe,EACnC,MAAMtF,EAAUyF,EAAgBG,CAAG,EAGnC,GAAI5K,GAAQgF,EAAQ,OAChB,OAAO0G,EAAS,KAAM,KAAM,KAAM,IAAI,EAC1C,MAAMC,EAAW3G,EAAQhF,CAAI,EACvBsE,EAAQsH,GAAqBD,EAAUf,EAAI,aAAc5K,EAAMwL,EAAQC,GAAQjB,EAAoB,EACzG,GAAIlG,IAAU,GACV,OAAOoH,EAAS,KAAM,KAAM,KAAM,IAAI,EAC1C,MAAMG,EAAUF,EAASrH,CAAK,EAC9B,GAAIuH,EAAQ,SAAW,EACnB,OAAOH,EAAS,KAAM,KAAM,KAAM,IAAI,EAC1C,KAAM,CAAE,MAAAR,EAAO,gBAAAY,CAAe,EAAKlB,EACnC,OAAOc,EAASI,EAAgBD,EAAQlD,EAAa,CAAC,EAAGkD,EAAQjD,EAAW,EAAI,EAAGiD,EAAQhD,EAAa,EAAGgD,EAAQ,SAAW,EAAIX,EAAMW,EAAQ/C,EAAW,CAAC,EAAI,IAAI,CACxK,EAEJ,SAAS4C,EAASnM,EAAQS,EAAMwL,EAAQ7K,EAAM,CAC1C,MAAO,CAAE,OAAApB,EAAQ,KAAAS,EAAM,OAAAwL,EAAQ,KAAA7K,CAAI,CACvC,CACA,SAASiL,GAAqBD,EAAUI,EAAM/L,EAAMwL,EAAQC,EAAM,CAC9D,IAAInH,EAAQ2F,GAAqB0B,EAAUH,EAAQO,EAAM/L,CAAI,EAM7D,OALIsJ,EACAhF,GAASmH,IAASlB,EAAoBT,GAAaC,IAAY4B,EAAUH,EAAQlH,CAAK,EAEjFmH,IAASlB,GACdjG,IACAA,IAAU,IAAMA,IAAUqH,EAAS,OAC5B,GACJrH,CACX,CAEA,MAAM0H,GAAyB,iCACzBC,GAA4B,8BAC5BC,GAAsB,CAC1B,gBACA,0BACA,yBACA,gBACA,eACA,mBACA,kBACA,sBACA,0BACA,yBACA,gBACA,oBACF,EACA,SAASC,GAAgBC,EAAS,CAChC,GAAI,CAACA,EAAQ,SAAS,GAAG,EACvB,MAAO,CAACA,CAAO,EAEjB,MAAMC,EADS,+BACM,KAAKD,EAAQ,QAAQ,WAAY,EAAE,CAAC,EACzD,GAAI,CAACC,EACH,MAAO,CAACD,CAAO,EACjB,IAAI7E,EAAM8E,EAAM,CAAC,EACjB,OAAI9E,EAAI,WAAW,OAAO,GAAKA,EAAI,WAAW,QAAQ,KAEpDA,EADe,IAAI,IAAIA,CAAG,EACb,UAEXA,EAAI,WAAW,OAAO,IACxBA,EAAMA,EAAI,MAAM,OAAO,QAAY,KAAe,QAAQ,WAAa,QAAU,EAAI,CAAC,GAEjF,CAACA,EAAK8E,EAAM,CAAC,GAAK,OAAQA,EAAM,CAAC,GAAK,MAAM,CACrD,CACA,SAASC,GAA2BC,EAAK,CACvC,IAAIvM,EAAOuM,EAAI,KAAI,EAKnB,GAJIN,GAA0B,KAAKjM,CAAI,IAEnCA,EAAK,SAAS,SAAS,IACzBA,EAAOA,EAAK,QAAQ,mDAAoD,KAAK,GAC3E,CAACA,EAAK,SAAS,GAAG,GAAK,CAACA,EAAK,SAAS,GAAG,GAC3C,OAAO,KACT,MAAMwM,EAAoB,6BACpBC,EAAUzM,EAAK,MAAMwM,CAAiB,EACtCE,EAAeD,GAAWA,EAAQ,CAAC,EAAIA,EAAQ,CAAC,EAAI,OACpD,CAAClF,EAAK/H,EAAYC,CAAY,EAAI0M,GAAgBnM,EAAK,QAAQwM,EAAmB,EAAE,CAAC,EAC3F,MAAI,CAACjF,GAAO,CAAC/H,GAAc,CAACC,EACnB,KACF,CACL,KAAM8H,EACN,OAAQmF,GAAgB,GACxB,KAAM,OAAO,SAASlN,CAAU,EAChC,OAAQ,OAAO,SAASC,CAAY,CACxC,CACA,CACA,SAASkN,GAAmBJ,EAAK,CAC/B,IAAIvM,EAAOuM,EAAI,KAAI,EACnB,GAAI,CAACP,GAAuB,KAAKhM,CAAI,EACnC,OAAO,KACLA,EAAK,SAAS,QAAQ,IACxBA,EAAOA,EAAK,QAAQ,aAAc,MAAM,EAAE,QAAQ,6BAA8B,EAAE,GACpF,IAAI4M,EAAgB5M,EAAK,QAAQ,OAAQ,EAAE,EAAE,QAAQ,eAAgB,GAAG,EAAE,QAAQ,UAAW,EAAE,EAC/F,MAAM6M,EAAWD,EAAc,MAAM,YAAY,EACjDA,EAAgBC,EAAWD,EAAc,QAAQC,EAAS,CAAC,EAAG,EAAE,EAAID,EACpE,KAAM,CAACrF,EAAK/H,EAAYC,CAAY,EAAI0M,GAAgBU,EAAWA,EAAS,CAAC,EAAID,CAAa,EAC9F,IAAIE,EAASD,GAAYD,GAAiB,GACtC3B,EAAO1D,GAAO,CAAC,OAAQ,aAAa,EAAE,SAASA,CAAG,EAAI,OAASA,EACnE,MAAI,CAAC0D,GAAQ,CAACzL,GAAc,CAACC,EACpB,MACLqN,EAAO,WAAW,QAAQ,IAC5BA,EAASA,EAAO,MAAM,CAAC,GACrB7B,EAAK,WAAW,SAAS,IAC3BA,EAAOA,EAAK,MAAM,CAAC,GACrBA,EAAO8B,GAAU9B,CAAI,EACjB6B,IACFA,EAASA,EAAO,QAAQ,6BAA8B,EAAE,GACnD,CACL,OAAAA,EACA,KAAA7B,EACA,KAAM,OAAO,SAASzL,CAAU,EAChC,OAAQ,OAAO,SAASC,CAAY,CACxC,EACA,CACA,SAASuN,GAAgBC,EAAOjO,EAAU,GAAI,CAC5C,KAAM,CAAE,mBAAAkO,EAAqBhB,EAAmB,EAAKlN,EACrD,IAAImO,EAAUnB,GAAuB,KAAKiB,CAAK,EAAuCG,GAAkBH,CAAK,EAA1DI,GAA0BJ,CAAK,EAClF,OAAIC,EAAmB,SACrBC,EAASA,EAAO,OAAQG,GAAW,CAACJ,EAAmB,KAAMK,GAAMD,EAAO,KAAK,MAAMC,CAAC,CAAC,CAAC,GACnFJ,EAAO,IAAKG,GAAW,CAC5B,IAAI3J,EACJ,MAAMiH,GAAOjH,EAAK3E,EAAQ,eAAiB,KAAO,OAAS2E,EAAG,KAAK3E,EAASsO,EAAO,IAAI,EACvF,GAAI,CAAC1C,GAAO,OAAOA,GAAQ,UAAY,CAACA,EAAI,QAC1C,OAAO0C,EACT,MAAME,EAAW,IAAI7C,GAASC,CAAG,EAC3B,CAAE,KAAA5K,EAAM,OAAAwL,CAAM,EAAKd,GAAoB8C,EAAUF,CAAM,EAC7D,OAAItN,GAAQ,MAAQwL,GAAU,KACrB,CAAE,GAAG8B,EAAQ,KAAAtN,EAAM,OAAAwL,CAAM,EAC3B8B,CACT,CAAC,CACH,CACA,SAASD,GAA0BJ,EAAO,CACxC,OAAOA,EAAM,MAAM;AAAA,CAAI,EAAE,IAAKjN,GAASsM,GAA2BtM,CAAI,CAAC,EAAE,OAAOjC,CAAU,CAC5F,CACA,SAASqP,GAAkBH,EAAO,CAChC,OAAOA,EAAM,MAAM;AAAA,CAAI,EAAE,IAAKjN,GAAS2M,GAAmB3M,CAAI,CAAC,EAAE,OAAOjC,CAAU,CACpF,CACA,SAAS0P,GAAqBC,EAAG1O,EAAU,GAAI,CAC7C,GAAI,CAAC0O,GAAKzP,GAAYyP,CAAC,EACrB,MAAO,GACT,GAAIA,EAAE,OACJ,OAAOA,EAAE,OACX,MAAMC,EAAWD,EAAE,OAASA,EAAE,UAAY,GAC1C,IAAIE,EAAcZ,GAAgBW,EAAU3O,CAAO,EACnD,OAAIA,EAAQ,cACV4O,EAAcA,EAAY,OAAQC,GAAM7O,EAAQ,YAAY0O,EAAGG,CAAC,IAAM,EAAK,GAC7EH,EAAE,OAASE,EACJA,CACT,CAEA,eAAeE,GAAoB3K,EAAaG,EAAW,CACzD,MAAMyK,GAAe,MAAKC,GAAA,wBAAAC,CAAA,OAAC,QAAO,4BAAc,iBAAAA,CAAA,4BAAG,QAC7CC,EAAQ,IAAI,IAAI5K,EAAU,IAAKnG,GAAMA,EAAE,IAAI,CAAC,EAClD,MAAM,QAAQ,IAAI,MAAM,KAAK+Q,CAAK,EAAE,IAAI,MAAOjD,GAAS,CACtD,MAAMkD,EAAQ7K,EAAU,OAAQnG,GAAMA,EAAE,OAAS8N,CAAI,EAC/CrN,EAAO,MAAMuF,EAAY,iBAAiB8H,CAAI,EAC9CM,EAAI,IAAIwC,EAAYnQ,CAAI,EAC9B,UAAWwQ,KAAQD,EAAO,CACxB,MAAM7J,EAAQhF,GAAiB1B,EAAMwQ,EAAK,KAAMA,EAAK,MAAM,EAC3DC,GAAkBzQ,EAAM2N,EAAGjH,EAAO8J,EAAK,QAAQ,CACjD,CACA,MAAME,EAAc/C,EAAE,SAAQ,EAC1B+C,IAAgB1Q,GAClB,MAAMuF,EAAY,iBAAiB8H,EAAMqD,CAAW,CACxD,CAAC,CAAC,CACJ,CACA,MAAMC,GAAmB,+GACzB,SAASC,GAAkB5Q,EAAM2N,EAAGjH,EAAOmK,EAAS,CAClD,IAAIC,EAAQ9Q,EAAK,MAAM0G,CAAK,EAC5B,MAAMqK,EAAaJ,GAAiB,KAAKG,CAAK,EAC9C,GAAI,CAACC,EACH,MAAO,GACTD,EAAQA,EAAM,MAAMC,EAAW,KAAK,EACpC,IAAIC,EAAUvQ,GAAiBqQ,CAAK,EACpC,GAAIE,IAAY,KACd,MAAO,GACTA,GAAWtK,EAAQqK,EAAW,MAC9B,MAAME,EAAavK,EAAQqK,EAAW,MAAQA,EAAW,CAAC,EAAE,OACtDG,EAAWC,GAAuBnR,EAAMiR,CAAU,EAClDT,EAAO,KAAKY,GAAkBP,EAAS7Q,EAAM0G,CAAK,CAAC,GACzD,OAAIwK,IAAaF,EACfrD,EAAE,WAAWqD,EAASR,CAAI,EAE1B7C,EAAE,UAAUuD,EAAUF,EAASR,CAAI,EAE9B,EACT,CACA,SAASW,GAAuBnR,EAAM0G,EAAO,CAC3C,IAAI2K,EAAc,EACdC,EAAY,EAChB,KAAOD,IAAgBC,GAAa5K,EAAQ1G,EAAK,QAAQ,CACvD,MAAM2N,EAAI3N,EAAK0G,GAAO,EAClBiH,IAAM,IACR0D,IACO1D,IAAM,KACb2D,GACJ,CACA,OAAO5K,CACT,CACA,SAAS0K,GAAkBZ,EAAM7O,EAAQ+E,EAAO,CAC9C,MAAM9E,EAAaK,GAAmBN,EAAQ+E,CAAK,EAE7C1B,EADOrD,EAAO,MAAMF,CAAW,EAAEG,EAAa,CAAC,EACjC,MAAM,MAAM,EAAE,CAAC,GAAK,GAClC2P,EAAavM,EAAO,SAAS,GAAG,EAAI,GAAGA,CAAM,IAAM,GAAGA,CAAM,KAC5DlD,EAAQ0O,EAAK,OAAO,QAAQ,MAAO,MAAM,EAAE,MAAM,KAAK,EACtDgB,EAAY1P,EAAM,QAAU,EAC5B2P,EAAQ,IACd,OAAID,EACK,GAAGC,CAAK,GAAG3P,EAAM,KAAK;AAAA,CAAI,EAAE,QAAQ,KAAM,KAAK,EAAE,QAAQ,OAAQ,MAAM,CAAC,GAAG2P,CAAK,GAClF,GAAGA,CAAK;AAAA,EACf3P,EAAM,IAAKvC,GAAMA,EAAIgS,EAAahS,EAAI,EAAE,EAAE,KAAK;AAAA,CAAI,EAAE,QAAQ,KAAM,KAAK,EAAE,QAAQ,OAAQ,MAAM,CAAC;AAAA,EACjGyF,CAAM,GAAGyM,CAAK,EAChB,CACA,MAAMC,GAAa,4HACnB,SAASjB,GAAkBzQ,EAAM2N,EAAGjH,EAAOmK,EAAS,CAClD,MAAMc,EAAsB3R,EAAK,MAAM0G,CAAK,EACtCqK,EAAaW,GAAW,KAAKC,CAAmB,EAChDC,EAAoB,2DAA2D,KAAKD,CAAmB,EAC7G,GAAI,CAACZ,GAAcA,EAAW,SAAWa,GAAqB,KAAO,OAASA,EAAkB,OAC9F,OAAOhB,GAAkB5Q,EAAM2N,EAAGjH,EAAOmK,CAAO,EAClD,MAAMY,EAAQV,EAAW,CAAC,EACpBc,EAAanL,EAAQqK,EAAW,MAAQA,EAAW,CAAC,EAAE,OACtDe,EAAaV,GAAkBP,EAAS7Q,EAAM0G,CAAK,EACzD,GAAI+K,IAAU,IACZ,OAAA9D,EAAE,YAAYkE,EAAa,EAAGC,CAAU,EACjC,GAGT,MAAMC,EADa,IAAI,OAAO,gBAAgBN,CAAK,EAAE,EACzB,KAAKzR,EAAK,MAAM6R,CAAU,CAAC,EACvD,GAAI,CAACE,EACH,MAAO,GACT,MAAMC,EAAWH,EAAaE,EAAS,MAAQA,EAAS,CAAC,EAAE,OAC3D,OAAApE,EAAE,UAAUkE,EAAa,EAAGG,EAAUF,CAAU,EACzC,EACT,CACA,MAAMG,GAAoB,iBAC1B,SAASC,GAAyBC,EAAgB,CAChD,MAAMnJ,EAAQmJ,EAAe,MAAMF,EAAiB,EACpD,GAAI,CAACjJ,GAAS,CAACA,EAAM,CAAC,EACpB,OAAOmJ,EAET,MAAMxP,EAAcqG,EAAM,CAAC,EACrBlH,EAAQqQ,EAAe,MAAM,KAAK,EAIxC,GAHIrQ,EAAM,QAAU,GAGhBA,EAAM,CAAC,EAAE,KAAI,IAAO,IAAMA,EAAMA,EAAM,OAAS,CAAC,EAAE,KAAI,IAAO,GAC/D,OAAOqQ,EAET,QAAS5S,EAAI,EAAGA,EAAIuC,EAAM,OAAS,EAAGvC,IACpC,GAAIuC,EAAMvC,CAAC,IAAM,GAAI,CACnB,GAAIuC,EAAMvC,CAAC,EAAE,QAAQoD,CAAW,IAAM,EACpC,OAAOwP,EAETrQ,EAAMvC,CAAC,EAAIuC,EAAMvC,CAAC,EAAE,UAAUoD,EAAY,MAAM,CAClD,CAEF,OAAAb,EAAMA,EAAM,OAAS,CAAC,EAAI,GAC1BqQ,EAAiBrQ,EAAM,KAAK;AAAA,CAAI,EACzBqQ,CACT,CAEA,eAAeC,GAAiB7M,EAAaG,EAAW,CACtD,MAAM,QAAQ,IAAIA,EAAU,IAAI,MAAO8K,GAAS,CACzCA,EAAK,UACR,MAAMjL,EAAY,iBAAiBiL,EAAK,KAAMA,EAAK,QAAQ,CAC/D,CAAC,CAAC,CACJ,CAEA,MAAM6B,CAAc,CAClB,YAAYC,EAAc7M,EAAc8M,EAAiBnR,EAAS,CA4BlEoR,EAAA,kBACAA,EAAA,eACAA,EAAA,wBACAA,EAAA,sBACAA,EAAA,qBACAA,EAAA,yBACAA,EAAA,sBACAA,EAAA,uBACAA,EAAA,wBACAA,EAAA,qBACAA,EAAA,oBACAA,EAAA,cACAA,EAAA,eACAA,EAAA,gBACAA,EAAA,kBACAA,EAAA,gBA1CE,KAAK,aAAeF,EACpB,KAAK,aAAe7M,EACpB,KAAM,CAAE,KAAAlB,EAAM,MAAAE,CAAK,EAAKL,GACtBmO,EACAnR,CACN,EACI,KAAK,YAAcmR,GAAmB,KACtC,KAAK,aAAehO,EACpB,KAAK,cAAgBA,EACrB,KAAK,OAASE,EACd,KAAK,iBAAmB,GACxB,KAAK,cAAgB,GACrB,KAAK,eAAiB,IAAI,IAAI,OAAO,KAAK,KAAK,aAAa,CAAC,EAC7D,KAAK,UAA4B,IAAI,IACrC,KAAK,OAASrD,EAAQ,QAAU,GAChC,KAAK,MAAQ,EACb,KAAK,QAAU,EACf,KAAK,UAAY,EACjB,KAAK,gBAAkBA,EAAQ,eAC/B,KAAK,QAAU,EACf,KAAK,gBAAkB,CACrB,oBAAqB,GACrB,aAAc,GACd,GAAGA,EAAQ,cACjB,EACI,KAAK,aAAeA,EAAQ,mBAC9B,CAiBA,aAAa,OAAOkR,EAAclR,EAAS,CACzC,MAAMqE,EAAe,MAAMrE,EAAQ,oBAAoB,YAAYkR,CAAY,EACzEjO,EAAU,MAAMjD,EAAQ,oBAAoB,iBAAiBqE,CAAY,EAC/E,OAAO,IAAI4M,EAAcC,EAAc7M,EAAcpB,EAASjD,CAAO,CACvE,CACA,IAAI,aAAc,CAChB,OAAO,KAAK,YACd,CACA,8BAA8B4C,EAAU,CACtC,KAAK,eAAe,QAASyO,GAAiB,CACxCvO,GAAcuO,CAAY,IAAMzO,GAClC,KAAK,eAAe,OAAOyO,CAAY,CAC3C,CAAC,CACH,CACA,0BAA0BlD,EAAQ,CAChC,MAAMmD,EAAenD,EAAO,UAAWhQ,GAAMA,EAAE,OAAO,MAAM,+BAA+B,CAAC,EAC5F,GAAImT,IAAiB,GACnB,OAAOnD,EAAOmD,EAAe,CAAC,EAChC,MAAMC,EAAapD,EAAO,UAAWhQ,GAAMA,EAAE,OAAO,SAAS,qBAAqB,CAAC,EACnF,OAAOoT,IAAe,GAAKpD,EAAOoD,EAAa,CAAC,EAAI,IACtD,CACA,aAAaxO,EAAKyO,EAAoBxR,EAAS,CAE7C,GADA,KAAK,OAAS,GACVA,EAAQ,SAAU,CACpB,MAAMmO,EAASM,GAAqBzO,EAAQ,OAAS,IAAI,MAAM,UAAU,EAAG,CAAE,mBAAoB,GAAI,EAChGiO,EAAQ,KAAK,0BAA0BE,CAAM,EACnD,GAAI,CAACF,EACH,MAAM,IAAI,MACR;AAAA,EACR,KAAK,UAAUE,CAAM,CAAC,EACxB,EAEMF,EAAM,SACN,KAAK,iBAAiB,KAAK,CACzB,SAAUuD,EACV,GAAGvD,CACX,CAAO,CACH,MAAWjO,EAAQ,YACjB,KAAK,cAAc,KAAK,CACtB,GAAGA,EAAQ,YACX,SAAUwR,CAClB,CAAO,EAED,KAAK,cAAczO,CAAG,EAAIyO,CAE9B,CACA,OAAQ,CACN,KAAK,cAAgB,KAAK,aAC1B,KAAK,UAA4B,IAAI,IACrC,KAAK,MAAQ,EACb,KAAK,QAAU,EACf,KAAK,UAAY,EACjB,KAAK,QAAU,EACf,KAAK,OAAS,EAChB,CACA,MAAM,MAAO,CACX,MAAMC,EAAuB,OAAO,KAAK,KAAK,aAAa,EAAE,OACvDC,EAAqB,KAAK,iBAAiB,OAC3CC,EAAkB,KAAK,cAAc,OACrCC,EAAU,CAACH,GAAwB,CAACC,GAAsB,CAACC,EAC3DE,EAAS,CACb,QAAS,GACT,MAAO,EACb,EACI,OAAK,KAAK,QAAU,KAAK,eAAe,OAAS,CAACD,GAC5CH,IACF,MAAMvN,GAAiB,KAAK,aAAc,KAAK,cAAe,KAAK,YAAY,EAC/E,KAAK,YAAc,IAEjBwN,GACF,MAAM5C,GAAoB,KAAK,aAAc,KAAK,gBAAgB,EAChE6C,GACF,MAAMX,GAAiB,KAAK,aAAc,KAAK,aAAa,EAC9Da,EAAO,MAAQ,IACN,CAACJ,GAAwB,KAAK,cACnC,KAAK,kBAAoB,QAC3B,MAAM,KAAK,aAAa,mBAAmB,KAAK,YAAY,EAC5D,KAAK,YAAc,IAErBI,EAAO,QAAU,IAEZA,CACT,CACA,mBAAoB,CAClB,OAAO,KAAK,eAAe,MAAQ,CACrC,CACA,kBAAmB,CACjB,OAAO,MAAM,KAAK,KAAK,cAAc,CACvC,CACA,qBAAsB,CAChB,KAAK,kBAAoB,OAAS,KAAK,eAAe,OACxD,KAAK,OAAS,GACd,KAAK,eAAe,QAAS9O,GAAQ,OAAO,KAAK,cAAcA,CAAG,CAAC,EACnE,KAAK,eAAe,MAAK,EAE7B,CACA,MAAM,CACJ,SAAAH,EACA,SAAAkP,EACA,IAAA/O,EACA,eAAAgO,EACA,SAAAgB,EACA,MAAAC,EACA,YAAAC,CACJ,EAAK,CACD,KAAK,UAAU,IAAIrP,GAAW,KAAK,UAAU,IAAIA,CAAQ,GAAK,GAAK,CAAC,EACpE,MAAMC,EAAQ,OAAO,KAAK,UAAU,IAAID,CAAQ,CAAC,EAC5CG,IACHA,EAAMJ,GAAcC,EAAUC,CAAK,GAC/BkP,GAAY,KAAK,cAAchP,CAAG,IAAM,QAC5C,KAAK,eAAe,OAAOA,CAAG,EAChC,IAAIyO,EAAqBS,GAAe,OAAOH,GAAa,SAAWA,EAAWnO,GAAUmO,EAAU,OAAQ,KAAK,eAAe,EAC7HG,IACHT,EAAqBlO,GAAmBkO,CAAkB,GACxDS,GACEA,EAAY,SAAWA,EAAY,QAAQ,MAAM,MAAM,GAAK,CAACT,EAAmB,MAAM,MAAM,IAC9FS,EAAY,QAAUnO,EAAkBmO,EAAY,OAAO,GAE/D,MAAMxN,EAAWsN,EAAWhB,EAAiBkB,EAAcA,EAAY,QAAU,KAAK,cAAclP,CAAG,EACjGkC,EAAkBT,EAAgBC,CAAQ,EAC1CyN,EAAOjN,IAAoBT,EAAgBgN,CAAkB,EAC7DW,EAAc1N,IAAa,OAC3B2N,EAAsBL,GAAY,KAAK,aAAeE,GAAeA,EAAY,SAAW,KAIlG,OAHIC,GAAQ,CAACH,GAAY,CAACE,IACxB,KAAK,cAAclP,CAAG,EAAIyO,GAExBW,GAAe,KAAK,kBAAoB,QAAU,CAACA,GAAe,CAACC,KAAyB,KAAK,kBAAoB,OAAS,KAAK,kBAAoB,QACrJ,KAAK,kBAAoB,MACtBF,EAOH,KAAK,WANDC,EACF,KAAK,UAEL,KAAK,QACP,KAAK,aAAapP,EAAKyO,EAAoB,CAAE,MAAAQ,EAAO,SAAAD,EAAU,YAAAE,EAAa,IAK7E,KAAK,aAAalP,EAAKyO,EAAoB,CAAE,MAAAQ,EAAO,SAAAD,EAAU,YAAAE,EAAa,EAC3E,KAAK,SAEA,CACL,OAAQ,GACR,MAAApP,EACA,SAAU,GACV,IAAAE,EACA,KAAM,EACd,GAEWmP,GAUH,KAAK,UACE,CACL,OAAQ,GACR,MAAArP,EACA,SAAU,GACV,IAAAE,EACA,KAAM,EAChB,IAhBQ,KAAK,YACE,CACL,OAAQS,EAAsBgO,CAAkB,EAChD,MAAA3O,EACA,SAAUoC,IAAoB,OAASzB,EAAsByB,CAAe,EAAI,OAChF,IAAAlC,EACA,KAAM,EAChB,EAYE,CACA,MAAM,MAAO,CACX,MAAMsP,EAAW,CACf,SAAU,KAAK,aACf,MAAO,EACP,YAAa,GACb,QAAS,EACT,UAAW,EACX,cAAe,GACf,UAAW,EACX,QAAS,CACf,EACUC,EAAiB,KAAK,kBAAiB,EACvCC,EAAgB,KAAK,iBAAgB,EACvCD,GACF,KAAK,oBAAmB,EAC1B,MAAMT,EAAS,MAAM,KAAK,KAAI,EAC9B,OAAAQ,EAAS,YAAcR,EAAO,QAC9BQ,EAAS,MAAQ,KAAK,MACtBA,EAAS,QAAU,KAAK,QACxBA,EAAS,UAAY,KAAK,UAC1BA,EAAS,QAAU,KAAK,QACxBA,EAAS,UAAaR,EAAO,QAA2B,EAAjBS,EACvCD,EAAS,cAAgB,MAAM,KAAKE,CAAa,EAC1CF,CACT,CACF,CAEA,SAASG,EAAoBC,EAASC,EAAQC,EAAQlO,EAAU,CAC9D,MAAMuN,EAAQ,IAAI,MAAMS,CAAO,EAC/B,cAAO,eAAeT,EAAO,SAAU,CACrC,MAAOW,EACP,WAAY,GACZ,aAAc,GACd,SAAU,EACd,CAAG,EACD,OAAO,eAAeX,EAAO,WAAY,CACvC,MAAOvN,EACP,WAAY,GACZ,aAAc,GACd,SAAU,EACd,CAAG,EACD,OAAO,eAAeuN,EAAO,cAAe,CAAE,MAAO,CAAE,OAAAU,CAAM,EAAI,EAC1DV,CACT,CACA,MAAMY,EAAe,CACnB,YAAY5S,EAAU,GAAI,CAG1BoR,EAAA,iBACAA,EAAA,aACAA,EAAA,sBACAA,EAAA,wBAAmC,IAAI,KALrC,KAAK,QAAUpR,CACjB,CAKA,MAAM,gBAAgB6S,EAAUlR,EAAM3B,EAAS,CAC7C,IAAI2E,EACJ,KAAK,SAAWkO,EAChB,KAAK,KAAOlR,IACNgD,EAAK,KAAK,gBAAkB,KAAO,OAASA,EAAG,gBAAkBkO,IACrE,MAAM,KAAK,iBAAgB,EACtB,KAAK,iBAAiBA,CAAQ,GACjC,KAAK,iBAAiB,IACpBA,EACA,MAAM5B,EAAc,OAClB4B,EACA7S,CACZ,CACA,EAEM,KAAK,cAAgB,KAAK,iBAAiB6S,CAAQ,EAEvD,CACA,iBAAiBA,EAAU,CACzB,OAAO,KAAK,iBAAiB,IAAIA,CAAQ,CAC3C,CACA,WAAY,CACV,KAAK,SAAW,OAChB,KAAK,KAAO,MACd,CACA,kBAAkBlR,EAAM,CACtB,IAAIgD,GACHA,EAAK,KAAK,gBAAkB,MAAgBA,EAAG,8BAA8BhD,CAAI,CACpF,CACA,OAAO3B,EAAS,CACd,IAAI2E,EAAIC,EAAIkO,EAAIC,EAChB,KAAM,CACJ,SAAAF,EAAW,KAAK,SAChB,KAAAlR,EAAO,KAAK,KACZ,QAAA8Q,EACA,SAAAV,EAAW,GACX,WAAAiB,EACA,eAAAjC,EACA,MAAAiB,EACA,aAAAiB,EACA,YAAAhB,CACN,EAAQjS,EACJ,GAAI,CAAE,SAAA8R,CAAQ,EAAK9R,EACnB,GAAI,CAAC6S,EACH,MAAM,IAAI,MAAM,yCAAyC,EAC3D,GAAI,OAAOG,GAAe,SAAU,CAClC,GAAI,OAAOlB,GAAa,UAAY,CAACA,EACnC,MAAM,IAAI,MAAM,kEAAkE,EACpF,GAAI,CAEF,KADgBlN,GAAMD,EAAK,KAAK,SAAS,UAAY,KAAO,OAASC,EAAG,KAAKD,EAAImN,EAAUkB,CAAU,IAAM,GAIzGlB,EAAWtM,EAAkBsM,EAAUkB,CAAU,MAFjD,OAAMR,EAAoB,kCAAmCM,EAAK,KAAK,gBAAkB,KAAO,OAASA,EAAG,OAAQhB,EAAUkB,CAAU,CAG5I,OAASE,EAAK,CACZ,MAAAA,EAAI,QAAUD,GAAgB,sBACxBC,CACR,CACF,CACA,MAAMtQ,GAAW,CACfjB,EACA,GAAG8Q,EAAU,CAACA,CAAO,EAAI,EAC/B,EAAM,KAAK,KAAK,EACNU,GAAgB,KAAK,iBAAiBN,CAAQ,EAC9C,CAAE,OAAAF,EAAQ,SAAAlO,EAAU,IAAA1B,GAAK,KAAAmP,EAAI,EAAKiB,GAAc,MAAM,CAC1D,SAAAvQ,GACA,SAAAkP,EACA,SAAAC,EACA,MAAAC,EACA,eAAAjB,EACA,YAAAkB,CACN,CAAK,EACD,GAAI,CAACC,GACH,MAAMM,EAAoB,cAAczP,IAAO,SAAS,iBAAkBgQ,EAAK,KAAK,gBAAkB,KAAO,OAASA,EAAG,OAAQJ,GAAU,KAAO,OAASA,EAAO,OAAQlO,GAAY,KAAO,OAASA,EAAS,KAAI,CAAE,CACzN,CACA,MAAM,UAAUzE,EAAS,CACvB,GAAI,CAACA,EAAQ,YACX,MAAM,IAAI,MAAM,0BAA0B,EAC5C,KAAM,CACJ,SAAA6S,EAAW,KAAK,SAChB,YAAAZ,CACN,EAAQjS,EACJ,GAAIiS,EAAY,SAAW,KAAM,CAC/B,GAAI,CAACY,EACH,MAAM,IAAI,MAAM,yCAAyC,EAC3D,MAAMM,EAAgB,KAAK,iBAAiBN,CAAQ,EACpD7S,EAAQ,WAAaA,EAAQ,SAAW6S,GACxCZ,EAAY,KAAO,MAAMkB,EAAc,YAAY,eAAeN,EAAUZ,EAAY,IAAI,EAC5FA,EAAY,QAAU,MAAMkB,EAAc,YAAY,iBAAiBlB,EAAY,IAAI,GAAK,MAC9F,CACA,OAAO,KAAK,OAAOjS,CAAO,CAC5B,CACA,MAAM,kBAAmB,CACvB,GAAI,CAAC,KAAK,cACR,OAAO,KACT,MAAMoT,EAAS,MAAM,KAAK,cAAc,KAAI,EAC5C,YAAK,cAAgB,OACdA,CACT,CACA,OAAQ,CACN,KAAK,iBAAiB,MAAK,CAC7B,CACF","names":["getDefaultExportFromCjs","x","naturalCompare$2","naturalCompare","a","b","i","codeA","codeB","posA","posB","alphabet","getCode","str","pos","code","naturalCompareExports","naturalCompare$1","notNullish","v","isPrimitive","value","isObject","item","getCallLastIndex","charIndex","inString","startedBracers","endedBracers","beforeChar","char","getPromiseValue","getPromiseDetails","kPending","kRejected","options","state","innerValue","nodeInspect","nodeUtil","lineSplitRE","positionToOffset","source","lineNumber","columnNumber","lines","nl","start","offsetToLineNumber","offset","counted","line","lineLength","LineTerminatorSequence","reservedWords","serialize$1","val","config","indentation","depth","refs","printer","name","nameString","callsString","indentationNext","test","plugin","DOMCollection","DOMElement","Immutable","ReactElement","ReactTestComponent","AsymmetricMatcher","plugins","PLUGINS","addSerializer","getSerializers","testNameToKey","testName","count","keyToTestName","key","getSnapshotData","content","update","data","snapshotContents","dirty","addExtraLineBreaks","string","removeExtraLineBreaks","escapeRegex","printFunctionName","serialize","indent","formatOverrides","normalizeNewlines","format","escapeBacktickString","printBacktickString","saveSnapshotFile","environment","snapshotData","snapshotPath","snapshots","oldContent","prepareExpected","expected","findStartIndent","_a","_b","matchObject","objectIndent","matchText","startIndent","expectedTrimmed","deepMergeArray","target","mergedOutput","sourceElement","index","targetElement","deepMergeSnapshot","comma","chars","intToChar","charToInt","c","decode","mappings","decoded","semi","indexOf","sorted","lastCol","seg","decodeInteger","col","hasMoreVlq","sort","idx","j","shift","integer","shouldNegate","length","sortComparator$1","schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","isSchemeRelativeUrl","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","parseUrl","url","stripPathFilename","mergePaths","base","normalizePath","type","rel","pieces","pointer","positive","addTrailingSlash","piece","resolve$1","inputType","baseUrl","baseType","queryHash","resolve","stripFilename","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","maybeSort","owned","unsortedIndex","nextUnsortedSegmentLine","sortSegments","isSorted","sortComparator","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","memoizedBinarySearch","lastKey","lastNeedle","lastIndex","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","decodedMappings","originalPositionFor","TraceMap","map","mapUrl","isString","parsed","version","file","names","sourceRoot","sources","sourcesContent","from","s","column","bias","OMapping","segments","traceSegmentInternal","segment","resolvedSources","memo","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stackIgnorePatterns","extractLocation","urlLike","parts","parseSingleFFOrSafariStack","raw","functionNameRegex","matches","functionName","parseSingleV8Stack","sanitizedLine","location","method","resolve$2","parseStacktrace","stack","ignoreStackEntries","stacks","parseV8Stacktrace","parseFFOrSafariStackTrace","stack2","p","traceMap","parseErrorStacktrace","e","stackStr","stackFrames","f","saveInlineSnapshots","MagicString","__vitePreload","__vite_default__","files","snaps","snap","replaceInlineSnap","transformed","startObjectRegex","replaceObjectSnap","newSnap","_code","startMatch","callEnd","shapeStart","shapeEnd","getObjectShapeEndIndex","prepareSnapString","startBraces","endBraces","indentNext","isOneline","quote","startRegex","codeStartingAtIndex","firstKeywordMatch","startIndex","snapString","endMatch","endIndex","INDENTATION_REGEX","stripSnapshotIndentation","inlineSnapshot","saveRawSnapshots","SnapshotState","testFilePath","snapshotContent","__publicField","uncheckedKey","promiseIndex","stackIndex","receivedSerialized","hasExternalSnapshots","hasInlineSnapshots","hasRawSnapshots","isEmpty","status","received","isInline","error","rawSnapshot","pass","hasSnapshot","snapshotIsPersisted","snapshot","uncheckedCount","uncheckedKeys","createMismatchError","message","expand","actual","SnapshotClient","filepath","_c","_d","properties","errorMessage","err","snapshotState","result"],"ignoreList":[0],"sources":["../../../node_modules/.pnpm/@vitest+snapshot@1.6.1/node_modules/@vitest/snapshot/dist/index.js"],"sourcesContent":["import { plugins, format } from 'pretty-format';\nimport { resolve as resolve$2 } from 'pathe';\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar naturalCompare$2 = {exports: {}};\n\n/*\n * @version    1.4.0\n * @date       2015-10-26\n * @stability  3 - Stable\n * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)\n * @license    MIT License\n */\n\n\nvar naturalCompare = function(a, b) {\n\tvar i, codeA\n\t, codeB = 1\n\t, posA = 0\n\t, posB = 0\n\t, alphabet = String.alphabet;\n\n\tfunction getCode(str, pos, code) {\n\t\tif (code) {\n\t\t\tfor (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;\n\t\t\treturn +str.slice(pos - 1, i)\n\t\t}\n\t\tcode = alphabet && alphabet.indexOf(str.charAt(pos));\n\t\treturn code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code\n\t\t\t: code < 46 ? 65               // -\n\t\t\t: code < 48 ? code - 1\n\t\t\t: code < 58 ? code + 18        // 0-9\n\t\t\t: code < 65 ? code - 11\n\t\t\t: code < 91 ? code + 11        // A-Z\n\t\t\t: code < 97 ? code - 37\n\t\t\t: code < 123 ? code + 5        // a-z\n\t\t\t: code - 63\n\t}\n\n\n\tif ((a+=\"\") != (b+=\"\")) for (;codeB;) {\n\t\tcodeA = getCode(a, posA++);\n\t\tcodeB = getCode(b, posB++);\n\n\t\tif (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {\n\t\t\tcodeA = getCode(a, posA, posA);\n\t\t\tcodeB = getCode(b, posB, posA = i);\n\t\t\tposB = i;\n\t\t}\n\n\t\tif (codeA != codeB) return (codeA < codeB) ? -1 : 1\n\t}\n\treturn 0\n};\n\ntry {\n\tnaturalCompare$2.exports = naturalCompare;\n} catch (e) {\n\tString.naturalCompare = naturalCompare;\n}\n\nvar naturalCompareExports = naturalCompare$2.exports;\nvar naturalCompare$1 = /*@__PURE__*/getDefaultExportFromCjs(naturalCompareExports);\n\nfunction notNullish(v) {\n  return v != null;\n}\nfunction isPrimitive(value) {\n  return value === null || typeof value !== \"function\" && typeof value !== \"object\";\n}\nfunction isObject(item) {\n  return item != null && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction getCallLastIndex(code) {\n  let charIndex = -1;\n  let inString = null;\n  let startedBracers = 0;\n  let endedBracers = 0;\n  let beforeChar = null;\n  while (charIndex <= code.length) {\n    beforeChar = code[charIndex];\n    charIndex++;\n    const char = code[charIndex];\n    const isCharString = char === '\"' || char === \"'\" || char === \"`\";\n    if (isCharString && beforeChar !== \"\\\\\") {\n      if (inString === char)\n        inString = null;\n      else if (!inString)\n        inString = char;\n    }\n    if (!inString) {\n      if (char === \"(\")\n        startedBracers++;\n      if (char === \")\")\n        endedBracers++;\n    }\n    if (startedBracers && endedBracers && startedBracers === endedBracers)\n      return charIndex;\n  }\n  return null;\n}\n\nlet getPromiseValue = () => 'Promise{â€¦}';\ntry {\n  const { getPromiseDetails, kPending, kRejected } = process.binding('util');\n  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {\n    getPromiseValue = (value, options) => {\n      const [state, innerValue] = getPromiseDetails(value);\n      if (state === kPending) {\n        return 'Promise{<pending>}'\n      }\n      return `Promise${state === kRejected ? '!' : ''}{${options.inspect(innerValue, options)}}`\n    };\n  }\n} catch (notNode) {\n  /* ignore */\n}\n\n/* !\n * loupe\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nlet nodeInspect = false;\ntry {\n  // eslint-disable-next-line global-require\n  const nodeUtil = require('util');\n  nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;\n} catch (noNodeInspect) {\n  nodeInspect = false;\n}\n\nconst lineSplitRE = /\\r?\\n/;\nfunction positionToOffset(source, lineNumber, columnNumber) {\n  const lines = source.split(lineSplitRE);\n  const nl = /\\r\\n/.test(source) ? 2 : 1;\n  let start = 0;\n  if (lineNumber > lines.length)\n    return source.length;\n  for (let i = 0; i < lineNumber - 1; i++)\n    start += lines[i].length + nl;\n  return start + columnNumber;\n}\nfunction offsetToLineNumber(source, offset) {\n  if (offset > source.length) {\n    throw new Error(\n      `offset is longer than source length! offset ${offset} > length ${source.length}`\n    );\n  }\n  const lines = source.split(lineSplitRE);\n  const nl = /\\r\\n/.test(source) ? 2 : 1;\n  let counted = 0;\n  let line = 0;\n  for (; line < lines.length; line++) {\n    const lineLength = lines[line].length + nl;\n    if (counted + lineLength >= offset)\n      break;\n    counted += lineLength;\n  }\n  return line + 1;\n}\n\n// Copyright 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023 Simon Lydell\n// License: MIT.\nvar LineTerminatorSequence;\nLineTerminatorSequence = /\\r?\\n|[\\r\\u2028\\u2029]/y;\nRegExp(LineTerminatorSequence.source);\n\n// src/index.ts\nvar reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\"\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\"\n  ]\n}; new Set(reservedWords.keyword); new Set(reservedWords.strict);\n\nconst serialize$1 = (val, config, indentation, depth, refs, printer) => {\n  const name = val.getMockName();\n  const nameString = name === \"vi.fn()\" ? \"\" : ` ${name}`;\n  let callsString = \"\";\n  if (val.mock.calls.length !== 0) {\n    const indentationNext = indentation + config.indent;\n    callsString = ` {${config.spacingOuter}${indentationNext}\"calls\": ${printer(val.mock.calls, config, indentationNext, depth, refs)}${config.min ? \", \" : \",\"}${config.spacingOuter}${indentationNext}\"results\": ${printer(val.mock.results, config, indentationNext, depth, refs)}${config.min ? \"\" : \",\"}${config.spacingOuter}${indentation}}`;\n  }\n  return `[MockFunction${nameString}]${callsString}`;\n};\nconst test = (val) => val && !!val._isMockFunction;\nconst plugin = { serialize: serialize$1, test };\n\nconst {\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent,\n  AsymmetricMatcher\n} = plugins;\nlet PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher,\n  plugin\n];\nfunction addSerializer(plugin) {\n  PLUGINS = [plugin].concat(PLUGINS);\n}\nfunction getSerializers() {\n  return PLUGINS;\n}\n\nfunction testNameToKey(testName, count) {\n  return `${testName} ${count}`;\n}\nfunction keyToTestName(key) {\n  if (!/ \\d+$/.test(key))\n    throw new Error(\"Snapshot keys must end with a number.\");\n  return key.replace(/ \\d+$/, \"\");\n}\nfunction getSnapshotData(content, options) {\n  const update = options.updateSnapshot;\n  const data = /* @__PURE__ */ Object.create(null);\n  let snapshotContents = \"\";\n  let dirty = false;\n  if (content != null) {\n    try {\n      snapshotContents = content;\n      const populate = new Function(\"exports\", snapshotContents);\n      populate(data);\n    } catch {\n    }\n  }\n  const isInvalid = snapshotContents;\n  if ((update === \"all\" || update === \"new\") && isInvalid)\n    dirty = true;\n  return { data, dirty };\n}\nfunction addExtraLineBreaks(string) {\n  return string.includes(\"\\n\") ? `\n${string}\n` : string;\n}\nfunction removeExtraLineBreaks(string) {\n  return string.length > 2 && string.startsWith(\"\\n\") && string.endsWith(\"\\n\") ? string.slice(1, -1) : string;\n}\nconst escapeRegex = true;\nconst printFunctionName = false;\nfunction serialize(val, indent = 2, formatOverrides = {}) {\n  return normalizeNewlines(\n    format(val, {\n      escapeRegex,\n      indent,\n      plugins: getSerializers(),\n      printFunctionName,\n      ...formatOverrides\n    })\n  );\n}\nfunction escapeBacktickString(str) {\n  return str.replace(/`|\\\\|\\${/g, \"\\\\$&\");\n}\nfunction printBacktickString(str) {\n  return `\\`${escapeBacktickString(str)}\\``;\n}\nfunction normalizeNewlines(string) {\n  return string.replace(/\\r\\n|\\r/g, \"\\n\");\n}\nasync function saveSnapshotFile(environment, snapshotData, snapshotPath) {\n  const snapshots = Object.keys(snapshotData).sort(naturalCompare$1).map(\n    (key) => `exports[${printBacktickString(key)}] = ${printBacktickString(normalizeNewlines(snapshotData[key]))};`\n  );\n  const content = `${environment.getHeader()}\n\n${snapshots.join(\"\\n\\n\")}\n`;\n  const oldContent = await environment.readSnapshotFile(snapshotPath);\n  const skipWriting = oldContent != null && oldContent === content;\n  if (skipWriting)\n    return;\n  await environment.saveSnapshotFile(\n    snapshotPath,\n    content\n  );\n}\nfunction prepareExpected(expected) {\n  function findStartIndent() {\n    var _a, _b;\n    const matchObject = /^( +)}\\s+$/m.exec(expected || \"\");\n    const objectIndent = (_a = matchObject == null ? void 0 : matchObject[1]) == null ? void 0 : _a.length;\n    if (objectIndent)\n      return objectIndent;\n    const matchText = /^\\n( +)\"/.exec(expected || \"\");\n    return ((_b = matchText == null ? void 0 : matchText[1]) == null ? void 0 : _b.length) || 0;\n  }\n  const startIndent = findStartIndent();\n  let expectedTrimmed = expected == null ? void 0 : expected.trim();\n  if (startIndent) {\n    expectedTrimmed = expectedTrimmed == null ? void 0 : expectedTrimmed.replace(new RegExp(`^${\" \".repeat(startIndent)}`, \"gm\"), \"\").replace(/ +}$/, \"}\");\n  }\n  return expectedTrimmed;\n}\nfunction deepMergeArray(target = [], source = []) {\n  const mergedOutput = Array.from(target);\n  source.forEach((sourceElement, index) => {\n    const targetElement = mergedOutput[index];\n    if (Array.isArray(target[index])) {\n      mergedOutput[index] = deepMergeArray(target[index], sourceElement);\n    } else if (isObject(targetElement)) {\n      mergedOutput[index] = deepMergeSnapshot(target[index], sourceElement);\n    } else {\n      mergedOutput[index] = sourceElement;\n    }\n  });\n  return mergedOutput;\n}\nfunction deepMergeSnapshot(target, source) {\n  if (isObject(target) && isObject(source)) {\n    const mergedOutput = { ...target };\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key]) && !source[key].$$typeof) {\n        if (!(key in target))\n          Object.assign(mergedOutput, { [key]: source[key] });\n        else\n          mergedOutput[key] = deepMergeSnapshot(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        mergedOutput[key] = deepMergeArray(target[key], source[key]);\n      } else {\n        Object.assign(mergedOutput, { [key]: source[key] });\n      }\n    });\n    return mergedOutput;\n  } else if (Array.isArray(target) && Array.isArray(source)) {\n    return deepMergeArray(target, source);\n  }\n  return target;\n}\n\nconst comma = ','.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator$1);\n}\nfunction sortComparator$1(a, b) {\n    return a[0] - b[0];\n}\n\n// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: UrlType.Absolute,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = UrlType.SchemeRelative;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = UrlType.AbsolutePath;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? UrlType.Query\n            : input.startsWith('#')\n                ? UrlType.Hash\n                : UrlType.RelativePath\n        : UrlType.Empty;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve$1(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case UrlType.Empty:\n                url.hash = baseUrl.hash;\n            // fall through\n            case UrlType.Hash:\n                url.query = baseUrl.query;\n            // fall through\n            case UrlType.Query:\n            case UrlType.RelativePath:\n                mergePaths(url, baseUrl);\n            // fall through\n            case UrlType.AbsolutePath:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case UrlType.SchemeRelative:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case UrlType.Hash:\n        case UrlType.Query:\n            return queryHash;\n        case UrlType.RelativePath: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case UrlType.AbsolutePath:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolve$1(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n(() => {\n    decodedMappings = (map) => {\n        return (map._decoded || (map._decoded = decode(map._encoded)));\n    };\n    originalPositionFor = (map, { line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1)\n            return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1)\n            return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n})();\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\n\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nconst stackIgnorePatterns = [\n  \"node:internal\",\n  /\\/packages\\/\\w+\\/dist\\//,\n  /\\/@vitest\\/\\w+\\/dist\\//,\n  \"/vitest/dist/\",\n  \"/vitest/src/\",\n  \"/vite-node/dist/\",\n  \"/vite-node/src/\",\n  \"/node_modules/chai/\",\n  \"/node_modules/tinypool/\",\n  \"/node_modules/tinyspy/\",\n  \"/deps/chai.js\",\n  /__vitest_browser__/\n];\nfunction extractLocation(urlLike) {\n  if (!urlLike.includes(\":\"))\n    return [urlLike];\n  const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n  const parts = regExp.exec(urlLike.replace(/^\\(|\\)$/g, \"\"));\n  if (!parts)\n    return [urlLike];\n  let url = parts[1];\n  if (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\n    const urlObj = new URL(url);\n    url = urlObj.pathname;\n  }\n  if (url.startsWith(\"/@fs/\")) {\n    url = url.slice(typeof process !== \"undefined\" && process.platform === \"win32\" ? 5 : 4);\n  }\n  return [url, parts[2] || void 0, parts[3] || void 0];\n}\nfunction parseSingleFFOrSafariStack(raw) {\n  let line = raw.trim();\n  if (SAFARI_NATIVE_CODE_REGEXP.test(line))\n    return null;\n  if (line.includes(\" > eval\"))\n    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n  if (!line.includes(\"@\") && !line.includes(\":\"))\n    return null;\n  const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n  const matches = line.match(functionNameRegex);\n  const functionName = matches && matches[1] ? matches[1] : void 0;\n  const [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, \"\"));\n  if (!url || !lineNumber || !columnNumber)\n    return null;\n  return {\n    file: url,\n    method: functionName || \"\",\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction parseSingleV8Stack(raw) {\n  let line = raw.trim();\n  if (!CHROME_IE_STACK_REGEXP.test(line))\n    return null;\n  if (line.includes(\"(eval \"))\n    line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n  let sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n  const location = sanitizedLine.match(/ (\\(.+\\)$)/);\n  sanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n  const [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);\n  let method = location && sanitizedLine || \"\";\n  let file = url && [\"eval\", \"<anonymous>\"].includes(url) ? void 0 : url;\n  if (!file || !lineNumber || !columnNumber)\n    return null;\n  if (method.startsWith(\"async \"))\n    method = method.slice(6);\n  if (file.startsWith(\"file://\"))\n    file = file.slice(7);\n  file = resolve$2(file);\n  if (method)\n    method = method.replace(/__vite_ssr_import_\\d+__\\./g, \"\");\n  return {\n    method,\n    file,\n    line: Number.parseInt(lineNumber),\n    column: Number.parseInt(columnNumber)\n  };\n}\nfunction parseStacktrace(stack, options = {}) {\n  const { ignoreStackEntries = stackIgnorePatterns } = options;\n  let stacks = !CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack);\n  if (ignoreStackEntries.length)\n    stacks = stacks.filter((stack2) => !ignoreStackEntries.some((p) => stack2.file.match(p)));\n  return stacks.map((stack2) => {\n    var _a;\n    const map = (_a = options.getSourceMap) == null ? void 0 : _a.call(options, stack2.file);\n    if (!map || typeof map !== \"object\" || !map.version)\n      return stack2;\n    const traceMap = new TraceMap(map);\n    const { line, column } = originalPositionFor(traceMap, stack2);\n    if (line != null && column != null)\n      return { ...stack2, line, column };\n    return stack2;\n  });\n}\nfunction parseFFOrSafariStackTrace(stack) {\n  return stack.split(\"\\n\").map((line) => parseSingleFFOrSafariStack(line)).filter(notNullish);\n}\nfunction parseV8Stacktrace(stack) {\n  return stack.split(\"\\n\").map((line) => parseSingleV8Stack(line)).filter(notNullish);\n}\nfunction parseErrorStacktrace(e, options = {}) {\n  if (!e || isPrimitive(e))\n    return [];\n  if (e.stacks)\n    return e.stacks;\n  const stackStr = e.stack || e.stackStr || \"\";\n  let stackFrames = parseStacktrace(stackStr, options);\n  if (options.frameFilter)\n    stackFrames = stackFrames.filter((f) => options.frameFilter(e, f) !== false);\n  e.stacks = stackFrames;\n  return stackFrames;\n}\n\nasync function saveInlineSnapshots(environment, snapshots) {\n  const MagicString = (await import('magic-string')).default;\n  const files = new Set(snapshots.map((i) => i.file));\n  await Promise.all(Array.from(files).map(async (file) => {\n    const snaps = snapshots.filter((i) => i.file === file);\n    const code = await environment.readSnapshotFile(file);\n    const s = new MagicString(code);\n    for (const snap of snaps) {\n      const index = positionToOffset(code, snap.line, snap.column);\n      replaceInlineSnap(code, s, index, snap.snapshot);\n    }\n    const transformed = s.toString();\n    if (transformed !== code)\n      await environment.saveSnapshotFile(file, transformed);\n  }));\n}\nconst startObjectRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\S\\s]*\\*\\/\\s*|\\/\\/.*\\s+)*\\s*({)/m;\nfunction replaceObjectSnap(code, s, index, newSnap) {\n  let _code = code.slice(index);\n  const startMatch = startObjectRegex.exec(_code);\n  if (!startMatch)\n    return false;\n  _code = _code.slice(startMatch.index);\n  let callEnd = getCallLastIndex(_code);\n  if (callEnd === null)\n    return false;\n  callEnd += index + startMatch.index;\n  const shapeStart = index + startMatch.index + startMatch[0].length;\n  const shapeEnd = getObjectShapeEndIndex(code, shapeStart);\n  const snap = `, ${prepareSnapString(newSnap, code, index)}`;\n  if (shapeEnd === callEnd) {\n    s.appendLeft(callEnd, snap);\n  } else {\n    s.overwrite(shapeEnd, callEnd, snap);\n  }\n  return true;\n}\nfunction getObjectShapeEndIndex(code, index) {\n  let startBraces = 1;\n  let endBraces = 0;\n  while (startBraces !== endBraces && index < code.length) {\n    const s = code[index++];\n    if (s === \"{\")\n      startBraces++;\n    else if (s === \"}\")\n      endBraces++;\n  }\n  return index;\n}\nfunction prepareSnapString(snap, source, index) {\n  const lineNumber = offsetToLineNumber(source, index);\n  const line = source.split(lineSplitRE)[lineNumber - 1];\n  const indent = line.match(/^\\s*/)[0] || \"\";\n  const indentNext = indent.includes(\"\t\") ? `${indent}\t` : `${indent}  `;\n  const lines = snap.trim().replace(/\\\\/g, \"\\\\\\\\\").split(/\\n/g);\n  const isOneline = lines.length <= 1;\n  const quote = \"`\";\n  if (isOneline)\n    return `${quote}${lines.join(\"\\n\").replace(/`/g, \"\\\\`\").replace(/\\${/g, \"\\\\${\")}${quote}`;\n  return `${quote}\n${lines.map((i) => i ? indentNext + i : \"\").join(\"\\n\").replace(/`/g, \"\\\\`\").replace(/\\${/g, \"\\\\${\")}\n${indent}${quote}`;\n}\nconst startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\\s*\\(\\s*(?:\\/\\*[\\S\\s]*\\*\\/\\s*|\\/\\/.*\\s+)*\\s*[\\w_$]*(['\"`\\)])/m;\nfunction replaceInlineSnap(code, s, index, newSnap) {\n  const codeStartingAtIndex = code.slice(index);\n  const startMatch = startRegex.exec(codeStartingAtIndex);\n  const firstKeywordMatch = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);\n  if (!startMatch || startMatch.index !== (firstKeywordMatch == null ? void 0 : firstKeywordMatch.index))\n    return replaceObjectSnap(code, s, index, newSnap);\n  const quote = startMatch[1];\n  const startIndex = index + startMatch.index + startMatch[0].length;\n  const snapString = prepareSnapString(newSnap, code, index);\n  if (quote === \")\") {\n    s.appendRight(startIndex - 1, snapString);\n    return true;\n  }\n  const quoteEndRE = new RegExp(`(?:^|[^\\\\\\\\])${quote}`);\n  const endMatch = quoteEndRE.exec(code.slice(startIndex));\n  if (!endMatch)\n    return false;\n  const endIndex = startIndex + endMatch.index + endMatch[0].length;\n  s.overwrite(startIndex - 1, endIndex, snapString);\n  return true;\n}\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m;\nfunction stripSnapshotIndentation(inlineSnapshot) {\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n  if (!match || !match[1]) {\n    return inlineSnapshot;\n  }\n  const indentation = match[1];\n  const lines = inlineSnapshot.split(/\\n/g);\n  if (lines.length <= 2) {\n    return inlineSnapshot;\n  }\n  if (lines[0].trim() !== \"\" || lines[lines.length - 1].trim() !== \"\") {\n    return inlineSnapshot;\n  }\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== \"\") {\n      if (lines[i].indexOf(indentation) !== 0) {\n        return inlineSnapshot;\n      }\n      lines[i] = lines[i].substring(indentation.length);\n    }\n  }\n  lines[lines.length - 1] = \"\";\n  inlineSnapshot = lines.join(\"\\n\");\n  return inlineSnapshot;\n}\n\nasync function saveRawSnapshots(environment, snapshots) {\n  await Promise.all(snapshots.map(async (snap) => {\n    if (!snap.readonly)\n      await environment.saveSnapshotFile(snap.file, snap.snapshot);\n  }));\n}\n\nclass SnapshotState {\n  constructor(testFilePath, snapshotPath, snapshotContent, options) {\n    this.testFilePath = testFilePath;\n    this.snapshotPath = snapshotPath;\n    const { data, dirty } = getSnapshotData(\n      snapshotContent,\n      options\n    );\n    this._fileExists = snapshotContent != null;\n    this._initialData = data;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._inlineSnapshots = [];\n    this._rawSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = /* @__PURE__ */ new Map();\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n    this._snapshotFormat = {\n      printBasicPrototype: false,\n      escapeString: false,\n      ...options.snapshotFormat\n    };\n    this._environment = options.snapshotEnvironment;\n  }\n  _counters;\n  _dirty;\n  _updateSnapshot;\n  _snapshotData;\n  _initialData;\n  _inlineSnapshots;\n  _rawSnapshots;\n  _uncheckedKeys;\n  _snapshotFormat;\n  _environment;\n  _fileExists;\n  added;\n  expand;\n  matched;\n  unmatched;\n  updated;\n  static async create(testFilePath, options) {\n    const snapshotPath = await options.snapshotEnvironment.resolvePath(testFilePath);\n    const content = await options.snapshotEnvironment.readSnapshotFile(snapshotPath);\n    return new SnapshotState(testFilePath, snapshotPath, content, options);\n  }\n  get environment() {\n    return this._environment;\n  }\n  markSnapshotsAsCheckedForTest(testName) {\n    this._uncheckedKeys.forEach((uncheckedKey) => {\n      if (keyToTestName(uncheckedKey) === testName)\n        this._uncheckedKeys.delete(uncheckedKey);\n    });\n  }\n  _inferInlineSnapshotStack(stacks) {\n    const promiseIndex = stacks.findIndex((i) => i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));\n    if (promiseIndex !== -1)\n      return stacks[promiseIndex + 3];\n    const stackIndex = stacks.findIndex((i) => i.method.includes(\"__INLINE_SNAPSHOT__\"));\n    return stackIndex !== -1 ? stacks[stackIndex + 2] : null;\n  }\n  _addSnapshot(key, receivedSerialized, options) {\n    this._dirty = true;\n    if (options.isInline) {\n      const stacks = parseErrorStacktrace(options.error || new Error(\"snapshot\"), { ignoreStackEntries: [] });\n      const stack = this._inferInlineSnapshotStack(stacks);\n      if (!stack) {\n        throw new Error(\n          `@vitest/snapshot: Couldn't infer stack frame for inline snapshot.\n${JSON.stringify(stacks)}`\n        );\n      }\n      stack.column--;\n      this._inlineSnapshots.push({\n        snapshot: receivedSerialized,\n        ...stack\n      });\n    } else if (options.rawSnapshot) {\n      this._rawSnapshots.push({\n        ...options.rawSnapshot,\n        snapshot: receivedSerialized\n      });\n    } else {\n      this._snapshotData[key] = receivedSerialized;\n    }\n  }\n  clear() {\n    this._snapshotData = this._initialData;\n    this._counters = /* @__PURE__ */ new Map();\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this.updated = 0;\n    this._dirty = false;\n  }\n  async save() {\n    const hasExternalSnapshots = Object.keys(this._snapshotData).length;\n    const hasInlineSnapshots = this._inlineSnapshots.length;\n    const hasRawSnapshots = this._rawSnapshots.length;\n    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots && !hasRawSnapshots;\n    const status = {\n      deleted: false,\n      saved: false\n    };\n    if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {\n      if (hasExternalSnapshots) {\n        await saveSnapshotFile(this._environment, this._snapshotData, this.snapshotPath);\n        this._fileExists = true;\n      }\n      if (hasInlineSnapshots)\n        await saveInlineSnapshots(this._environment, this._inlineSnapshots);\n      if (hasRawSnapshots)\n        await saveRawSnapshots(this._environment, this._rawSnapshots);\n      status.saved = true;\n    } else if (!hasExternalSnapshots && this._fileExists) {\n      if (this._updateSnapshot === \"all\") {\n        await this._environment.removeSnapshotFile(this.snapshotPath);\n        this._fileExists = false;\n      }\n      status.deleted = true;\n    }\n    return status;\n  }\n  getUncheckedCount() {\n    return this._uncheckedKeys.size || 0;\n  }\n  getUncheckedKeys() {\n    return Array.from(this._uncheckedKeys);\n  }\n  removeUncheckedKeys() {\n    if (this._updateSnapshot === \"all\" && this._uncheckedKeys.size) {\n      this._dirty = true;\n      this._uncheckedKeys.forEach((key) => delete this._snapshotData[key]);\n      this._uncheckedKeys.clear();\n    }\n  }\n  match({\n    testName,\n    received,\n    key,\n    inlineSnapshot,\n    isInline,\n    error,\n    rawSnapshot\n  }) {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n    const count = Number(this._counters.get(testName));\n    if (!key)\n      key = testNameToKey(testName, count);\n    if (!(isInline && this._snapshotData[key] !== void 0))\n      this._uncheckedKeys.delete(key);\n    let receivedSerialized = rawSnapshot && typeof received === \"string\" ? received : serialize(received, void 0, this._snapshotFormat);\n    if (!rawSnapshot)\n      receivedSerialized = addExtraLineBreaks(receivedSerialized);\n    if (rawSnapshot) {\n      if (rawSnapshot.content && rawSnapshot.content.match(/\\r\\n/) && !receivedSerialized.match(/\\r\\n/))\n        rawSnapshot.content = normalizeNewlines(rawSnapshot.content);\n    }\n    const expected = isInline ? inlineSnapshot : rawSnapshot ? rawSnapshot.content : this._snapshotData[key];\n    const expectedTrimmed = prepareExpected(expected);\n    const pass = expectedTrimmed === prepareExpected(receivedSerialized);\n    const hasSnapshot = expected !== void 0;\n    const snapshotIsPersisted = isInline || this._fileExists || rawSnapshot && rawSnapshot.content != null;\n    if (pass && !isInline && !rawSnapshot) {\n      this._snapshotData[key] = receivedSerialized;\n    }\n    if (hasSnapshot && this._updateSnapshot === \"all\" || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === \"new\" || this._updateSnapshot === \"all\")) {\n      if (this._updateSnapshot === \"all\") {\n        if (!pass) {\n          if (hasSnapshot)\n            this.updated++;\n          else\n            this.added++;\n          this._addSnapshot(key, receivedSerialized, { error, isInline, rawSnapshot });\n        } else {\n          this.matched++;\n        }\n      } else {\n        this._addSnapshot(key, receivedSerialized, { error, isInline, rawSnapshot });\n        this.added++;\n      }\n      return {\n        actual: \"\",\n        count,\n        expected: \"\",\n        key,\n        pass: true\n      };\n    } else {\n      if (!pass) {\n        this.unmatched++;\n        return {\n          actual: removeExtraLineBreaks(receivedSerialized),\n          count,\n          expected: expectedTrimmed !== void 0 ? removeExtraLineBreaks(expectedTrimmed) : void 0,\n          key,\n          pass: false\n        };\n      } else {\n        this.matched++;\n        return {\n          actual: \"\",\n          count,\n          expected: \"\",\n          key,\n          pass: true\n        };\n      }\n    }\n  }\n  async pack() {\n    const snapshot = {\n      filepath: this.testFilePath,\n      added: 0,\n      fileDeleted: false,\n      matched: 0,\n      unchecked: 0,\n      uncheckedKeys: [],\n      unmatched: 0,\n      updated: 0\n    };\n    const uncheckedCount = this.getUncheckedCount();\n    const uncheckedKeys = this.getUncheckedKeys();\n    if (uncheckedCount)\n      this.removeUncheckedKeys();\n    const status = await this.save();\n    snapshot.fileDeleted = status.deleted;\n    snapshot.added = this.added;\n    snapshot.matched = this.matched;\n    snapshot.unmatched = this.unmatched;\n    snapshot.updated = this.updated;\n    snapshot.unchecked = !status.deleted ? uncheckedCount : 0;\n    snapshot.uncheckedKeys = Array.from(uncheckedKeys);\n    return snapshot;\n  }\n}\n\nfunction createMismatchError(message, expand, actual, expected) {\n  const error = new Error(message);\n  Object.defineProperty(error, \"actual\", {\n    value: actual,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  });\n  Object.defineProperty(error, \"expected\", {\n    value: expected,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  });\n  Object.defineProperty(error, \"diffOptions\", { value: { expand } });\n  return error;\n}\nclass SnapshotClient {\n  constructor(options = {}) {\n    this.options = options;\n  }\n  filepath;\n  name;\n  snapshotState;\n  snapshotStateMap = /* @__PURE__ */ new Map();\n  async startCurrentRun(filepath, name, options) {\n    var _a;\n    this.filepath = filepath;\n    this.name = name;\n    if (((_a = this.snapshotState) == null ? void 0 : _a.testFilePath) !== filepath) {\n      await this.finishCurrentRun();\n      if (!this.getSnapshotState(filepath)) {\n        this.snapshotStateMap.set(\n          filepath,\n          await SnapshotState.create(\n            filepath,\n            options\n          )\n        );\n      }\n      this.snapshotState = this.getSnapshotState(filepath);\n    }\n  }\n  getSnapshotState(filepath) {\n    return this.snapshotStateMap.get(filepath);\n  }\n  clearTest() {\n    this.filepath = void 0;\n    this.name = void 0;\n  }\n  skipTestSnapshots(name) {\n    var _a;\n    (_a = this.snapshotState) == null ? void 0 : _a.markSnapshotsAsCheckedForTest(name);\n  }\n  assert(options) {\n    var _a, _b, _c, _d;\n    const {\n      filepath = this.filepath,\n      name = this.name,\n      message,\n      isInline = false,\n      properties,\n      inlineSnapshot,\n      error,\n      errorMessage,\n      rawSnapshot\n    } = options;\n    let { received } = options;\n    if (!filepath)\n      throw new Error(\"Snapshot cannot be used outside of test\");\n    if (typeof properties === \"object\") {\n      if (typeof received !== \"object\" || !received)\n        throw new Error(\"Received value must be an object when the matcher has properties\");\n      try {\n        const pass2 = ((_b = (_a = this.options).isEqual) == null ? void 0 : _b.call(_a, received, properties)) ?? false;\n        if (!pass2)\n          throw createMismatchError(\"Snapshot properties mismatched\", (_c = this.snapshotState) == null ? void 0 : _c.expand, received, properties);\n        else\n          received = deepMergeSnapshot(received, properties);\n      } catch (err) {\n        err.message = errorMessage || \"Snapshot mismatched\";\n        throw err;\n      }\n    }\n    const testName = [\n      name,\n      ...message ? [message] : []\n    ].join(\" > \");\n    const snapshotState = this.getSnapshotState(filepath);\n    const { actual, expected, key, pass } = snapshotState.match({\n      testName,\n      received,\n      isInline,\n      error,\n      inlineSnapshot,\n      rawSnapshot\n    });\n    if (!pass)\n      throw createMismatchError(`Snapshot \\`${key || \"unknown\"}\\` mismatched`, (_d = this.snapshotState) == null ? void 0 : _d.expand, actual == null ? void 0 : actual.trim(), expected == null ? void 0 : expected.trim());\n  }\n  async assertRaw(options) {\n    if (!options.rawSnapshot)\n      throw new Error(\"Raw snapshot is required\");\n    const {\n      filepath = this.filepath,\n      rawSnapshot\n    } = options;\n    if (rawSnapshot.content == null) {\n      if (!filepath)\n        throw new Error(\"Snapshot cannot be used outside of test\");\n      const snapshotState = this.getSnapshotState(filepath);\n      options.filepath || (options.filepath = filepath);\n      rawSnapshot.file = await snapshotState.environment.resolveRawPath(filepath, rawSnapshot.file);\n      rawSnapshot.content = await snapshotState.environment.readSnapshotFile(rawSnapshot.file) || void 0;\n    }\n    return this.assert(options);\n  }\n  async finishCurrentRun() {\n    if (!this.snapshotState)\n      return null;\n    const result = await this.snapshotState.pack();\n    this.snapshotState = void 0;\n    return result;\n  }\n  clear() {\n    this.snapshotStateMap.clear();\n  }\n}\n\nexport { SnapshotClient, SnapshotState, addSerializer, getSerializers, stripSnapshotIndentation };\n"],"file":"assets/vendors/vitest_snapshot-DDbcfdwL.js"}
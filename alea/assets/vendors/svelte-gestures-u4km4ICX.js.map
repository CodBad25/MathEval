{"version":3,"file":"svelte-gestures-u4km4ICX.js","sources":["../../../node_modules/.pnpm/svelte-gestures@4.0.0/node_modules/svelte-gestures/dist/index.esm.js"],"sourcesContent":["const DEFAULT_DELAY = 300; // ms\nconst DEFAULT_PRESS_SPREAD = 4; // px\nconst DEFAULT_MIN_SWIPE_DISTANCE = 60; // px\nconst DEFAULT_TOUCH_ACTION = 'none';\n\n// export type PointerType = 'mouse' | 'touch' | 'pen' | 'all';\n\nfunction ensureArray(o) {\n  if (Array.isArray(o)) return o;\n  return [o];\n}\nfunction addEventListener(node, event, handler) {\n  node.addEventListener(event, handler);\n  return () => node.removeEventListener(event, handler);\n}\nfunction getCenterOfTwoPoints(node, activeEvents) {\n  const rect = node.getBoundingClientRect();\n  const xDistance = Math.abs(activeEvents[0].clientX - activeEvents[1].clientX);\n  const yDistance = Math.abs(activeEvents[0].clientY - activeEvents[1].clientY);\n  const minX = Math.min(activeEvents[0].clientX, activeEvents[1].clientX);\n  const minY = Math.min(activeEvents[0].clientY, activeEvents[1].clientY);\n  const centerX = minX + xDistance / 2;\n  const centerY = minY + yDistance / 2;\n  const x = Math.round(centerX - rect.left);\n  const y = Math.round(centerY - rect.top);\n  return {\n    x,\n    y\n  };\n}\nfunction removeEvent(event, activeEvents) {\n  return activeEvents.filter(activeEvent => {\n    return event.pointerId !== activeEvent.pointerId;\n  });\n}\nfunction dispatch(node, gestureName, event, activeEvents, actionType) {\n  node.dispatchEvent(new CustomEvent(`${gestureName}${actionType}`, {\n    detail: {\n      event,\n      pointersCount: activeEvents.length,\n      target: event.target\n    }\n  }));\n}\nfunction setPointerControls(gestureName, node, onMoveCallback, onDownCallback, onUpCallback, touchAction = DEFAULT_TOUCH_ACTION) {\n  node.style.touchAction = ensureArray(touchAction).join(' ');\n  let activeEvents = [];\n  function handlePointerdown(event) {\n    activeEvents.push(event);\n    dispatch(node, gestureName, event, activeEvents, 'down');\n    onDownCallback?.(activeEvents, event);\n    const pointerId = event.pointerId;\n    function onup(e) {\n      if (pointerId === e.pointerId) {\n        activeEvents = removeEvent(e, activeEvents);\n        if (!activeEvents.length) {\n          removeEventHandlers();\n        }\n        dispatch(node, gestureName, e, activeEvents, 'up');\n        onUpCallback?.(activeEvents, e);\n      }\n    }\n    function removeEventHandlers() {\n      removePointermoveHandler();\n      removeLostpointercaptureHandler();\n      removepointerupHandler();\n      removepointerleaveHandler();\n    }\n    const removePointermoveHandler = addEventListener(node, 'pointermove', e => {\n      activeEvents = activeEvents.map(activeEvent => {\n        return e.pointerId === activeEvent.pointerId ? e : activeEvent;\n      });\n      dispatch(node, gestureName, e, activeEvents, 'move');\n      onMoveCallback?.(activeEvents, e);\n    });\n    const removeLostpointercaptureHandler = addEventListener(node, 'lostpointercapture', e => {\n      onup(e);\n    });\n    const removepointerupHandler = addEventListener(node, 'pointerup', e => {\n      onup(e);\n    });\n    const removepointerleaveHandler = addEventListener(node, 'pointerleave', e => {\n      activeEvents = [];\n      removeEventHandlers();\n      dispatch(node, gestureName, e, activeEvents, 'up');\n      onUpCallback?.(activeEvents, e);\n    });\n  }\n  const removePointerdownHandler = addEventListener(node, 'pointerdown', handlePointerdown);\n  return {\n    destroy: () => {\n      removePointerdownHandler();\n    }\n  };\n}\n\nfunction pan(node, inputParameters) {\n  let parameters = {\n    delay: DEFAULT_DELAY,\n    composed: false,\n    touchAction: DEFAULT_TOUCH_ACTION,\n    ...inputParameters\n  };\n  const gestureName = 'pan';\n  let startTime;\n  let target;\n  function onDown(activeEvents, event) {\n    startTime = Date.now();\n    target = event.target;\n  }\n  function onMove(activeEvents, event) {\n    if (activeEvents.length === 1 && Date.now() - startTime > parameters.delay) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(event.clientX - rect.left);\n      const y = Math.round(event.clientY - rect.top);\n      if (x >= 0 && y >= 0 && x <= rect.width && y <= rect.height) {\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            x,\n            y,\n            target\n          }\n        }));\n      }\n    }\n    return false;\n  }\n  if (parameters.composed) {\n    return {\n      onMove,\n      onDown,\n      onUp: null\n    };\n  }\n  return {\n    ...setPointerControls(gestureName, node, onMove, onDown, null, parameters.touchAction),\n    update: updateParameters => {\n      parameters = {\n        ...parameters,\n        ...updateParameters\n      };\n    }\n  };\n}\n\nfunction getPointersDistance(activeEvents) {\n  return Math.hypot(activeEvents[0].clientX - activeEvents[1].clientX, activeEvents[0].clientY - activeEvents[1].clientY);\n}\nfunction pinch(node, inputParameters) {\n  const parameters = {\n    touchAction: DEFAULT_TOUCH_ACTION,\n    composed: false,\n    ...inputParameters\n  };\n  const gestureName = 'pinch';\n  let prevDistance;\n  let initDistance = 0;\n  let pinchCenter;\n  function onUp(activeEvents, event) {\n    if (activeEvents.length === 1) {\n      prevDistance = undefined;\n    }\n  }\n  function onDown(activeEvents, event) {\n    if (activeEvents.length === 2) {\n      initDistance = getPointersDistance(activeEvents);\n      pinchCenter = getCenterOfTwoPoints(node, activeEvents);\n    }\n  }\n  function onMove(activeEvents, event) {\n    if (activeEvents.length === 2) {\n      const curDistance = getPointersDistance(activeEvents);\n      if (prevDistance !== undefined && curDistance !== prevDistance) {\n        const scale = curDistance / initDistance;\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            scale,\n            center: pinchCenter\n          }\n        }));\n      }\n      prevDistance = curDistance;\n    }\n    return false;\n  }\n  if (parameters.composed) {\n    return {\n      onMove,\n      onDown,\n      onUp: null\n    };\n  }\n  return setPointerControls(gestureName, node, onMove, onDown, onUp, parameters.touchAction);\n}\n\nfunction press(node, inputParameters) {\n  const parameters = {\n    composed: false,\n    timeframe: DEFAULT_DELAY,\n    triggerBeforeFinished: false,\n    spread: DEFAULT_PRESS_SPREAD,\n    touchAction: 'auto',\n    ...inputParameters\n  };\n  node.style.userSelect = 'none';\n  node.oncontextmenu = e => {\n    e.preventDefault();\n  };\n  const gestureName = 'press';\n  let startTime;\n  let clientX;\n  let clientY;\n  const clientMoved = {\n    x: 0,\n    y: 0\n  };\n  let timeout;\n  let triggeredOnTimeout = false;\n  let triggered = false;\n  function onDone(eventX, eventY, event) {\n    if (Math.abs(eventX - clientX) < parameters.spread && Math.abs(eventY - clientY) < parameters.spread && Date.now() - startTime > parameters.timeframe) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(eventX - rect.left);\n      const y = Math.round(eventY - rect.top);\n      triggered = true;\n      node.dispatchEvent(new CustomEvent(gestureName, {\n        detail: {\n          x,\n          y,\n          target: event.target,\n          pointerType: event.pointerType\n        }\n      }));\n    }\n  }\n  function onUp(activeEvents, event) {\n    clearTimeout(timeout);\n    if (!triggeredOnTimeout) {\n      onDone(event.clientX, event.clientY, event);\n    }\n  }\n  function onMove(activeEvents, event) {\n    clientMoved.x = event.clientX;\n    clientMoved.y = event.clientY;\n    return triggered;\n  }\n  function onDown(activeEvents, event) {\n    triggered = false;\n    clientX = event.clientX;\n    clientY = event.clientY;\n    startTime = Date.now();\n    triggeredOnTimeout = false;\n    clientMoved.x = event.clientX;\n    clientMoved.y = event.clientY;\n    if (parameters.triggerBeforeFinished) {\n      timeout = setTimeout(() => {\n        triggeredOnTimeout = true;\n        onDone(clientMoved.x, clientMoved.y, event);\n      }, parameters.timeframe + 1);\n    }\n  }\n  const onSharedDestroy = setPointerControls(gestureName, node, onMove, onDown, onUp, parameters.touchAction);\n  if (parameters.composed) {\n    return {\n      onMove,\n      onDown,\n      onUp\n    };\n  }\n  return {\n    destroy: () => {\n      onSharedDestroy.destroy();\n      clearTimeout(timeout);\n    }\n  };\n}\n\nfunction getPointersAngleDeg(activeEvents) {\n  const quadrantsMap = {\n    left: {\n      top: 360,\n      bottom: 180\n    },\n    right: {\n      top: 0,\n      bottom: 180\n    }\n  };\n  const width = activeEvents[1].clientX - activeEvents[0].clientX;\n  const height = activeEvents[0].clientY - activeEvents[1].clientY;\n\n  /*\n  In quadrants 1 and 3 allworks as expected. \n  In quadrants 2 and 4, either height or width is negative,\n  so we get negative angle. It is even the other of the two angles.\n  As sum in triangle is 180 deg, we can simply sum the negative angle with 90 deg\n  and get the right angle's positive value. Then add 90 for each quadrant above 1st.\n  This way we dont need to code our own arc cotangent fn (it does not exist in JS)\n  */\n\n  const angle = Math.atan(width / height) / (Math.PI / 180);\n  const halfQuadrant = width > 0 ? quadrantsMap.right : quadrantsMap.left;\n  const quadrantAngleBonus = height > 0 ? halfQuadrant.top : halfQuadrant.bottom;\n  return angle + quadrantAngleBonus;\n}\nfunction rotate(node, inputParameters) {\n  const parameters = {\n    touchAction: DEFAULT_TOUCH_ACTION,\n    composed: false,\n    ...inputParameters\n  };\n  const gestureName = 'rotate';\n  let prevAngle;\n  let initAngle = 0;\n  let rotationCenter;\n  function onUp(activeEvents, event) {\n    if (activeEvents.length === 1) {\n      prevAngle = undefined;\n    }\n  }\n  function onDown(activeEvents, event) {\n    if (activeEvents.length === 2) {\n      activeEvents = activeEvents.sort((a, b) => {\n        return a.clientX - b.clientX;\n      });\n      rotationCenter = getCenterOfTwoPoints(node, activeEvents);\n      initAngle = getPointersAngleDeg(activeEvents);\n    }\n  }\n  function onMove(activeEvents, event) {\n    if (activeEvents.length === 2) {\n      const curAngle = getPointersAngleDeg(activeEvents);\n      if (prevAngle !== undefined && curAngle !== prevAngle) {\n        // Make sure we start at zero, doesnt matter what is the initial angle of fingers\n        let rotation = curAngle - initAngle;\n\n        // instead of showing 180 - 360, we will show negative -180 - 0\n        if (rotation > 180) {\n          rotation -= 360;\n        }\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            rotation,\n            center: rotationCenter\n          }\n        }));\n      }\n      prevAngle = curAngle;\n    }\n    return false;\n  }\n  if (parameters.composed) {\n    return {\n      onMove,\n      onDown,\n      onUp\n    };\n  }\n  return setPointerControls(gestureName, node, onMove, onDown, onUp, parameters.touchAction);\n}\n\nfunction swipe(node, inputParameters) {\n  const parameters = {\n    timeframe: DEFAULT_DELAY,\n    minSwipeDistance: DEFAULT_MIN_SWIPE_DISTANCE,\n    touchAction: DEFAULT_TOUCH_ACTION,\n    composed: false,\n    ...inputParameters\n  };\n  const gestureName = 'swipe';\n  let startTime;\n  let clientX;\n  let clientY;\n  let target;\n  function onDown(activeEvents, event) {\n    clientX = event.clientX;\n    clientY = event.clientY;\n    startTime = Date.now();\n    if (activeEvents.length === 1) {\n      target = event.target;\n    }\n  }\n  function onUp(activeEvents, event) {\n    if (event.type === 'pointerup' && activeEvents.length === 0 && Date.now() - startTime < parameters.timeframe) {\n      const x = event.clientX - clientX;\n      const y = event.clientY - clientY;\n      const absX = Math.abs(x);\n      const absY = Math.abs(y);\n      let direction = null;\n      if (absX >= 2 * absY && absX > parameters.minSwipeDistance) {\n        // horizontal (by *2 we eliminate diagonal movements)\n        direction = x > 0 ? 'right' : 'left';\n      } else if (absY >= 2 * absX && absY > parameters.minSwipeDistance) {\n        // vertical (by *2 we eliminate diagonal movements)\n        direction = y > 0 ? 'bottom' : 'top';\n      }\n      if (direction) {\n        node.dispatchEvent(new CustomEvent(gestureName, {\n          detail: {\n            direction,\n            target\n          }\n        }));\n      }\n    }\n  }\n  if (parameters.composed) {\n    return {\n      onMove: null,\n      onDown,\n      onUp\n    };\n  }\n  return setPointerControls(gestureName, node, null, onDown, onUp, parameters.touchAction);\n}\n\nfunction callAllByType(ListenerType, subGestureFunctions, activeEvents, event) {\n  subGestureFunctions.forEach(gesture => {\n    gesture[ListenerType]?.(activeEvents, event);\n  });\n}\nfunction composedGesture(node, gestureCallback) {\n  const gestureFunctions = [];\n  function registerGesture(gestureFn, parameters) {\n    const subGestureFns = gestureFn(node, {\n      ...parameters,\n      composed: true\n    });\n    gestureFunctions.push(subGestureFns);\n    return subGestureFns;\n  }\n  const onMoveCallback = gestureCallback(registerGesture);\n  const gestureName = 'composedGesture';\n  function onUp(activeEvents, event) {\n    callAllByType('onUp', gestureFunctions, activeEvents, event);\n  }\n  function onDown(activeEvents, event) {\n    callAllByType('onDown', gestureFunctions, activeEvents, event);\n  }\n  function onMove(activeEvents, event) {\n    onMoveCallback(activeEvents, event);\n    return true;\n  }\n  return setPointerControls(gestureName, node, onMove, onDown, onUp);\n}\n\nconst DEFAULT_TRESHOLD = 0.9;\nconst DEFAULT_NB_OF_SAMPLE_POINTS = 64;\nconst PHI = (Math.sqrt(5.0) - 1) / 2;\nconst ANGLE_RANGE_RAD = deg2Rad(45.0);\nconst ANGLE_PRECISION_RAD = deg2Rad(2.0);\nfunction deg2Rad(d) {\n  return d * Math.PI / 180;\n}\nfunction getDistance(a, b) {\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nfunction distanceAtBestAngle(pattern, points, center) {\n  let fromAngleRad = -ANGLE_RANGE_RAD;\n  let toAngleRad = ANGLE_RANGE_RAD;\n  let angleOne = PHI * fromAngleRad + (1.0 - PHI) * toAngleRad;\n  let distanceOne = distanceAtAngle(pattern, angleOne, points, center);\n  let angleTwo = (1.0 - PHI) * fromAngleRad + PHI * toAngleRad;\n  let distanceTwo = distanceAtAngle(pattern, angleTwo, points, center);\n  while (Math.abs(toAngleRad - fromAngleRad) > ANGLE_PRECISION_RAD) {\n    if (distanceOne < distanceTwo) {\n      toAngleRad = angleTwo;\n      angleTwo = angleOne;\n      distanceTwo = distanceOne;\n      angleOne = PHI * fromAngleRad + (1.0 - PHI) * toAngleRad;\n      distanceOne = distanceAtAngle(pattern, angleOne, points, center);\n    } else {\n      fromAngleRad = angleOne;\n      angleOne = angleTwo;\n      distanceOne = distanceTwo;\n      angleTwo = (1.0 - PHI) * fromAngleRad + PHI * toAngleRad;\n      distanceTwo = distanceAtAngle(pattern, angleTwo, points, center);\n    }\n  }\n  return Math.min(distanceOne, distanceTwo);\n}\nfunction distanceAtAngle(pattern, angle, points, center) {\n  const strokePoints = rotateBy(angle, points, center);\n  const d = strokePoints.reduce((accu, sPoint, i) => {\n    return accu += getDistance(sPoint, pattern.points[i]);\n  }, 0);\n  return d / strokePoints.length;\n}\nfunction rotateBy(angle, points, center) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return points.map(point => {\n    return {\n      x: (point.x - center.x) * cos - (point.y - center.y) * sin + center.x,\n      y: (point.x - center.x) * sin + (point.y - center.y) * cos + center.y\n    };\n  });\n}\nfunction shapeDetector(inputPatterns, options = {}) {\n  const threshold = options.threshold || 0;\n  const NUMBER_OF_SAMPLE_POINTS = options.nbOfSamplePoints || DEFAULT_NB_OF_SAMPLE_POINTS;\n  const SQUARE_SIZE = 250;\n  const HALF_SQUARE_DIAGONAL = Math.sqrt(SQUARE_SIZE ** 2 + SQUARE_SIZE ** 2) / 2;\n  const patterns = inputPatterns.flatMap(pattern => learn(pattern.name, pattern.points, pattern.allowRotation ?? false, pattern.bothDirections ?? true));\n  function getStroke(points, name, allowRotation) {\n    points = resample();\n    const center = getCenterPoint();\n    if (allowRotation) {\n      points = rotateBy(-indicativeAngle(center), points, center);\n    }\n    points = scaleToSquare();\n    points = translateToOrigin(getCenterPoint());\n    return {\n      name,\n      points,\n      center: {\n        x: 0,\n        y: 0\n      },\n      allowRotation\n    };\n    function resample() {\n      let localDistance, q;\n      let distance = 0;\n      const interval = strokeLength() / (NUMBER_OF_SAMPLE_POINTS - 1);\n      const newPoints = [points[0]];\n      for (let i = 1; i < points.length; i++) {\n        localDistance = getDistance(points[i - 1], points[i]);\n        if (distance + localDistance >= interval) {\n          q = {\n            x: points[i - 1].x + (interval - distance) / localDistance * (points[i].x - points[i - 1].x),\n            y: points[i - 1].y + (interval - distance) / localDistance * (points[i].y - points[i - 1].y)\n          };\n          newPoints.push(q);\n          points.splice(i, 0, q);\n          distance = 0;\n        } else {\n          distance += localDistance;\n        }\n      }\n      if (newPoints.length === NUMBER_OF_SAMPLE_POINTS - 1) {\n        newPoints.push(points[points.length - 1]);\n      }\n      return newPoints;\n    }\n    function scaleToSquare() {\n      const box = {\n        minX: +Infinity,\n        maxX: -Infinity,\n        minY: +Infinity,\n        maxY: -Infinity,\n        width: 0,\n        height: 0\n      };\n      points.forEach(point => {\n        box.minX = Math.min(box.minX, point.x);\n        box.minY = Math.min(box.minY, point.y);\n        box.maxX = Math.max(box.maxX, point.x);\n        box.maxY = Math.max(box.maxY, point.y);\n      });\n      box.width = box.maxX - box.minX;\n      box.height = box.maxY - box.minY;\n      return points.map(point => {\n        return {\n          x: point.x * (SQUARE_SIZE / box.width),\n          y: point.y * (SQUARE_SIZE / box.height)\n        };\n      });\n    }\n    function translateToOrigin(center) {\n      return points.map(point => ({\n        x: point.x - center.x,\n        y: point.y - center.y\n      }));\n    }\n    function getCenterPoint() {\n      const centre = points.reduce((acc, point) => {\n        acc.x += point.x;\n        acc.y += point.y;\n        return acc;\n      }, {\n        x: 0,\n        y: 0\n      });\n      centre.x /= points.length;\n      centre.y /= points.length;\n      return centre;\n    }\n    function indicativeAngle(center) {\n      return Math.atan2(center.y - points[0].y, center.x - points[0].x);\n    }\n    function strokeLength() {\n      let d = 0;\n      for (let i = 1; i < points.length; i++) {\n        d += getDistance(points[i - 1], points[i]);\n      }\n      return d;\n    }\n  }\n  function detect(points, patternName = '') {\n    const strokeRotated = getStroke(points, patternName, true);\n    const strokeUnrotated = getStroke(points, patternName, false);\n    let bestDistance = +Infinity;\n    let bestPattern = null;\n    let bestScore = 0;\n    patterns.forEach(pattern => {\n      if (pattern.name.indexOf(patternName) > -1) {\n        const distance = pattern.allowRotation ? distanceAtBestAngle(pattern, strokeRotated.points, strokeRotated.center) : distanceAtAngle(pattern, 0, strokeUnrotated.points, strokeUnrotated.center);\n        const score = 1.0 - distance / HALF_SQUARE_DIAGONAL;\n        if (distance < bestDistance && score > threshold) {\n          bestDistance = distance;\n          bestPattern = pattern.name;\n          bestScore = score;\n        }\n      }\n    });\n    return {\n      pattern: bestPattern,\n      score: bestScore\n    };\n  }\n  function learn(name, points, allowRotation, bothDirections) {\n    const response = [getStroke([...points], name, allowRotation)];\n    if (bothDirections) {\n      response.push(getStroke([...points.reverse()], name, allowRotation));\n    }\n    return response;\n  }\n  return {\n    detect\n  };\n}\n\nfunction shapeGesture(node, inputParameters) {\n  let parameters = {\n    composed: false,\n    shapes: [],\n    threshold: DEFAULT_TRESHOLD,\n    timeframe: 1000,\n    nbOfSamplePoints: DEFAULT_NB_OF_SAMPLE_POINTS,\n    touchAction: DEFAULT_TOUCH_ACTION,\n    ...inputParameters\n  };\n  const gestureName = 'shapeGesture';\n  const detector = shapeDetector(parameters.shapes, {\n    ...parameters\n  });\n  let startTime;\n  let target;\n  let stroke = [];\n  function onDown(activeEvents, event) {\n    startTime = Date.now();\n    target = event.target;\n    stroke = [];\n  }\n  function onMove(activeEvents, event) {\n    if (activeEvents.length === 1) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(event.clientX - rect.left);\n      const y = Math.round(event.clientY - rect.top);\n      stroke.push({\n        x,\n        y\n      });\n    }\n    return false;\n  }\n  function onUp(activeEvents, event) {\n    if (stroke.length > 2 && Date.now() - startTime < parameters.timeframe) {\n      const detectionResult = detector.detect(stroke);\n      node.dispatchEvent(new CustomEvent(gestureName, {\n        detail: {\n          ...detectionResult,\n          target\n        }\n      }));\n    }\n  }\n  if (parameters.composed) {\n    return {\n      onMove,\n      onDown,\n      onUp\n    };\n  }\n  return {\n    ...setPointerControls(gestureName, node, onMove, onDown, onUp, parameters.touchAction),\n    update: updateParameters => {\n      parameters = {\n        ...parameters,\n        ...updateParameters\n      };\n    }\n  };\n}\n\nfunction isScrollMode(event) {\n  return event.pointerType === 'touch';\n}\nfunction getScrollParent(node, direction) {\n  if (!node) {\n    return undefined;\n  }\n  const isElement = node instanceof HTMLElement;\n  const overflowY = isElement && window.getComputedStyle(node).overflowY;\n  const isScrollable = overflowY !== 'visible' && overflowY !== 'hidden';\n  const directionToDimension = {\n    x: 'Width',\n    y: 'Height'\n  };\n  if (isScrollable && node[`scroll${directionToDimension[direction]}`] > node[`client${directionToDimension[direction]}`]) {\n    return node;\n  } else {\n    return getScrollParent(node.parentNode, direction) || document.scrollingElement || document.body;\n  }\n}\nfunction scroll(node, inputParameters) {\n  let parameters = {\n    ...{\n      delay: DEFAULT_DELAY,\n      touchAction: DEFAULT_TOUCH_ACTION,\n      composed: false\n    },\n    ...inputParameters\n  };\n  const gestureName = 'scroll';\n  const nearestScrollEl = {\n    x: undefined,\n    y: undefined\n  };\n  let prevCoords;\n  const scrollDelta = {\n    x: 0,\n    y: 0\n  };\n  const scrollDirectionPositive = {\n    x: true,\n    y: true\n  };\n  function scrollElementTo(el, scrollValue, direction) {\n    el?.scrollBy({\n      [direction === 'x' ? 'left' : 'top']: scrollValue,\n      behavior: 'auto'\n    });\n  }\n  function onDown(activeEvents, event) {\n    nearestScrollEl.y = getScrollParent(node, 'y');\n    nearestScrollEl.x = getScrollParent(node, 'x');\n    prevCoords = undefined;\n  }\n  function onMove(activeEvents, event) {\n    if (activeEvents.length === 1 && isScrollMode(event)) {\n      if (prevCoords !== undefined) {\n        scrollDelta.y = Math.round(prevCoords.y - event.clientY);\n        scrollDelta.x = Math.round(prevCoords.x - event.clientX);\n        nearestScrollEl.y && scrollElementTo(nearestScrollEl.y, scrollDelta.y, 'y');\n        nearestScrollEl.x && scrollElementTo(nearestScrollEl.x, scrollDelta.x, 'x');\n      }\n      prevCoords = {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n    return false;\n  }\n  function onUp(activeEvents, event) {\n    if (isScrollMode(event)) {\n      if (scrollDelta.y || scrollDelta.x) {\n        scrollDirectionPositive.y = scrollDelta.y > 0;\n        scrollDirectionPositive.x = scrollDelta.x > 0;\n        requestAnimationFrame(scrollOutLoop);\n      }\n    }\n  }\n  function scrollOutByDirection(direction) {\n    if (!scrollDirectionPositive[direction] && scrollDelta[direction] < 0) {\n      scrollDelta[direction] += 0.3;\n    } else if (scrollDirectionPositive[direction] && scrollDelta[direction] > 0) {\n      scrollDelta[direction] -= 0.3;\n    } else {\n      scrollDelta[direction] = 0;\n    }\n    if (scrollDelta[direction]) {\n      scrollElementTo(nearestScrollEl[direction], scrollDelta[direction], direction);\n      requestAnimationFrame(scrollOutLoop);\n    }\n  }\n  function scrollOutLoop() {\n    nearestScrollEl.x && scrollOutByDirection('x');\n    nearestScrollEl.y && scrollOutByDirection('y');\n  }\n  if (parameters.composed) {\n    return {\n      onMove,\n      onUp,\n      onDown\n    };\n  }\n  return {\n    ...setPointerControls(gestureName, node, onMove, onDown, onUp, parameters.touchAction),\n    update: updateParameters => {\n      parameters = {\n        ...parameters,\n        ...updateParameters\n      };\n    }\n  };\n}\n\nfunction tap(node, inputParameters) {\n  const parameters = {\n    timeframe: DEFAULT_DELAY,\n    composed: false,\n    touchAction: 'auto',\n    ...inputParameters\n  };\n  const gestureName = 'tap';\n  let startTime;\n  let clientX;\n  let clientY;\n  function onUp(activeEvents, event) {\n    if (Math.abs(event.clientX - clientX) < 4 && Math.abs(event.clientY - clientY) < 4 && Date.now() - startTime < parameters.timeframe) {\n      const rect = node.getBoundingClientRect();\n      const x = Math.round(event.clientX - rect.left);\n      const y = Math.round(event.clientY - rect.top);\n      node.dispatchEvent(new CustomEvent(gestureName, {\n        detail: {\n          x,\n          y,\n          target: event.target\n        }\n      }));\n    }\n  }\n  function onDown(activeEvents, event) {\n    clientX = event.clientX;\n    clientY = event.clientY;\n    startTime = Date.now();\n  }\n  if (parameters.composed) {\n    return {\n      onMove: null,\n      onDown,\n      onUp\n    };\n  }\n  return setPointerControls(gestureName, node, null, onDown, onUp, parameters.touchAction);\n}\n\nexport { DEFAULT_DELAY, DEFAULT_MIN_SWIPE_DISTANCE, DEFAULT_PRESS_SPREAD, DEFAULT_TOUCH_ACTION, composedGesture, getCenterOfTwoPoints, pan, pinch, press, rotate, scroll, setPointerControls, shapeGesture, swipe, tap };\n"],"names":["DEFAULT_TOUCH_ACTION","ensureArray","o","addEventListener","node","event","handler","removeEvent","activeEvents","activeEvent","dispatch","gestureName","actionType","setPointerControls","onMoveCallback","onDownCallback","onUpCallback","touchAction","handlePointerdown","pointerId","onup","e","removeEventHandlers","removePointermoveHandler","removeLostpointercaptureHandler","removepointerupHandler","removepointerleaveHandler","removePointerdownHandler","swipe","inputParameters","parameters","startTime","clientX","clientY","target","onDown","onUp","x","y","absX","absY","direction"],"mappings":"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","x_google_ignoreList":[0]}
import{f as Ys}from"./mathjs-oaIJR0Fd.js";var y={NO_CHANGE:"NO_CHANGE",EQUALITY:"EQUALITY",SIMPLIFY_ARITHMETIC:"SIMPLIFY_ARITHMETIC",DIVISION_BY_NEGATIVE_ONE:"DIVISION_BY_NEGATIVE_ONE",DIVISION_BY_ONE:"DIVISION_BY_ONE",MULTIPLY_BY_ZERO:"MULTIPLY_BY_ZERO",REARRANGE_COEFF:"REARRANGE_COEFF",REDUCE_EXPONENT_BY_ZERO:"REDUCE_EXPONENT_BY_ZERO",REDUCE_ZERO_NUMERATOR:"REDUCE_ZERO_NUMERATOR",REMOVE_ADDING_ZERO:"REMOVE_ADDING_ZERO",REMOVE_EXPONENT_BY_ONE:"REMOVE_EXPONENT_BY_ONE",REMOVE_EXPONENT_BASE_ONE:"REMOVE_EXPONENT_BASE_ONE",REMOVE_MULTIPLYING_BY_NEGATIVE_ONE:"REMOVE_MULTIPLYING_BY_NEGATIVE_ONE",REMOVE_MULTIPLYING_BY_ONE:"REMOVE_MULTIPLYING_BY_ONE",RESOLVE_DOUBLE_MINUS:"RESOLVE_DOUBLE_MINUS",COLLECT_AND_COMBINE_LIKE_TERMS:"COLLECT_AND_COMBINE_LIKE_TERMS",COLLECT_LIKE_TERMS:"COLLECT_LIKE_TERMS",COLLECT_CONSTANT_EXPONENTS:"COLLECT_CONSTANT_EXPONENTS",ADD_COEFFICIENT_OF_ONE:"ADD_COEFFICIENT_OF_ONE",ADD_POLYNOMIAL_TERMS:"ADD_POLYNOMIAL_TERMS",GROUP_COEFFICIENTS:"GROUP_COEFFICIENTS",UNARY_MINUS_TO_NEGATIVE_ONE:"UNARY_MINUS_TO_NEGATIVE_ONE",CROSS_PRODUCT_EQUALITY:"CROSS_PRODUCT_EQUALITY",ADD_EXPONENT_OF_ONE:"ADD_EXPONENT_OF_ONE",COLLECT_POLYNOMIAL_EXPONENTS:"COLLECT_POLYNOMIAL_EXPONENTS",MULTIPLY_COEFFICIENTS:"MULTIPLY_COEFFICIENTS",MULTIPLY_POLYNOMIAL_TERMS:"MULTIPLY_POLYNOMIAL_TERMS",BREAK_UP_FRACTION:"BREAK_UP_FRACTION",CANCEL_MINUSES:"CANCEL_MINUSES",CANCEL_TERMS:"CANCEL_TERMS",SIMPLIFY_FRACTION:"SIMPLIFY_FRACTION",SIMPLIFY_SIGNS:"SIMPLIFY_SIGNS",SIMPLIFY_SIGNS_BEFORE:"SIMPLIFY_SIGNS_BEFORE",FIND_GCD:"FIND_GCD",CANCEL_GCD:"CANCEL_GCD",CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION:"CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION",IMPROPER_FRACTION_NUMERATOR:"IMPROPER_FRACTION_NUMERATOR",ADD_FRACTIONS:"ADD_FRACTIONS",ADD_NUMERATORS:"ADD_NUMERATORS",COMBINE_NUMERATORS:"COMBINE_NUMERATORS",COMMON_DENOMINATOR:"COMMON_DENOMINATOR",CONVERT_INTEGER_TO_FRACTION:"CONVERT_INTEGER_TO_FRACTION",DIVIDE_FRACTION_FOR_ADDITION:"DIVIDE_FRACTION_FOR_ADDITION",MULTIPLY_DENOMINATORS:"MULTIPLY_DENOMINATORS",MULTIPLY_NUMERATORS:"MULTIPLY_NUMERATORS",MULTIPLY_FRACTIONS:"MULTIPLY_FRACTIONS",SIMPLIFY_DIVISION:"SIMPLIFY_DIVISION",MULTIPLY_BY_INVERSE:"MULTIPLY_BY_INVERSE",DISTRIBUTE:"DISTRIBUTE",DISTRIBUTE_NEGATIVE_ONE:"DISTRIBUTE_NEGATIVE_ONE",SIMPLIFY_TERMS:"SIMPLIFY_TERMS",EXPAND_EXPONENT:"EXPAND_EXPONENT",ABSOLUTE_VALUE:"ABSOLUTE_VALUE",CANCEL_EXPONENT:"CANCEL_EXPONENT",CANCEL_EXPONENT_AND_ROOT:"CANCEL_EXPONENT_AND_ROOT",CANCEL_ROOT:"CANCEL_ROOT",COMBINE_UNDER_ROOT:"COMBINE_UNDER_ROOT",CONVERT_MULTIPLICATION_TO_EXPONENT:"CONVERT_MULTIPLICATION_TO_EXPONENT",DISTRIBUTE_NTH_ROOT:"DISTRIBUTE_NTH_ROOT",EVALUATE_DISTRIBUTED_NTH_ROOT:"EVALUATE_DISTRIBUTED_NTH_ROOT",FACTOR_INTO_PRIMES:"FACTOR_INTO_PRIMES",GROUP_TERMS_BY_ROOT:"GROUP_TERMS_BY_ROOT",NTH_ROOT_VALUE:"NTH_ROOT_VALUE",ADD_NTH_ROOTS:"ADD_NTH_ROOTS",MULTIPLY_NTH_ROOTS:"MULTIPLY_NTH_ROOTS",ADD_TO_BOTH_SIDES:"ADD_TO_BOTH_SIDES",DIVIDE_FROM_BOTH_SIDES:"DIVIDE_FROM_BOTH_SIDES",MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION:"MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION",MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE:"MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE",MULTIPLY_TO_BOTH_SIDES:"MULTIPLY_TO_BOTH_SIDES",SIMPLIFY_LEFT_SIDE:"SIMPLIFY_LEFT_SIDE",SIMPLIFY_RIGHT_SIDE:"SIMPLIFY_RIGHT_SIDE",SUBTRACT_FROM_BOTH_SIDES:"SUBTRACT_FROM_BOTH_SIDES",SWAP_SIDES:"SWAP_SIDES",FIND_ROOTS:"FIND_ROOTS",STATEMENT_IS_TRUE:"STATEMENT_IS_TRUE",STATEMENT_IS_FALSE:"STATEMENT_IS_FALSE",FACTOR_SYMBOL:"FACTOR_SYMBOL",FACTOR_DIFFERENCE_OF_SQUARES:"FACTOR_DIFFERENCE_OF_SQUARES",FACTOR_PERFECT_SQUARE:"FACTOR_PERFECT_SQUARE",FACTOR_SUM_PRODUCT_RULE:"FACTOR_SUM_PRODUCT_RULE",BREAK_UP_TERM:"BREAK_UP_TERM"};const{create:Vs,NodeDependencies:ks,lcmDependencies:Hs,nthRootDependencies:Xs,gcdDependencies:Zs,fractionDependencies:js,parseDependencies:Qs,evaluateDependencies:qs,simplifyDependencies:Ws,formatDependencies:Ks}=Ys,zs={},Js=Vs({fractionDependencies:js,lcmDependencies:Hs,gcdDependencies:Zs,nthRootDependencies:Xs,NodeDependencies:ks,formatDependencies:Ks,parseDependencies:Qs,evaluateDependencies:qs,simplifyDependencies:Ws},zs);var se=Js;const v={};v.isOperator=function(e,t=null){return e.type==="OperatorNode"&&e.fn!=="unaryMinus"&&"*+-/^".includes(e.op)&&(t?e.op===t:!0)};v.isParenthesis=function(e){return e.type==="ParenthesisNode"};v.isUnaryMinus=function(e){return e.type==="OperatorNode"&&e.fn==="unaryMinus"};v.isFunction=function(e,t=null){return!(e.type!=="FunctionNode"||t&&e.fn.name!==t)};v.isSymbol=function(e,t=!1){return e.type==="SymbolNode"?!0:t&&v.isUnaryMinus(e)?v.isSymbol(e.args[0],!1):!1};v.isConstant=function(e,t=!1){return e.type==="ConstantNode"?!0:t&&v.isUnaryMinus(e)?!!v.isConstant(e.args[0],!1):!1};v.isConstantFraction=function(e,t=!1){return v.isOperator(e,"/")?e.args.every(r=>v.isConstant(r,t)):!1};v.isConstantOrConstantFraction=function(e,t=!1){return!!(v.isConstant(e,t)||v.isConstantFraction(e,t))};v.isIntegerFraction=function(e,t=!1){if(!v.isConstantFraction(e,t))return!1;let r=e.args[0],n=e.args[1];return t&&(v.isUnaryMinus(r)&&(r=r.args[0]),v.isUnaryMinus(n)&&(n=n.args[0])),Number.isInteger(parseFloat(r.value))&&Number.isInteger(parseFloat(n.value))};var oe=v;const z=se,eo=oe,En={operator(e,t,r=!1){switch(e){case"+":return new z.OperatorNode("+","add",t);case"-":return new z.OperatorNode("-","subtract",t);case"/":return new z.OperatorNode("/","divide",t);case"*":return new z.OperatorNode("*","multiply",t,r);case"^":return new z.OperatorNode("^","pow",t);default:throw Error("Unsupported operation: "+e)}},unaryMinus(e){return new z.OperatorNode("-","unaryMinus",[e])},constant(e){return new z.ConstantNode(e)},symbol(e){return new z.SymbolNode(e)},parenthesis(e){return new z.ParenthesisNode(e)},list(e){return new z.ArrayNode(e)},term(e,t,r,n=!1){let s=e;return t&&(s=this.operator("^",[s,t])),r&&(n||parseFloat(r.value)!==1)&&(eo.isConstant(r)&&parseFloat(r.value)===-1&&!n?s=this.unaryMinus(s):s=this.operator("*",[r,s],!0)),s},polynomialTerm(e,t,r,n=!1){return this.term(e,t,r,n)},nthRoot(e,t){const r=En.symbol("nthRoot");return new z.FunctionNode(r,[e,t])}};var gt=En;function to(e){if(e.evaluate!=null)return e.evaluate();if(e.eval!=null)return e.eval();throw Error(`Problem, no method for evaluate this : ${e}`)}var ye=to;const qe=gt,Te=oe,ro=ye;let _e=class On{constructor(t,r,n=!1){const s=On.parseNode(t,r,n);this.base=s.base,this.exponent=s.exponent,this.coeff=s.coeff}getBaseNode(){return this.base}getCoeffNode(t=!1){return!this.coeff&&t?qe.constant(1):this.coeff}getCoeffValue(){return this.coeff?ro(this.coeff):1}getExponentNode(t=!1){return!this.exponent&&t?qe.constant(1):this.exponent}hasFractionCoeff(){return this.coeff&&Te.isOperator(this.coeff)}hasCoeff(){return!!this.coeff}};_e.isTerm=function(e,t,r=!1){try{return new _e(e,t,r),!0}catch{return!1}};_e.parseNode=function(e,t,r){let n,s,o;if(Te.isOperator(e))if(e.op==="^"){const i=e.args[0];if(!t(i))throw Error("Expected base term, got "+i);n=i,s=e.args[1]}else if(e.op==="*"){if(r&&!e.implicit)throw Error("Expected implicit multiplication");if(e.args.length!==2)throw Error("Expected two arguments to *");const i=Te.isParenthesis(e.args[0])?e.args[0].content:e.args[0];if(!Te.isConstantOrConstantFraction(i))throw Error("Expected coefficient to be constant or fraction of constants term, got "+i);o=i;const c=new _e(e.args[1],t,r);if(c.hasCoeff())throw Error("Cannot have two coefficients "+i+" and "+c.getCoeffNode());n=c.getBaseNode(),s=c.getExponentNode()}else if(e.op==="/"){const i=e.args[1];if(!Te.isConstant(i))throw Error("denominator must be constant node, instead of "+i);const c=new _e(e.args[0],t,r);if(c.hasFractionCoeff())throw Error("Terms with coefficients cannot have nested fractions");s=c.getExponentNode(),n=c.getBaseNode();const u=c.getCoeffNode(!0);o=qe.operator("/",[u,i])}else throw Error("Unsupported operatation for term with coefficent: "+e.op);else if(Te.isUnaryMinus(e)){var a=e.args[0];Te.isParenthesis(a)&&(a=a.content);const i=new _e(a,t,r);s=i.getExponentNode(),n=i.getBaseNode(),i.hasCoeff()?o=no(i.getCoeffNode()):o=qe.constant(-1)}else if(t(e))n=e;else{if(Te.isParenthesis(e))return _e.parseNode(e.content,t,r);throw Error("Unsupported node type: "+e.type)}return{base:n,exponent:s,coeff:o}};function no(e){if(Te.isConstant(e))e=qe.constant(0-parseFloat(e.value));else{const t=0-parseFloat(e.args[0].value);e.args[0]=qe.constant(t)}return e}var hr=_e;const so=oe,_n=hr;let wt=class In extends _n{constructor(t,r=!1){super(t,In.baseNodeFunc,r)}getSymbolNode(){return this.base}getSymbolName(){return this.base.name}};wt.baseNodeFunc=function(e){return so.isSymbol(e)};wt.isPolynomialTerm=function(e,t=!1){return _n.isTerm(e,wt.baseNodeFunc,t)};var dn=wt;const at=gt,He=oe,ut=dn,ue={};ue.isNegative=function(e){if(He.isUnaryMinus(e))return!ue.isNegative(e.args[0]);if(He.isConstant(e))return parseFloat(e.value)<0;if(He.isConstantFraction(e)){const t=parseFloat(e.args[0].value),r=parseFloat(e.args[1].value);if(t<0||r<0)return!(t<0&&r<0)}else if(ut.isPolynomialTerm(e)){const t=new ut(e);return ue.isNegative(t.getCoeffNode(!0))}return!1};ue.negate=function(e,t=!1){if(He.isConstantFraction(e))return e.args[0]=ue.negate(e.args[0],t),e;if(ut.isPolynomialTerm(e))return ue.negatePolynomialTerm(e,t);if(!t){if(He.isUnaryMinus(e))return e.args[0];if(He.isConstant(e))return at.constant(0-parseFloat(e.value))}return at.unaryMinus(e)};ue.negatePolynomialTerm=function(e,t=!1){if(!ut.isPolynomialTerm(e))throw Error("node is not a polynomial term");const r=new ut(e);let n;if(!r.hasCoeff())n=at.constant(-1);else{const s=r.getCoeffNode();if(s.value==="-1")n=null;else if(r.hasFractionCoeff()){let o=s.args[0];o=ue.negate(o,t);const a=s.args[1];n=at.operator("/",[o,a])}else n=ue.negate(s,t),n.value==="1"&&(n=null)}return at.polynomialTerm(r.getSymbolNode(),r.getExponentNode(),n)};var X=ue;const oo=X,ao=gt,Ue=oe,re={};re.isType=function(e,t,r=!0,n=!0){return t(e)?!0:r&&Ue.isUnaryMinus(e)?re.isType(e.args[0],t,r,n):n&&Ue.isParenthesis(e)?re.isType(e.content,t,r,n):!1};re.getType=function(e,t,r=!0,n=!0,s=void 0){if(r===!0&&s===void 0)throw Error("Error in `getType`: moveUnaryMinus is undefined");if(t(e))return e;if(r&&Ue.isUnaryMinus(e))return s(re.getType(e.args[0],t,r,n,s));if(n&&Ue.isParenthesis(e))return re.getType(e.content,t,r,n,s);throw Error("`getType` called on a node that does not belong to specified type")};re.isFraction=function(e,t=!0,r=!0){return re.isType(e,n=>Ue.isOperator(n,"/"),t,r)};re.getFraction=function(e,t=!0,r=!0){const n=function(s){if(!Ue.isOperator(s,"/"))throw Error("Expected a fraction");const o=s.args[0],a=s.args[1],i=oo.negate(o);return ao.operator("/",[i,a])};return re.getType(e,s=>Ue.isOperator(s,"/"),r,t,n)};var io=re;const co=X,Q=oe;function ft(e){if(!Q.isOperator(e,"/")||e.args.length!==2)return!1;const t=e.args[0],r=e.args[1];if(!(Q.isOperator(t,"*")&&t.implicit))return!1;const n=Q.isUnaryMinus(t.args[0])?co.negate(t.args[0].args[0]):t.args[0],s=Q.isParenthesis(t.args[1])?t.args[1].content:t.args[1];if(!(Q.isConstant(n)&&Q.isConstant(s)))return!1;const o=Q.isParenthesis(r)?r.content:r;return!!Q.isConstant(o)}function uo(e){if(!ft(e))throw Error("Expected a mixed number");return Q.isUnaryMinus(e.args[0].args[0])}function lo(e){if(!ft(e))throw Error("Expected a mixed number");const t=Q.isUnaryMinus(e.args[0].args[0])?e.args[0].args[0].args[0]:e.args[0].args[0];return parseInt(t.value)}function po(e){if(!ft(e))throw Error("Expected a mixed number");const t=Q.isParenthesis(e.args[0].args[1])?e.args[0].args[1].content:e.args[0].args[1];return parseInt(t.value)}function go(e){if(!ft(e))throw Error("Expected a mixed number");const t=Q.isParenthesis(e.args[1])?e.args[1].content:e.args[1];return parseInt(t.value)}var fo={isMixedNumber:ft,isNegativeMixedNumber:uo,getWholeNumberValue:lo,getNumeratorValue:po,getDenominatorValue:go};const ho=oe,Rn=hr;let Ft=class Pn extends Rn{constructor(t,r=!1){super(t,Pn.baseNodeFunc,r)}};Ft.baseNodeFunc=function(e){return ho.isFunction(e,"nthRoot")};Ft.isNthRootTerm=function(e,t=!1){return Rn.isTerm(e,Ft.baseNodeFunc,t)};var To=Ft;const wn=y,mt=oe;let Re=class{constructor(t,r,n,s=[]){if(!n)throw Error("node is not defined");if(t===void 0||typeof t!="string")throw Error("changetype isn't valid");this.changeType=t,this.oldNode=r,this.newNode=n,this.substeps=s}hasChanged(){return this.changeType!==wn.NO_CHANGE}};Re.resetChangeGroups=function(e){return e=e.cloneDeep(),e.filter(t=>t.changeGroup).forEach(t=>{delete t.changeGroup}),e};Re.noChange=function(e){return new Re(wn.NO_CHANGE,null,e)};Re.nodeChanged=function(e,t,r,n=!0,s=[]){return n&&(t.changeGroup=1,r.changeGroup=1),new Re(e,t,r,s)};Re.childChanged=function(e,t,r=null){const n=e.cloneDeep(),s=e.cloneDeep();let o=t.substeps;if(!t.oldNode)throw Error("Expected old node for changeType: "+t.changeType);function a(i,c){return i.map(u=>{u=c(u),u.substeps=a(u.substeps,c)}),i}if(mt.isParenthesis(e))n.content=t.oldNode,s.content=t.newNode,o=a(o,i=>{const c=e.cloneDeep(),u=e.cloneDeep();return c.content=i.oldNode,u.content=i.newNode,i.oldNode=c,i.newNode=u,i});else if(mt.isOperator(e)||mt.isFunction(e)&&r!==null)n.args[r]=t.oldNode,s.args[r]=t.newNode,o=a(o,i=>{const c=e.cloneDeep(),u=e.cloneDeep();return c.args[r]=i.oldNode,u.args[r]=i.newNode,i.oldNode=c,i.newNode=u,i});else if(mt.isUnaryMinus(e))n.args[0]=t.oldNode,s.args[0]=t.newNode,o=a(o,i=>{const c=e.cloneDeep(),u=e.cloneDeep();return c.args[0]=i.oldNode,u.args[0]=i.newNode,i.oldNode=c,i.newNode=u,i});else throw Error("Unexpected node type: "+e.type);return new Re(t.changeType,n,s,o)};var Fn=Re;const Co=gt,No=io,mo=fo,yo=To,So=dn,Eo=Fn,Oo=hr,_o=oe;var T={Creator:Co,CustomType:No,MixedNumber:mo,NthRootTerm:yo,PolynomialTerm:So,Status:Eo,Term:Oo,Type:_o};const Mt=T;function Tr(e,t){if(!Mt.Type.isOperator(e,"+"))return!1;const r=e.args;if(!r.every(c=>Mt.Term.isTerm(c,t.baseNodeFunc))||r.length===1)return!1;const n=r.map(c=>new t(c)),s=n[0],o=s.getBaseNode(),a=s.getExponentNode(!0);return n.slice(1).every(c=>{const u=o.equals(c.getBaseNode()),h=c.getExponentNode(!0).equals(a);return u&&h})}function Io(e){return Tr(e,Mt.NthRootTerm)}function Ro(e){return Tr(e,Mt.PolynomialTerm)}var Mn={canAddLikeTermNodes:Tr,canAddLikeTermNthRootNodes:Io,canAddLikeTermPolynomialNodes:Ro};const Ge=T;function dt(e){if(Ge.Type.isOperator(e)||Ge.Type.isFunction(e))return e.args.every(t=>dt(t));if(Ge.Type.isParenthesis(e))return dt(e.content);if(Ge.Type.isConstant(e,!0))return!0;if(Ge.Type.isSymbol(e))return!1;if(Ge.Type.isUnaryMinus(e))return dt(e.args[0]);throw Error("Unsupported node type: "+e.type)}var Cr=dt;const ze=T,Mr=Cr;function Po(e){const t=e.leftNode,r=e.rightNode,n=ze.Type.isConstant(r)&&parseFloat(r.value)===0,s=ze.Type.isOperator(t,"*")||ze.Type.isOperator(t,"^");if(!(n&&s))return!1;if(ze.Type.isOperator(t,"*"))return t.args.filter(a=>!Mr(a)).length>=1;if(ze.Type.isOperator(t,"^"))return!Mr(t)}var wo=Po;const Fo=gt,Rt=oe;function Mo(e){return e.args?e.args[0]:e}function Lo(e){return Rt.isConstant(e)?Fo.constant(1):e.args[1]}function vo(e){return Rt.isOperator(e,"^")&&Rt.isConstant(e.args[0])||Rt.isConstant(e)}var Ln={getBaseNode:Mo,getExponentNode:Lo,isConstantOrConstantPower:vo};const Lr=Ln,vr=T;function Ao(e){if(!vr.Type.isOperator(e)||e.op!=="*")return!1;const t=e.args;if(!t.every(o=>Lr.isConstantOrConstantPower(o))||t.every(o=>!vr.Type.isOperator(o,"^")))return!1;const r=t.map(o=>Lr.getBaseNode(o)),n=r[0];return r.slice(1).every(o=>n.value===o.value)}var Do=Ao;const zt=T;function $o(e){if(!zt.Type.isOperator(e)||e.op!=="*")return!1;const t=e.args;if(!t.every(o=>zt.PolynomialTerm.isPolynomialTerm(o))||t.length===1)return!1;const r=e.args.map(o=>new zt.PolynomialTerm(o));if(!r.every(o=>!o.hasCoeff()))return!1;const n=r[0];return r.slice(1).every(o=>n.getSymbolName()===o.getSymbolName())}var vn=$o;const it={};it.getPrimeFactors=function(e){let t=[];if(e<0)return t=[-1],t=t.concat(it.getPrimeFactors(-1*e)),t;const r=Math.sqrt(e);let n=2;if(e%2)for(n=3;e%n&&n<=r;)n=n+2;return n>r?t.push(e):(t.push(n),t=t.concat(it.getPrimeFactors(e/n))),t};it.getFactorPairs=function(e){const t=[],r=Math.floor(Math.sqrt(Math.abs(e)));for(var n=-r;n<=r;n++)if(n!==0&&e%n===0){const s=e/n;t.push([n,s])}return t};var An=it;const Uo=ye,Dn=X,M=T;function U(e){if(M.MixedNumber.isMixedNumber(e))return e;if(M.Type.isConstant(e,!0)){const t=M.Creator.constant(Uo(e));return e.changeGroup&&(t.changeGroup=e.changeGroup),t}else if(M.Type.isOperator(e)){if("+-/*".includes(e.op)){let t;return e.op==="/"?t="*":e.op==="-"?t="+":t=e.op,bo(e,t)}else e.args.forEach((t,r)=>{e.args[r]=U(t)});return e}else{if(M.Type.isParenthesis(e))return e.content=U(e.content),e;if(M.Type.isUnaryMinus(e)){const t=U(e.args[0]),r=Dn.negate(t,!0);return e.changeGroup&&(r.changeGroup=e.changeGroup),r}else if(M.Type.isFunction(e)&&e.fn.args){const t=U(e.fn),r=U(e.args[0]);return M.Creator.operator("*",[t,M.Creator.parenthesis(r)])}else return M.Type.isFunction(e,"abs")?(e.args[0]=U(e.args[0]),e):(M.Type.isFunction(e,"nthRoot")&&(e.args[0]=U(e.args[0]),e.args[1]&&(e.args[1]=U(e.args[1]))),e)}}function bo(e,t){const r=Xe(e,t);return r.length===1?e=r[0]:(e.op==="/"&&(r.length>2||$n(e))?e=M.Creator.operator("*",r):e.op==="-"?e=M.Creator.operator("+",r):e.args=r,e.op==="*"&&(e.implicit=!1)),e}function Xe(e,t){if(!M.Type.isOperator(e))return[U(e)];switch(e.op){case"*":case"/":if(t!=="*")return[U(e)];break;case"+":case"-":if(t!=="+")return[U(e)];break;default:return[U(e)]}if(M.PolynomialTerm.isPolynomialTerm(e,!0))return e.args.forEach((r,n)=>{e.args[n]=U(e.args[n])}),[e];if(t==="*"&&Bo(e))return Go(e);if(t==="*"&&e.op==="/")return xo(e);if(e.op==="-"){const r=e.args[1],n=Dn.negate(r,!0),s=[Xe(e.args[0],t),Xe(n,t)];return[].concat.apply([],s)}else{const r=[];return e.args.forEach(n=>{r.push(Xe(n,t))}),[].concat.apply([],r)}}function Bo(e){if(e.op!=="*"||e.args.length!==2)return!1;const t=e.args[1];return M.PolynomialTerm.isPolynomialTerm(t)?!new M.PolynomialTerm(t).hasCoeff():!1}function Go(e){const t=Xe(e.args[0],"*"),r=t.pop(),n=U(e.args[1]);return M.Type.isConstantOrConstantFraction(r)?t.push(M.Creator.operator("*",[r,n],!1)):(t.push(r),t.push(n)),t}function xo(e){let t=Xe(e.args[0],"*");if(t.length===1)e.args[0]=t.pop(),e.args[1]=U(e.args[1]),t=[e];else{const r=t.pop(),n=U(e.args[1]),s=M.Creator.operator("/",[r,n]);t.push(s)}return t}function $n(e){return M.Type.isOperator(e)?e.op==="*"?!0:e.op!=="/"?!1:e.args.some($n):!1}var ht=U;function Yo(e){const t=e.cloneDeep(),r=[],n=[];e.traverse(s=>r.push(s)),t.traverse(s=>n.push(s));for(let s=0;s<r.length;s++){const o=r[s],a=n[s];Object.prototype.hasOwnProperty.call(o,"changeGroup")&&(a.changeGroup=o.changeGroup)}return t}var Vo=Yo;const ko=Vo;function Ho(e){const t=ko(e);return t.transform(function(r,n,s){return r.type==="OperatorNode"&&r.op==="*"&&((r.args[1].type==="ParenthesisNode"||r.args[1].type==="SymbolNode"||r.args[1].type==="OperatorNode"&&r.args[1].op==="^"&&r.args[1].args[0].type==="SymbolNode")&&(r.implicit=!0),r.args[1].isOperatorNode&&r.args[1].op==="^"&&r.args[1].args[0].isSymbolNode&&(r.args[1].implicit=!0)),r}),t}var Un=Ho;const{Creator:Ar,PolynomialTerm:Dr}=T,xe=oe;function Xo(e){return!!(Dr.isPolynomialTerm(e)&&new Dr(e).getCoeffValue()<0)}function Zo(e){const t=e.cloneDeep();return t.transform(function(r,n,s){if(r.type==="OperatorNode"&&r.op==="*"){if(xe.isUnaryMinus(r.args[1])||xe.isConstant(r.args[1])&&r.args[1].value<0||Xo(r.args[1])||xe.isOperator(r.args[1])&&(r.args[1].op==="+"||r.args[1].op==="-")){const o=Ar.parenthesis(r.args[1]);r.args[1]=o}}else if(r.type==="OperatorNode"&&r.op==="^"&&(xe.isUnaryMinus(r.args[0])||xe.isConstantOrConstantFraction(r.args[0])&&r.args[0].value<0||xe.isOperator(r.args[0]))){const o=Ar.parenthesis(r.args[0]);r.args[0]=o}return r}),t}var jo=Zo;const bn=ht,Z=T,$r=se,Bn=Un,Gn=jo;function Qo(e,t=!1,r=!1,n=!0,s=!1){n?e=bn(e.cloneDeep()):e=e.cloneDeep(),r&&e.transform(function(a,i,c){return a.isOperatorNode&&a.op==="*"&&(a.implicit=!1),a}),s&&(e=Gn(e));let o=he(e);return t||(o=o.replace(/\s*?\+\s*?\-\s*?/g," - ")),r?$r.parse(o).toString({notation:"fixed"}):Bn($r.parse(o)).toString({notation:"fixed"})}function he(e,t){if(Z.PolynomialTerm.isPolynomialTerm(e)){const r=new Z.PolynomialTerm(e);if(r.hasFractionCoeff()&&e.op!=="/"){const n=r.getCoeffNode(),s=he(n),o=Z.Creator.polynomialTerm(r.getSymbolNode(),r.exponent,null),a=he(o);return`${s} ${a}`}}if(Z.Type.isIntegerFraction(e))return`${e.args[0]}/${e.args[1]}`;if(Z.Type.isOperator(e)){if(e.op==="/"&&Z.Type.isOperator(e.args[1]))return`${he(e.args[0])} / (${he(e.args[1])})`;let r="";switch(e.op){case"+":case"-":r=` ${e.op} `;break;case"*":if(e.implicit){r=" ";break}r=` ${e.op} `;break;case"/":Z.Type.isConstantFraction(e,!0)?r=`${e.op}`:r=` ${e.op} `;break;case"^":r=`${e.op}`;break}let n=e.args.map(s=>he(s,e)).join(r);return t&&Z.Type.isOperator(t)&&e.op&&t.op&&"*/^".indexOf(t.op)>=0&&"+-".indexOf(e.op)>=0&&(n=`(${n})`),n}else return Z.Type.isParenthesis(e)?`(${he(e.content)})`:Z.Type.isUnaryMinus(e)?Z.Type.isOperator(e.args[0])&&"*/^".indexOf(e.args[0].op)===-1&&!Z.PolynomialTerm.isPolynomialTerm(e)?`-(${he(e.args[0])})`:`-${he(e.args[0])}`:e.toString()}function qo(e,t=!1,r=!1,n=!0,s=!1,o){n?e=bn(e.cloneDeep()):e=e.cloneDeep(),s&&(e=Gn(e)),r?e.transform(function(i,c,u){return i.isOperatorNode&&i.op==="*"&&(i.implicit=!1),i}):e=Bn(e),o&&Array.isArray(o)&&o.forEach(i=>{e=i(e)});let a=e.toTex({implicit:"hide",parenthesis:"keep"});return t||(a=a.replace(/\s*?\+\s*?\-\s*?/g," - ").replaceAll("\\frac","\\dfrac").replaceAll("\\cdot","\\times ")),a=a.replace(/~/g," ").replace(/ {2,}/g," "),a}var We={ascii:Qo,latex:qo};const Pt=se,x=y,xn=An,Lt=X,p=T,ir=We;function Yn(e){if(!p.Type.isFunction(e,"nthRoot"))return p.Status.noChange(e);const t=Pe(e);if(p.Type.isOperator(t)){if(t.op==="^")return Vn(e);if(t.op==="*")return kn(e)}else if(p.Type.isConstant(t))return ra(e);return p.Status.noChange(e)}function Vn(e){let t=e.cloneDeep();const r=Pe(e),n=be(e),s=r.args[0],o=p.Type.isParenthesis(r.args[1])?r.args[1].content:r.args[1];if(n.equals(o))return t=s,p.Status.nodeChanged(x.CANCEL_EXPONENT_AND_ROOT,e,t);if(p.Type.isConstant(n)&&p.Type.isConstant(o)){const a=parseFloat(n.value),i=parseFloat(o.value);if(a%i===0){const c=a/i,u=p.Creator.constant(c);return t=p.Creator.nthRoot(s,u),p.Status.nodeChanged(x.CANCEL_EXPONENT,e,t)}else if(i%a===0){const c=i/a,u=p.Creator.constant(c);return t=p.Creator.operator("^",[s,u]),p.Status.nodeChanged(x.CANCEL_ROOT,e,t)}}return p.Status.noChange(e)}function kn(e){let t=e.cloneDeep();const r=be(e),n=[];let s;return p.Type.isConstant(r)&&!Lt.isNegative(r)&&(s=Wo(t),s.hasChanged()&&(n.push(s),t=p.Status.resetChangeGroups(s.newNode)),s=Ko(t),s.hasChanged()&&(n.push(s),t=p.Status.resetChangeGroups(s.newNode)),s=zo(t),s.hasChanged()&&(n.push(s),t=p.Status.resetChangeGroups(s.newNode),t.args[0].op==="^"))?(s=Vn(t),n.push(s),p.Status.nodeChanged(x.NTH_ROOT_VALUE,e,s.newNode,!0,n)):(s=Jo(t),n.push(s),t=p.Status.resetChangeGroups(s.newNode),s=ea(t),s.hasChanged()?(n.push(s),t=p.Status.resetChangeGroups(s.newNode),s=ta(t),s.hasChanged()&&(n.push(s),t=p.Status.resetChangeGroups(s.newNode)),p.Status.nodeChanged(x.NTH_ROOT_VALUE,e,t,!0,n)):p.Status.noChange(e))}function Wo(e){const t=e.cloneDeep(),r=Pe(e);let n=[],s=!1;return r.args.forEach(o=>{if(p.PolynomialTerm.isPolynomialTerm(o)){const a=new p.PolynomialTerm(o),i=a.getCoeffNode(),c=p.Creator.polynomialTerm(a.getSymbolNode(),a.getExponentNode(),null);if(i){const u=Ur(i);u.length>1&&(s=!0),n=n.concat(u)}n.push(c)}else{const a=Ur(o);a.length>1&&(s=!0),n=n.concat(a)}}),s?(t.args[0]=p.Creator.operator("*",n),p.Status.nodeChanged(x.FACTOR_INTO_PRIMES,e,t)):p.Status.noChange(e)}function Ur(e){if(p.Type.isConstant(e)&&!Lt.isNegative(e)){const t=parseFloat(e.value);return xn.getPrimeFactors(t).map(p.Creator.constant)}return[e]}function Ko(e){let t=e.cloneDeep();const r=Pe(e),n=be(e),s=parseFloat(n.value);r.args.sort(na);const o=r.args.map(h=>ir.ascii(h));if([...new Set(o)].length===o.length)return p.Status.noChange(e);const a={};r.args.forEach(h=>{const N=ir.ascii(h);a[N]?a[N]++:a[N]=1});const u=Object.keys(a).map(h=>{let N=a[h];const m=Pt.parse(h),$=s,k=[];for(;N-$>0;)N-=$,k.push(p.Creator.parenthesis(p.Creator.operator("*",Array($).fill(m))));const we=N===1?m:p.Creator.parenthesis(p.Creator.operator("*",Array(N).fill(m)));return k.push(we),k}).reduce((h,N)=>h.concat(N),[]),C=p.Creator.operator("*",u);return t=p.Creator.nthRoot(C,n),p.Status.nodeChanged(x.GROUP_TERMS_BY_ROOT,e,t)}function zo(e){const t=e.cloneDeep(),r=Pe(e);if(p.Type.isParenthesis(r)){const n=r.content;if(br(n)){const s=n.args[0],o=p.Creator.constant(n.args.length);return t.args[0]=p.Creator.operator("^",[s,o]),p.Status.nodeChanged(x.CONVERT_MULTIPLICATION_TO_EXPONENT,e,t)}}else if(p.Type.isOperator(r,"*")){const n=[];return r.args.forEach(s=>{if(p.Type.isParenthesis(s)){const o=s.content;if(br(o)){const a=o.args[0],i=p.Creator.constant(o.args.length);n.push(p.Creator.operator("^",[a,i]));return}}n.push(s)}),t.args[0]=p.Creator.operator("*",n),p.Status.nodeChanged(x.CONVERT_MULTIPLICATION_TO_EXPONENT,e,t)}return p.Status.noChange(e)}function Jo(e){let t=e.cloneDeep();const r=Pe(e),n=be(e),s=[];for(let o=0;o<r.args.length;o++){const a=r.args[o];s.push(p.Creator.nthRoot(a,n))}return t=p.Creator.operator("*",s),p.Status.nodeChanged(x.DISTRIBUTE_NTH_ROOT,e,t)}function ea(e){const t=e.cloneDeep(),r=[];for(let n=0;n<t.args.length;n++){const s=t.args[n],o=Yn(s);o.hasChanged()&&(t.args[n]=o.newNode,r.push(p.Status.childChanged(t,o,n)))}return r.length===0?p.Status.noChange(e):r.length===1?r[0]:p.Status.nodeChanged(x.EVALUATE_DISTRIBUTED_NTH_ROOT,e,t,!0,r)}function ta(e){let t=e.cloneDeep(),r;const n=[],s=[];for(let o=0;o<t.args.length;o++){const a=t.args[o];p.Type.isFunction(a,"nthRoot")?(s.push(a.args[0]),r=be(a)):n.push(a)}if(n.length>0){if(s.length>0){const o=s.length===1?s[0]:p.Creator.operator("*",s);n.push(p.Creator.nthRoot(o,r))}if(t=p.Creator.operator("*",n),!t.equals(e))return p.Status.nodeChanged(x.COMBINE_UNDER_ROOT,e,t)}return p.Status.noChange(e)}function ra(e){let t=e.cloneDeep();const r=Pe(e),n=be(e);if(Lt.isNegative(r))return p.Status.noChange(e);if(!p.Type.isConstant(n)||Lt.isNegative(n))return p.Status.noChange(e);const s=parseFloat(r.value),o=parseFloat(n.value),a=Pt.nthRoot(s,o),i=Pt.round(a);if(Pt.pow(i,o)===s)return t=p.Creator.constant(i),p.Status.nodeChanged(x.NTH_ROOT_VALUE,e,t);{const c=xn.getPrimeFactors(s);if(c.length>1){let u=[];const C=c.map(p.Creator.constant);t.args[0]=p.Creator.operator("*",C),u.push(p.Status.nodeChanged(x.FACTOR_INTO_PRIMES,e,t));const h=kn(t);if(h.hasChanged())return u=u.concat(h.substeps),t=h.newNode,p.Status.nodeChanged(x.NTH_ROOT_VALUE,e,t,!0,u)}}return p.Status.noChange(e)}function be(e){if(!p.Type.isFunction(e,"nthRoot"))throw Error("Expected nthRoot");return e.args.length===2?e.args[1]:p.Creator.constant(2)}function Pe(e){if(!p.Type.isFunction(e,"nthRoot"))throw Error("Expected nthRoot");return e.args[0]}function na(e,t){return p.Type.isConstant(e)&&p.Type.isConstant(t)?parseFloat(e.value)-parseFloat(t.value):p.Type.isConstant(e)?-1:p.Type.isConstant(t)?1:0}function br(e){if(!p.Type.isOperator(e)||e.op!=="*")return!1;const t=e.args.map(ir.ascii);return[...new Set(t)].length===1}var Yt={getRadicandNode:Pe,getRootNode:be,nthRoot:Yn};const Br=T,Gr=Yt;function sa(e){if(!Br.Type.isOperator(e,"*")||!e.args.every(n=>Br.Type.isFunction(n,"nthRoot")))return!1;const t=e.args[0],r=Gr.getRootNode(t);return e.args.every(n=>Gr.getRootNode(n).equals(r))}var oa=sa;const Je=T;function aa(e){if(e.op!=="*"||e.implicit||e.args.length!==2||!Je.PolynomialTerm.isPolynomialTerm(e.args[0]))return!1;const t=new Je.PolynomialTerm(e.args[0]);return Je.Type.isParenthesis(e.args[1])&&Je.Type.isConstantOrConstantFraction(e.args[1].content,!0)||Je.Type.isConstantOrConstantFraction(e.args[1],!0)?!t.hasCoeff():!1}var Hn=aa;const ia=Mn,ca=vn,ua=Hn;function la(e){return ia.canAddLikeTermPolynomialNodes(e)||ca(e)||ua(e)}var pa=la;const Fe=T,ga=Cr;function Ve(e){return Fe.Type.isParenthesis(e)?Ve(e.content):Fe.Type.isUnaryMinus(e)?Ve(e.args[0]):Fe.Type.isOperator(e)?e.args.some(Ve):Fe.Type.isSymbol(e)||Fe.Type.isConstant(e)?!1:Fe.Type.isFunction(e,"abs")?e.args.length!==1||e.args.some(Ve)?!0:!ga(e.args[0]):Fe.Type.isFunction(e,"nthRoot")?e.args.some(Ve)||e.args.length<1:!0}var fa=Ve;const W=T,H={};H.getSymbolsInEquation=function(e){const t=H.getSymbolsInExpression(e.leftNode),r=H.getSymbolsInExpression(e.rightNode);return new Set([...t,...r])};H.getSymbolsInExpression=function(e){const r=e.filter(s=>s.isSymbolNode).map(s=>s.name);return new Set(r)};H.getLastSymbolTerm=function(e,t){if(cr(e,t))return e;if(W.Type.isOperator(e,"+")||W.Type.isOperator(e,"*"))for(let r=e.args.length-1;r>=0;r--){const n=e.args[r];if(W.Type.isOperator(n,"+"))return H.getLastSymbolTerm(n,t);if(cr(n,t))return n}else if(W.Type.isParenthesis(e))return H.getLastSymbolTerm(e.content,t);return null};H.getLastNonSymbolTerm=function(e,t){if(Xn(e,t))return new W.PolynomialTerm(e).getCoeffNode();if(vt(e,t))return null;if(W.Type.isOperator(e))for(let r=e.args.length-1;r>=0;r--){const n=e.args[r];if(W.Type.isOperator(n,"+"))return H.getLastNonSymbolTerm(n,t);if(!cr(n,t))return n}return null};H.getLastDenominatorWithSymbolTerm=function(e,t){if(vt(e,t))return e.args[1];if(W.Type.isOperator(e,"+"))for(let r=e.args.length-1;r>=0;r--){const n=e.args[r];if(W.Type.isOperator(n,"+"))return H.getLastDenominatorWithSymbolTerm(n,t);if(vt(n,t))return n.args[1]}return null};function cr(e,t){return Xn(e,t)||vt(e,t)}function Xn(e,t){return!!(W.PolynomialTerm.isPolynomialTerm(e)&&new W.PolynomialTerm(e).getSymbolName()===t)}function vt(e,t){return W.Type.isOperator(e)&&e.op==="/"?H.getSymbolsInExpression(e.args[1]).has(t):!1}var Nr=H;const At=T,ha=Nr;function Ta(e){if(!At.Type.isOperator(e,"+")||e.args.length>3||ha.getSymbolsInExpression(e).size!==1)return!1;const r=e.args.filter(xr(2)),n=e.args.filter(xr(1)),s=e.args.filter(At.Type.isConstant);return!(r.length!==1||n.length>1||s.length>1||r.length+n.length+s.length!==e.args.length)}function xr(e){return function(t){if(At.PolynomialTerm.isPolynomialTerm(t)){const n=new At.PolynomialTerm(t).getExponentNode(!0);return n&&parseFloat(n.value)===e}return!1}}var Ca=Ta;const Yr=se,yt=We,Vr=Un;let ur=class Zn{constructor(t,r,n){this.leftNode=Vr(t),this.rightNode=Vr(r),this.comparator=n}ascii(t=!1,r=!1){const n=yt.ascii(this.leftNode,t,r),s=yt.ascii(this.rightNode,t,r),o=this.comparator;return`${n} ${o} ${s}`}latex(t=!1){const r=yt.latex(this.leftNode,t),n=yt.latex(this.rightNode,t),s=this.comparator;return`${r} ${s==null?void 0:s.replaceAll(">=","\\geqslant").replaceAll("<=","\\leqslant")} ${n}`}clone(){const t=this.leftNode.cloneDeep(),r=this.rightNode.cloneDeep();return new Zn(t,r,this.comparator)}};ur.createEquationFromString=function(e,t){const r=e.split(t);if(r.length!==2)throw Error("Expected two sides of an equation using comparator: "+t);const n=Yr.parse(r[0]),s=Yr.parse(r[1]);return new ur(n,s,t)};var Vt=ur;const ae=T;function Na(e){if(e.comparator!=="=")return!1;const t=e.leftNode,r=e.rightNode;return ae.Type.isOperator(t,"/")&&ae.Type.isOperator(r,"/")?!!(ae.Type.isConstantOrConstantFraction(t.args[0])&&ae.PolynomialTerm.isPolynomialTerm(t.args[1])&&ae.Type.isConstantOrConstantFraction(r.args[0])&&ae.Type.isConstantOrConstantFraction(r.args[1])||ae.Type.isConstantOrConstantFraction(t.args[0])&&ae.Type.isConstantOrConstantFraction(t.args[1])&&ae.Type.isConstantOrConstantFraction(r.args[0])&&ae.PolynomialTerm.isPolynomialTerm(r.args[1])):!1}var ma=Na;const ya=Mn,Sa=wo,Ea=Do,Oa=vn,_a=oa,Ia=Hn,da=pa,Ra=fa,Pa=Ca,wa=Cr,Fa=ma;var pe={canFindRoots:Sa,canAddLikeTerms:ya,canMultiplyLikeTermConstantNodes:Ea,canMultiplyLikeTermPolynomialNodes:Oa,canMultiplyLikeTermsNthRoots:_a,canRearrangeCoefficient:Ia,canSimplifyPolynomialTerms:da,hasUnsupportedNodes:Ra,isQuadratic:Pa,resolvesToConstant:wa,canCrossMultiplication:Fa};const Ze=se,Ma=An,ie=y,La=ye,Ce=X,l=T,kr=[Aa,Da,$a,Ua];function va(e){let t,r=0,n=0,s=0;for(const a of e.args)if(l.Type.isConstant(a))s=La(a);else if(l.PolynomialTerm.isPolynomialTerm(a)){const i=new l.PolynomialTerm(a),c=i.getExponentNode(!0);if(c.value==="2"||c.value===2)t=i.getSymbolNode(),r=i.getCoeffValue();else if(c.value==="1"||c.value===1)n=i.getCoeffValue();else return l.Status.noChange(e)}else return l.Status.noChange(e);if(!t||!r)return l.Status.noChange(e);let o=!1;r<0&&(o=!0,r=-r,n=-n,s=-s);for(let a=0;a<kr.length;a++){const i=kr[a](e,t,r,n,s,o);if(i.hasChanged())return i}return l.Status.noChange(e)}function Aa(e,t,r,n,s,o){if(!n||s)return l.Status.noChange(e);const a=Ze.gcd(r,n),i=l.Creator.constant(a),c=l.Creator.constant(r/a),u=l.Creator.constant(n/a),C=l.Creator.polynomialTerm(t,null,i),h=l.Creator.polynomialTerm(t,null,c),N=l.Creator.parenthesis(l.Creator.operator("+",[h,u]));let m=l.Creator.operator("*",[C,N],!0);return o&&(m=Ce.negate(m)),l.Status.nodeChanged(ie.FACTOR_SYMBOL,e,m)}function Da(e,t,r,n,s,o){if(n||!s)return l.Status.noChange(e);const a=Ze.gcd(r,s);r=r/a,s=s/a;const i=Math.sqrt(Math.abs(r)),c=Math.sqrt(Math.abs(s));if(Number.isInteger(i)&&Number.isInteger(c)&&s<0){const u=l.Creator.constant(i),C=l.Creator.constant(c),h=l.Creator.polynomialTerm(t,null,u),N=l.Creator.parenthesis(l.Creator.operator("+",[h,C])),m=l.Creator.parenthesis(l.Creator.operator("-",[h,C]));let $=l.Creator.operator("*",[N,m],!0);if(a!==1){const k=l.Creator.constant(a);$=l.Creator.operator("*",[k,$],!0)}return o&&($=Ce.negate($)),l.Status.nodeChanged(ie.FACTOR_DIFFERENCE_OF_SQUARES,e,$)}return l.Status.noChange(e)}function $a(e,t,r,n,s,o){if(!n||!s)return l.Status.noChange(e);const a=Ze.gcd(r,n,s);r=r/a,s=s/a;const i=Math.sqrt(Math.abs(r));let c=Math.sqrt(Math.abs(s));n<0&&(c=c*-1);const u=2*i*c;if(Number.isInteger(i)&&Number.isInteger(c)&&n/a===u){const C=l.Creator.constant(i),h=l.Creator.constant(c),N=l.Creator.polynomialTerm(t,null,C),m=l.Creator.parenthesis(l.Creator.operator("+",[N,h])),$=l.Creator.constant(2);let k=l.Creator.operator("^",[m,$]);if(a!==1){const we=l.Creator.constant(a);k=l.Creator.operator("*",[we,k],!0)}return o&&(k=Ce.negate(k)),l.Status.nodeChanged(ie.FACTOR_PERFECT_SQUARE,e,k)}return l.Status.noChange(e)}function Ua(e,t,r,n,s,o){let a;if(n&&s){const i=Ze.gcd(r,n,s),c=l.Creator.constant(i);r=r/i,n=n/i,s=s/i;const u=r*s,C=Ma.getFactorPairs(u,!0);for(const h of C)if(h[0]+h[1]===n){const N=[];let m;const $=l.Creator.constant(r),k=l.Creator.constant(n),we=l.Creator.constant(s),jt=l.Creator.polynomialTerm(t,l.Creator.constant(2),$),As=l.Creator.polynomialTerm(t,null,k);o&&(a=l.Creator.operator("+",[jt,As,we],!0),a=Ce.negate(a),m=l.Status.nodeChanged(ie.REARRANGE_COEFF,e,a),N.push(m),a=l.Status.resetChangeGroups(m.newNode));const Qt=h[0],qt=h[1],Ds=l.Creator.constant(Qt),$s=l.Creator.constant(qt),_r=l.Creator.polynomialTerm(t,null,Ds),Ir=l.Creator.polynomialTerm(t,null,$s);a=l.Creator.operator("+",[jt,_r,Ir,we],!0),o&&(a=Ce.negate(a)),m=l.Status.nodeChanged(ie.BREAK_UP_TERM,e,a),N.push(m),a=l.Status.resetChangeGroups(m.newNode);const Us=l.Creator.parenthesis(l.Creator.operator("+",[jt,_r])),dr=l.Creator.parenthesis(l.Creator.operator("+",[Ir,we]));a=l.Creator.operator("+",[Us,dr],!0),o&&(a=Ce.negate(a)),m=l.Status.nodeChanged(ie.COLLECT_LIKE_TERMS,e,a),N.push(m),a=l.Status.resetChangeGroups(m.newNode);const Wt=l.Creator.constant(Ze.gcd(r,Qt)),bs=l.Creator.constant(r/Wt),Bs=l.Creator.constant(Qt/Wt),Rr=l.Creator.polynomialTerm(t,null,Wt),Gs=l.Creator.polynomialTerm(t,null,bs),Nt=l.Creator.parenthesis(l.Creator.operator("+",[Gs,Bs])),Pr=l.Creator.operator("*",[Rr,Nt],!0);a=l.Creator.operator("+",[Pr,dr],!0),o&&(a=Ce.negate(a)),m=l.Status.nodeChanged(ie.FACTOR_SYMBOL,e,a),N.push(m),a=l.Status.resetChangeGroups(m.newNode);let Kt=Ze.gcd(s,qt);qt<0&&(Kt=Kt*-1);const wr=l.Creator.constant(Kt),Fr=l.Creator.parenthesis(l.Creator.operator("+",[Rr,wr])),xs=l.Creator.operator("*",[wr,Nt],!0);return a=l.Creator.operator("+",[Pr,xs],!0),o&&(a=Ce.negate(a)),m=l.Status.nodeChanged(ie.FACTOR_SYMBOL,e,a),N.push(m),a=l.Status.resetChangeGroups(m.newNode),i===1?a=l.Creator.operator("*",[Nt,Fr],!0):a=l.Creator.operator("*",[c,Nt,Fr],!0),o&&(a=Ce.negate(a)),m=l.Status.nodeChanged(ie.FACTOR_SUM_PRODUCT_RULE,e,a),N.push(m),a=l.Status.resetChangeGroups(m.newNode),l.Status.nodeChanged(ie.FACTOR_SUM_PRODUCT_RULE,e,a,!0,N)}}return l.Status.noChange(e)}var ba=va;const jn={};jn.appendToArrayInObject=function(e,t,r){return e[t]?e[t].push(r):e[t]=[r],e};var Ba=jn;const Hr=We,Ga=y,_=T,xa=Yt,Y=Ba,K="constant",Ie="constantFraction",Ya="nthRoot",je="other",Dt={};Dt.canCollectLikeTerms=function(e){if(!(_.Type.isOperator(e,"+")||_.Type.isOperator(e,"*")))return!1;let t;if(e.op==="+")t=Qn(e);else if(e.op==="*")t=qn(e);else throw Error("Operation not supported: "+e.op);const r=Object.keys(t),n=r.filter(s=>s!==je);return r.length>1&&n.some(s=>t[s].length>1)};Dt.collectLikeTerms=function(e){if(!Dt.canCollectLikeTerms(e))return _.Status.noChange(e);const t=e.op;let r=[];if(t==="+")r=Qn(e);else if(t==="*")r=qn(e);else throw Error("Operation not supported: "+t);const n=Object.keys(r).filter(i=>i!==K&&i!==Ie&&i!==je).sort(Ha);r[K]&&(t==="+"&&n.push(K),t==="*"&&n.unshift(K)),r[Ie]&&n.push(Ie);let s=[],o=1;n.forEach(i=>{const c=r[i];if(c.length===1){const u=c[0].cloneDeep();u.changeGroup=o,s.push(u)}else{const u=_.Creator.parenthesis(_.Creator.operator(t,c)).cloneDeep();u.changeGroup=o,s.push(u)}c.forEach(u=>{u.changeGroup=o}),o++}),r[je]&&(s=s.concat(r[je]));const a=e.cloneDeep();return a.args=s,_.Status.nodeChanged(Ga.COLLECT_LIKE_TERMS,e,a,!1)};function $t(e,t,r){const n=new t(e);let s=Hr.ascii(n.getBaseNode());if(r==="+"){const o=Hr.ascii(n.getExponentNode(!0));s+="^"+o}return s}function Qn(e){let t={};for(let r=0;r<e.args.length;r++){const n=e.args[r];if(_.PolynomialTerm.isPolynomialTerm(n)){const s=$t(n,_.PolynomialTerm,"+");t=Y.appendToArrayInObject(t,s,n)}else if(_.NthRootTerm.isNthRootTerm(n)){const s=$t(n,_.NthRootTerm,"+");t=Y.appendToArrayInObject(t,s,n)}else if(_.Type.isIntegerFraction(n))t=Y.appendToArrayInObject(t,Ie,n);else if(_.Type.isConstant(n))t=Y.appendToArrayInObject(t,K,n);else if(_.Type.isOperator(e)||_.Type.isFunction(e)||_.Type.isParenthesis(e)||_.Type.isUnaryMinus(e))t=Y.appendToArrayInObject(t,je,n);else throw Error("Unsupported node type: "+n.type)}if(t[K]&&t[K].length===1&&t[Ie]&&t[Ie].length===1){const r=t[Ie][0];t=Y.appendToArrayInObject(t,K,r),delete t[Ie]}return t}function qn(e){let t={};for(let r=0;r<e.args.length;r++){let n=e.args[r];if(_.Type.isUnaryMinus(n)&&(t=Y.appendToArrayInObject(t,K,_.Creator.constant(-1)),n=n.args[0]),_.PolynomialTerm.isPolynomialTerm(n))t=ka(t,n);else if(_.Type.isFunction(n,"nthRoot"))t=Va(t,n);else if(_.Type.isIntegerFraction(n))t=Y.appendToArrayInObject(t,K,n);else if(_.Type.isConstant(n))t=Y.appendToArrayInObject(t,K,n);else if(_.Type.isOperator(e)||_.Type.isFunction(e)||_.Type.isParenthesis(e)||_.Type.isUnaryMinus(e))t=Y.appendToArrayInObject(t,je,n);else throw Error("Unsupported node type: "+n.type)}return t}function Va(e,t){const n=xa.getRootNode(t).value;return e=Y.appendToArrayInObject(e,Ya+n,t),e}function ka(e,t){const r=new _.PolynomialTerm(t);let n;if(!r.hasCoeff())n=$t(t,_.PolynomialTerm,"*"),e=Y.appendToArrayInObject(e,n,t);else{const s=r.getCoeffNode();let o=r.getSymbolNode();r.getExponentNode()&&(o=_.Creator.operator("^",[o,r.getExponentNode()])),e=Y.appendToArrayInObject(e,K,s),n=$t(o,_.PolynomialTerm,"*"),e=Y.appendToArrayInObject(e,n,o)}return e}function Ha(e,t){if(e===t)return 0;if(e.indexOf("^")===-1)return e<t?-1:1;{const r=e.split("^")[0],n=e.split("^")[1],s=t.split("^")[0],o=t.split("^")[1];return r!==s?r<s?-1:1:n>o?-1:1}}var Wn=Dt;const Xr=pe,Xa=Wn,F=T;function Za(e,t=!1){if(t)for(;F.Type.isParenthesis(e);)e=e.content;return te(e)}function te(e){if(F.Type.isOperator(e))return ja(e);if(F.Type.isFunction(e))return Qa(e);if(F.Type.isParenthesis(e))return qa(e);if(F.Type.isConstant(e,!0)||F.Type.isSymbol(e))return e;if(F.Type.isUnaryMinus(e)){const t=e.args[0];return e.args[0]=te(t),e}else throw Error("Unsupported node type: "+e.type)}function ja(e){if(e.op==="^"&&F.Type.isParenthesis(e.args[0])){const t=e.args[0];if(F.Type.isOperator(t.content))return t.content=te(t.content),e.args[1]=te(e.args[1]),e}if(e.args.forEach((t,r)=>{e.args[r]=te(t)}),"+-".includes(e.op)&&e.args.length===2){const[t,r]=e.args;if(F.Type.isParenthesis(r)&&F.Type.isOperator(r.content)&&"*/".includes(r.content.op))return e.args[1]=r.content,e}return e.op==="+"?e.args.forEach((t,r)=>{F.Type.isParenthesis(t)&&!Zr(t.content)&&(e.args[r]=t.content)}):e.op==="-"&&F.Type.isParenthesis(e.args[0])&&!Zr(e.args[0].content)&&(e.args[0]=e.args[0].content),e}function Qa(e){return e.args.forEach((t,r)=>{F.Type.isParenthesis(t)&&(t=t.content),e.args[r]=te(t)}),e}function qa(e){if(F.PolynomialTerm.isPolynomialTerm(e.content))e.content.args&&e.content.args.forEach((t,r)=>{e.content.args[r]=te(t)}),e=e.content;else if(F.Type.isConstant(e.content,!0)||F.Type.isIntegerFraction(e.content)||F.Type.isSymbol(e.content))e=e.content;else if(F.Type.isFunction(e.content))e=e.content,e=te(e);else if(F.Type.isOperator(e.content))e.content=te(e.content),e.content.op==="^"&&(e=e.content);else if(F.Type.isParenthesis(e.content))e=te(e.content);else if(F.Type.isUnaryMinus(e.content))e.content=te(e.content);else throw Error("Unsupported node type: "+e.content.type);return e}function Zr(e){return Xa.canCollectLikeTerms(e)||Xr.resolvesToConstant(e)||Xr.canSimplifyPolynomialTerms(e)}var kt=Za;const jr=pe,Wa=ba,Ka=ht,za=kt;function Ja(e,t=!1){if(t&&console.log(`

Factoring: `+print.ascii(e,!1,!0)),jr.hasUnsupportedNodes(e))return[];let r;const n=[];return e=Ka(e),e=za(e,!0),jr.isQuadratic(e)&&(r=Wa(e),r.hasChanged()&&n.push(r)),n}var Kn=Ja;const ei=se,ti=Kn;function ri(e,t=!1){let r;try{r=ei.parse(e)}catch{return[]}return r?ti(r,t):[]}var ni=ri;const J=T,mr={};mr.preOrder=function(e){return function(t){return ct(e,t,!0)}};mr.postOrder=function(e){return function(t){return ct(e,t,!1)}};function ct(e,t,r){let n;if(r&&(n=e(t),n.hasChanged()))return n;if(J.Type.isConstant(t)||J.Type.isSymbol(t))return J.Status.noChange(t);if(J.Type.isUnaryMinus(t)){if(n=ct(e,t.args[0],r),n.hasChanged())return J.Status.childChanged(t,n)}else if(J.Type.isOperator(t)||J.Type.isFunction(t))for(let s=0;s<t.args.length;s++){const o=t.args[s],a=ct(e,o,r);if(a.hasChanged())return J.Status.childChanged(t,a,s)}else if(J.Type.isParenthesis(t)){if(n=ct(e,t.content,r),n.hasChanged())return J.Status.childChanged(t,n)}else throw Error("Unsupported node type: "+t);return r?J.Status.noChange(t):e(t)}var ge=mr;const Qr=y,zn=ye,ee=T,si=ge,oi=si.postOrder(ai);function ai(e){if(!ee.Type.isOperator(e)||!e.args.every(t=>ee.Type.isConstant(t,!0)))return ee.Status.noChange(e);if(e.args.forEach((t,r)=>{e.args[r]=ee.Creator.constant(zn(t))}),ee.Type.isIntegerFraction(e)){const t=parseInt(e.args[0]),r=parseInt(e.args[1]);if(t%r===0){const n=ee.Creator.constant(t/r);return ee.Status.nodeChanged(Qr.SIMPLIFY_ARITHMETIC,e,n)}else return ee.Status.noChange(e)}else{const t=ii(e),r=ee.Creator.constant(t);return ee.Status.nodeChanged(Qr.SIMPLIFY_ARITHMETIC,e,r)}}function ii(e){let t=zn(e);return Math.abs(t)<1?t=parseFloat(t.toPrecision(4)):t=parseFloat(t.toFixed(4)),t}var Tt=oi;const Ht=y,E=T;function ci(e){if(!E.MixedNumber.isMixedNumber(e))return E.Status.noChange(e);const t=[];let r=e.cloneDeep();const n=E.MixedNumber.getWholeNumberValue(e),s=E.MixedNumber.getNumeratorValue(e),o=E.MixedNumber.getDenominatorValue(e),a=E.MixedNumber.isNegativeMixedNumber(e);let i=ui(r,n,s,o,a);return t.push(i),r=E.Status.resetChangeGroups(i.newNode),i=li(r,n,s,o,a),t.push(i),r=E.Status.resetChangeGroups(i.newNode),i=pi(r,n,s,o,a),t.push(i),r=E.Status.resetChangeGroups(i.newNode),E.Status.nodeChanged(Ht.CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION,e,r,!0,t)}function ui(e,t,r,n,s){const o=E.Creator.parenthesis(E.Creator.operator("*",[E.Creator.constant(t),E.Creator.constant(n)])),a=E.Creator.operator("+",[o,E.Creator.constant(r)]);e.args[0].args[0].changeGroup=1,a.changeGroup=1;const i=E.Creator.constant(n);let c=E.Creator.operator("/",[a,i]);return s&&(c=E.Creator.unaryMinus(c)),E.Status.nodeChanged(Ht.IMPROPER_FRACTION_NUMERATOR,e,c,!1)}function li(e,t,r,n,s){const o=E.Creator.operator("+",[E.Creator.constant(t*n),E.Creator.constant(r)]);e.args[0].changeGroup=1,o.changeGroup=1;const a=E.Creator.constant(n);let i=E.Creator.operator("/",[o,a]);return s&&(i=E.Creator.unaryMinus(i)),E.Status.nodeChanged(Ht.SIMPLIFY_ARITHMETIC,e,i,!1)}function pi(e,t,r,n,s){const o=E.Creator.constant(t*n+r);e.args[0].changeGroup=1,o.changeGroup=1;const a=E.Creator.constant(n);let i=E.Creator.operator("/",[o,a]);return s&&(i=E.Creator.unaryMinus(i)),E.Status.nodeChanged(Ht.SIMPLIFY_ARITHMETIC,e,i,!1)}var Jn=ci;const gi=pe,fi=y,et=T;function hi(e){if(!gi.canRearrangeCoefficient(e))return et.Status.noChange(e);let t=e.cloneDeep();const r=new et.PolynomialTerm(t.args[0]),n=et.Type.isParenthesis(t.args[1])?t.args[1].content:t.args[1],s=r.getExponentNode();return t=et.Creator.polynomialTerm(r.getSymbolNode(),s,n),et.Status.nodeChanged(fi.REARRANGE_COEFF,e,t)}var yr=hi;const Ti=y,tt=T;function Ci(e){if(e.op!=="^")return tt.Status.noChange(e);const t=e.args[1];if(tt.Type.isConstant(t)&&t.value===0){const r=tt.Creator.constant(1);return tt.Status.nodeChanged(Ti.REDUCE_EXPONENT_BY_ZERO,e,r)}else return tt.Status.noChange(e)}var es=Ci;const Ni=y,Me=T;function mi(e){if(e.op!=="*")return Me.Status.noChange(e);if(e.args.findIndex(r=>Me.Type.isConstant(r)&&r.value===0?!0:Me.PolynomialTerm.isPolynomialTerm(r)?new Me.PolynomialTerm(r).getCoeffValue()===0:!1)>=0){const r=Me.Creator.constant(0);return Me.Status.nodeChanged(Ni.MULTIPLY_BY_ZERO,e,r)}else return Me.Status.noChange(e)}var ts=mi;const yi=y,St=T;function Si(e){if(e.op!=="/")return St.Status.noChange(e);if(e.args[0].value===0){const t=St.Creator.constant(0);return St.Status.nodeChanged(yi.REDUCE_ZERO_NUMERATOR,e,t)}else return St.Status.noChange(e)}var rs=Si;const Ei=y,Et=T;function Oi(e){if(e.op!=="+")return Et.Status.noChange(e);const t=e.args.findIndex(n=>Et.Type.isConstant(n)&&n.value===0);let r=e.cloneDeep();return t>=0?(r.args.splice(t,1),r.args.length===1&&(r=r.args[0]),Et.Status.nodeChanged(Ei.REMOVE_ADDING_ZERO,e,r)):Et.Status.noChange(e)}var ns=Oi;const Jt=y,qr=X,Se=T;function _i(e){if(e.op!=="/")return Se.Status.noChange(e);const t=e.args[1];if(!Se.Type.isConstant(t))return Se.Status.noChange(e);let r=e.args[0].cloneDeep();if(parseFloat(t.value)===-1){Se.Type.isOperator(r)&&(r=Se.Creator.parenthesis(r));const n=qr.isNegative(r)?Jt.RESOLVE_DOUBLE_MINUS:Jt.DIVISION_BY_NEGATIVE_ONE;return r=qr.negate(r),Se.Status.nodeChanged(n,e,r)}else return parseFloat(t.value)===1?Se.Status.nodeChanged(Jt.DIVISION_BY_ONE,e,r):Se.Status.noChange(e)}var ss=_i;const Ii=pe,di=y,er=T;function Ri(e){if(e.op==="^"&&Ii.resolvesToConstant(e.args[1])&&er.Type.isConstant(e.args[0])&&e.args[0].value===1){const t=e.args[0].cloneDeep();return er.Status.nodeChanged(di.REMOVE_EXPONENT_BASE_ONE,e,t)}return er.Status.noChange(e)}var os=Ri;const Pi=y,tr=T;function wi(e){if(e.op==="^"&&tr.Type.isConstant(e.args[1])&&e.args[1].value===1){const t=e.args[0].cloneDeep();return tr.Status.nodeChanged(Pi.REMOVE_EXPONENT_BY_ONE,e,t)}return tr.Status.noChange(e)}var as=wi;const Fi=y,Mi=X,Ee=T;function Li(e){if(e.op!=="*")return Ee.Status.noChange(e);const t=e.args.findIndex(i=>Ee.Type.isConstant(i)&&i.value===-1),r=e.args.findIndex(i=>Ee.Type.isUnaryMinus(i)&&Ee.Type.isConstant(i.args[0])&&i.args[0].value===1);if(t<0&&r<0)return Ee.Status.noChange(e);const n=t>=0?t:r;let s;n+1===e.args.length?s=n-1:s=n+1;let o=e.args[s];if(Ee.Type.isConstant(o))return Ee.Status.noChange(e);let a=e.cloneDeep();return o=Mi.negate(o.cloneDeep()),a.args[s]=o,a.args.splice(n,1),a.args.length===1&&(a=a.args[0]),Ee.Status.nodeChanged(Fi.REMOVE_MULTIPLYING_BY_NEGATIVE_ONE,e,a)}var is=Li;const vi=y,Ot=T;function Ai(e){if(e.op!=="*")return Ot.Status.noChange(e);const t=e.args.findIndex(r=>Ot.Type.isConstant(r)&&r.value===1);if(t>=0){let r=e.cloneDeep();return r.args.splice(t,1),r.args.length===1&&(r=r.args[0]),Ot.Status.nodeChanged(vi.REMOVE_MULTIPLYING_BY_ONE,e,r)}return Ot.Status.noChange(e)}var cs=Ai;const Le=y,R=T;function Di(e){if(R.Type.isOperator(e)&&e.op==="*"&&R.Type.isUnaryMinus(e.args[0])&&R.Type.isConstant(e.args[0].args[0])){const r=e.cloneDeep();return r.args[0]=R.Creator.constant(e.args[0].args[0].value*-1),R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,r)}if(!R.Type.isUnaryMinus(e))return R.Status.noChange(e);const t=e.args[0];if(R.Type.isUnaryMinus(t)){const r=t.args[0].cloneDeep();return R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,r)}else if(R.Type.isConstant(t)){const r=t.cloneDeep();return r.value=-1*r.value,R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,r)}else if(R.Type.isParenthesis(t)){const n=t.content;if(R.Type.isUnaryMinus(n)&&R.Type.isParenthesis(n.args[0])){const s=R.Creator.parenthesis(n.args[0].content);return R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,s)}else if(R.Type.isUnaryMinus(n)){const s=R.Creator.parenthesis(n.args[0]);return R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,s)}else if(R.Type.isConstant(n)){const s=R.Creator.constant(n.value*-1);return R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,s)}else if(R.Type.isSymbol(n)){const s=R.Creator.symbol(n.name);return R.Status.nodeChanged(Le.RESOLVE_DOUBLE_MINUS,e,s)}}return R.Status.noChange(e)}var us=Di;const $i=T,Ui=ge,bi=Jn,Bi=yr,Gi=es,xi=ts,Yi=rs,Vi=ns,ki=ss,Hi=os,Xi=as,Zi=is,ji=cs,Qi=us,Wr=[bi,xi,Yi,Gi,Xi,Hi,Qi,Vi,ji,Zi,ki,Bi],qi=Ui.preOrder(Wi);function Wi(e){for(let t=0;t<Wr.length;t++){const r=Wr[t](e);if(r.hasChanged())return r;e=r.newNode}return $i.Status.noChange(e)}var Ki=qi;const zi=y,fe=T,Ji=ge,ec=Ji.postOrder(tc);function tc(e){if(!fe.Type.isOperator(e)||e.op!=="/")return fe.Status.noChange(e);let t=e.args[0];if(fe.Type.isParenthesis(t)&&(t=t.content),!fe.Type.isOperator(t)||t.op!=="+")return fe.Status.noChange(e);const r=[],n=e.args[1];t.args.forEach(o=>{const a=fe.Creator.operator("/",[o,n]);a.changeGroup=1,r.push(a)});let s=fe.Creator.operator("+",r);return s=fe.Creator.parenthesis(s),e.changeGroup=1,fe.Status.nodeChanged(zi.BREAK_UP_FRACTION,e,s,!1)}var rc=ec;const nc=se,Sr=y,Kr=ye,L=T;function sc(e){if(!L.Type.isOperator(e)||e.op!=="/"||!L.Type.isIntegerFraction(e,!0))return L.Status.noChange(e);const t=[];let r=e.cloneDeep();const n=parseInt(Kr(e.args[0])),s=parseInt(Kr(e.args[1]));let o=nc.gcd(n,s);if(s<0&&(o*=-1),o===1)return L.Status.noChange(e);let a=oc(r,o,n,s);return t.push(a),r=L.Status.resetChangeGroups(a.newNode),a=ac(r,o,n,s),t.push(a),r=L.Status.resetChangeGroups(a.newNode),L.Status.nodeChanged(Sr.SIMPLIFY_FRACTION,e,r,!0,t)}function oc(e,t,r,n){let s=e.cloneDeep();const o=L.Creator.constant(t);o.changeGroup=1;const a=L.Creator.parenthesis(L.Creator.operator("*",[L.Creator.constant(r/t),o])),i=L.Creator.parenthesis(L.Creator.operator("*",[L.Creator.constant(n/t),o]));return s=L.Creator.operator("/",[a,i]),L.Status.nodeChanged(Sr.FIND_GCD,e,s,!1)}function ac(e,t,r,n){let s;const o=L.Creator.constant(r/t),a=L.Creator.constant(n/t);return parseFloat(a.value)===1?s=o:s=L.Creator.operator("/",[o,a]),L.Status.nodeChanged(Sr.CANCEL_GCD,e,s,!1)}var Xt=sc;const ic=Xt,cc=se,Be=y,Zt=ye,S=T;function uc(e){let t=e.cloneDeep();if(!S.Type.isOperator(e)||e.op!=="+"||!e.args.every(o=>S.Type.isIntegerFraction(o,!0)))return S.Status.noChange(e);const r=e.args.map(o=>parseFloat(Zt(o.args[1]))),n=[];let s;return r.every(o=>o===r[0])||(s=fc(t),n.push(s),t=S.Status.resetChangeGroups(s.newNode),s=hc(t),n.push(s),t=S.Status.resetChangeGroups(s.newNode),s=Tc(t),n.push(s),t=S.Status.resetChangeGroups(s.newNode)),s=lc(t),n.push(s),t=S.Status.resetChangeGroups(s.newNode),s=pc(t),n.push(s),t=S.Status.resetChangeGroups(s.newNode),s=gc(t),s.hasChanged()&&(n.push(s),t=S.Status.resetChangeGroups(s.newNode)),s=ic(t),s.hasChanged()&&(n.push(s),t=S.Status.resetChangeGroups(s.newNode)),S.Status.nodeChanged(Be.ADD_FRACTIONS,e,t,!0,n)}function lc(e){let t=e.cloneDeep();const r=t.args[0].args[1],n=[];t.args.forEach(o=>{n.push(o.args[0])});const s=S.Creator.parenthesis(S.Creator.operator("+",n));return t=S.Creator.operator("/",[s,r]),S.Status.nodeChanged(Be.COMBINE_NUMERATORS,e,t)}function pc(e){const t=e.cloneDeep();return t.args[0]=S.Creator.constant(Zt(t.args[0])),S.Status.nodeChanged(Be.ADD_NUMERATORS,e,t)}function gc(e){let t=e.cloneDeep();return t.args[0].value==="0"?(t=S.Creator.constant(0),S.Status.nodeChanged(Be.REDUCE_ZERO_NUMERATOR,e,t)):S.Status.noChange(e)}function fc(e){const t=e.cloneDeep(),r=t.args.map(s=>parseFloat(s.args[1].value)),n=cc.lcm(...r);return t.args.forEach((s,o)=>{const a=n/r[o];if(a!==1){const i=S.Creator.constant(a),c=S.Creator.parenthesis(S.Creator.operator("*",[s.args[0],i])),u=S.Creator.parenthesis(S.Creator.operator("*",[s.args[1],i]));t.args[o]=S.Creator.operator("/",[c,u])}}),S.Status.nodeChanged(Be.COMMON_DENOMINATOR,e,t)}function hc(e){const t=e.cloneDeep();return t.args.map(r=>{r.args[1]=S.Creator.constant(Zt(r.args[1]))}),S.Status.nodeChanged(Be.MULTIPLY_DENOMINATORS,e,t)}function Tc(e){const t=e.cloneDeep();return t.args.map(r=>{r.args[0]=S.Creator.constant(Zt(r.args[0]))}),S.Status.nodeChanged(Be.MULTIPLY_NUMERATORS,e,t)}var Er=uc;const Cc=Er,rt=y,zr=ye,D=T;function Nc(e){if(!D.Type.isOperator(e)||e.op!=="+"||e.args.length!==2)return D.Status.noChange(e);const t=e.args[0],r=e.args[1];let n,s;if(D.Type.isConstant(t))if(D.Type.isIntegerFraction(r))n=t,s=r;else return D.Status.noChange(e);else if(D.Type.isConstant(r))if(D.Type.isIntegerFraction(t))n=r,s=t;else return D.Status.noChange(e);else return D.Status.noChange(e);let o=e.cloneDeep(),a=[],i,c,u;if(Number.isInteger(parseFloat(n.value))){const h=s.args[1],N=parseInt(h),m=parseInt(n.value),$=D.Creator.constant(m*N);i=D.Creator.operator("/",[$,h]),c=s,u=rt.CONVERT_INTEGER_TO_FRACTION}else{let h=zr(s);h<1?h=parseFloat(h.toPrecision(4)):h=parseFloat(h.toFixed(4)),c=D.Creator.constant(h),i=n,u=rt.DIVIDE_FRACTION_FOR_ADDITION}if(D.Type.isConstant(t)?(o.args[0]=i,o.args[1]=c):(o.args[0]=c,o.args[1]=i),a.push(D.Status.nodeChanged(u,e,o)),o=D.Status.resetChangeGroups(o),u===rt.CONVERT_INTEGER_TO_FRACTION){const h=Cc(o);a=a.concat(h.substeps)}else{const h=D.Creator.constant(zr(o));a.push(D.Status.nodeChanged(rt.SIMPLIFY_ARITHMETIC,o,h))}const C=a[a.length-1];return o=D.Status.resetChangeGroups(C.newNode),D.Status.nodeChanged(rt.SIMPLIFY_ARITHMETIC,e,o,!0,a)}var ls=Nc;const mc=ls,Jr=Er,en=Tt,ps=y,w=T;function gs(e){if(w.Type.isParenthesis(e)&&(e=e.content),!w.Type.isOperator(e)||e.op!=="+"||e.args.some(i=>!w.Type.isConstantOrConstantFraction(i)))return w.Status.noChange(e);const t=[en,Jr,mc];for(let i=0;i<t.length;i++){const c=t[i](e);if(c.hasChanged()&&w.Type.isConstantOrConstantFraction(c.newNode))return c}let r=e.cloneDeep();const n=[];let s;s=yc(r),n.push(s),r=w.Status.resetChangeGroups(s.newNode);const o=r.args[0],a=r.args[1];if(w.Type.isParenthesis(o)){const i=o.content,c=en(i);s=w.Status.childChanged(r,c,0),n.push(s),r=w.Status.resetChangeGroups(s.newNode)}if(w.Type.isParenthesis(a)){const i=a.content,c=Jr(i);s=w.Status.childChanged(r,c,1),n.push(s),r=w.Status.resetChangeGroups(s.newNode)}return s=gs(r),n.push(s),r=w.Status.resetChangeGroups(s.newNode),w.Status.nodeChanged(ps.SIMPLIFY_ARITHMETIC,e,r,!0,n)}function yc(e){let t=e.args.filter(w.Type.isIntegerFraction),r=e.args.filter(w.Type.isConstant);if(t.length===0||r.length===0)throw Error("expected both integer fractions and constants, got "+e);if(t.length+r.length!==e.args.length)throw Error("can only evaluate integer fractions and constants");r=r.map(s=>(s.changeGroup=1,s.cloneDeep())),r.length>1?r=w.Creator.parenthesis(w.Creator.operator("+",r)):r=r[0],t=t.map(s=>(s.changeGroup=2,s.cloneDeep())),t.length>1?t=w.Creator.parenthesis(w.Creator.operator("+",t)):t=t[0];const n=w.Creator.operator("+",[r,t]);return w.Status.nodeChanged(ps.COLLECT_LIKE_TERMS,e,n)}var Sc=gs;const fs=pe,hs=Sc,Ct=y,P=T;function Ec(e,t=!1){if(!P.Type.isOperator(e))return P.Status.noChange(e);let r;return!t&&(r=hs(e),r.hasChanged())||(r=Oc(e),r.hasChanged())||(r=_c(e),r.hasChanged())?r:P.Status.noChange(e)}function Oc(e){return fs.canAddLikeTerms.canAddLikeTermPolynomialNodes(e)?Ts(e,P.PolynomialTerm,Ct.ADD_POLYNOMIAL_TERMS):P.Status.noChange(e)}function _c(e){return fs.canAddLikeTerms.canAddLikeTermNthRootNodes(e)?Ts(e,P.NthRootTerm,Ct.ADD_NTH_ROOTS):P.Status.noChange(e)}function Ts(e,t,r){const n=[];let s=e.cloneDeep(),o=Ic(s,t);return o.hasChanged()&&(n.push(o),s=P.Status.resetChangeGroups(o.newNode)),o=dc(s,t),o.hasChanged()&&(n.push(o),s=P.Status.resetChangeGroups(o.newNode)),o=Rc(s,t),n.push(o),s=P.Status.resetChangeGroups(o.newNode),o=Pc(s),n.push(o),s=P.Status.resetChangeGroups(o.newNode),P.Status.nodeChanged(r,e,s,!0,n)}function Ic(e,t){const r=e.cloneDeep();let n=!1,s=1;return r.args.forEach((o,a)=>{const i=new t(o);i.getCoeffValue()===1&&(r.args[a]=P.Creator.term(i.getBaseNode(),i.getExponentNode(),P.Creator.constant(1),!0),r.args[a].changeGroup=s,e.args[a].changeGroup=s,n=!0,s++)}),n?P.Status.nodeChanged(Ct.ADD_COEFFICIENT_OF_ONE,e,r,!1):P.Status.noChange(e)}function dc(e,t){const r=e.cloneDeep();let n=!1,s=1;return r.args.forEach((o,a)=>{const i=new t(o);i.getCoeffValue()===-1&&(r.args[a]=P.Creator.term(i.getBaseNode(),i.getExponentNode(),i.getCoeffNode(),!0),e.args[a].changeGroup=s,r.args[a].changeGroup=s,n=!0,s++)}),n?P.Status.nodeChanged(Ct.UNARY_MINUS_TO_NEGATIVE_ONE,e,r,!1):P.Status.noChange(e)}function Rc(e,t){let r=e.cloneDeep();const n=r.args.map(u=>new t(u)),s=n.map(u=>u.getCoeffNode(!0)),o=P.Creator.parenthesis(P.Creator.operator("+",s));o.changeGroup=1;const a=n[0],i=a.getExponentNode(),c=a.getBaseNode();return r=P.Creator.term(c,i,o),P.Status.nodeChanged(Ct.GROUP_COEFFICIENTS,e,r,!1)}function Pc(e){const t=e.cloneDeep().args[0],r=hs(t);return P.Status.childChanged(e,r,0)}var wc=Ec;const Fc=y,B=T,Mc=ge,Lc=Mc.postOrder(vc);function vc(e){if(!B.Type.isOperator(e)||e.op!=="*")return B.Status.noChange(e);const t=e.args.some(u=>B.CustomType.isFraction(u)),r=e.args.some(B.PolynomialTerm.isPolynomialTerm),n=e.args.some(Ac);if(!t||r&&!n)return B.Status.noChange(e);const s=[],o=[];e.args.forEach(u=>{if(B.CustomType.isFraction(u)){const C=B.CustomType.getFraction(u);s.push(C.args[0]),o.push(C.args[1])}else s.push(u)});const a=B.Creator.parenthesis(B.Creator.operator("*",s)),i=o.length===1?o[0]:B.Creator.parenthesis(B.Creator.operator("*",o)),c=B.Creator.operator("/",[a,i]);return B.Status.nodeChanged(Fc.MULTIPLY_FRACTIONS,e,c)}function Ac(e){if(!B.CustomType.isFraction(e))return!1;const r=B.CustomType.getFraction(e).args[1];return B.PolynomialTerm.isPolynomialTerm(r)}var Cs=Lc;const Ns=Tt,Qe=pe,lr=Ln,Dc=Cs,de=y,I=T,tn=Yt;function $c(e,t=!1){if(!I.Type.isOperator(e))return I.Status.noChange(e);let r;return!t&&!Qe.canMultiplyLikeTermConstantNodes(e)&&(r=Ns(e),r.hasChanged()||(r=Dc(e),r.hasChanged()))||(r=bc(e),r.hasChanged())?(r.changeType=de.MULTIPLY_COEFFICIENTS,r):(r=Uc(e),r.hasChanged()?r:I.Status.noChange(e))}function Uc(e){if(!Qe.canMultiplyLikeTermsNthRoots(e))return I.Status.noChange(e);let t=e.cloneDeep();const r=e.args.map(a=>tn.getRadicandNode(a)),n=I.Creator.operator("*",r),s=e.args[0],o=tn.getRootNode(s);return t=I.Creator.nthRoot(n,o),I.Status.nodeChanged(de.MULTIPLY_NTH_ROOTS,e,t,!1)}function bc(e){if(!Qe.canMultiplyLikeTermPolynomialNodes(e)&&!Qe.canMultiplyLikeTermConstantNodes(e))return I.Status.noChange(e);const t=[];let r=e.cloneDeep(),n=Bc(r);n.hasChanged()&&(t.push(n),r=I.Status.resetChangeGroups(n.newNode)),Qe.canMultiplyLikeTermConstantNodes(e)?n=Gc(r):n=xc(r),t.push(n),r=I.Status.resetChangeGroups(n.newNode);const s=r.args[1].content,o=Ns(s);return o.hasChanged()&&(n=I.Status.childChanged(r,o,1),t.push(n),r=I.Status.resetChangeGroups(n.newNode)),t.length===1?t[0]:I.Status.nodeChanged(de.MULTIPLY_POLYNOMIAL_TERMS,e,r,!0,t)}function Bc(e){const t=e.cloneDeep();let r=!1,n=1;return Qe.canMultiplyLikeTermConstantNodes(e)?t.args.forEach((s,o)=>{if(I.Type.isConstant(s)){const a=lr.getBaseNode(s),i=I.Creator.constant(1);t.args[o]=I.Creator.operator("^",[a,i]),t.args[o].changeGroup=n,e.args[o].changeGroup=n,r=!0,n++}}):t.args.forEach((s,o)=>{const a=new I.PolynomialTerm(s);a.getExponentNode()||(t.args[o]=I.Creator.polynomialTerm(a.getSymbolNode(),I.Creator.constant(1),a.getCoeffNode()),t.args[o].changeGroup=n,e.args[o].changeGroup=n,r=!0,n++)}),r?I.Status.nodeChanged(de.ADD_EXPONENT_OF_ONE,e,t,!1):I.Status.noChange(e)}function Gc(e){const t=lr.getBaseNode(e.args[0]),r=e.args.map(lr.getExponentNode),n=I.Creator.parenthesis(I.Creator.operator("+",r)),s=I.Creator.operator("^",[t,n]);return I.Status.nodeChanged(de.COLLECT_CONSTANT_EXPONENTS,e,s)}function xc(e){const t=e.args.map(a=>new I.PolynomialTerm(a)),r=t[0].getSymbolNode(),n=t.map(a=>a.getExponentNode(!0)),s=I.Creator.parenthesis(I.Creator.operator("+",n)),o=I.Creator.polynomialTerm(r,s,null);return I.Status.nodeChanged(de.COLLECT_POLYNOMIAL_EXPONENTS,e,o)}var Yc=$c;const ms=wc,Vc=pe,pr=Yc,kc=y,Hc=Wn,$e=T,Xc=ge,Zc={"+":ms,"*":pr},jc=Xc.postOrder(Qc);function Qc(e){if(e.op==="+"){const t=rn(e);return t.hasChanged()?t:ms(e,!0)}else if(e.op==="*"){if(Vc.canMultiplyLikeTermConstantNodes(e))return pr(e,!0);const t=rn(e);return t.hasChanged()?(t.newNode.implicit=!0,t):pr(e,!0)}else return $e.Status.noChange(e)}function rn(e){let t=[];const r=Hc.collectLikeTerms(e.cloneDeep());if(!r.hasChanged())return r;t.push(r);let n=$e.Status.resetChangeGroups(r.newNode);const s=qc(n);if(s.length>0){t=t.concat(s);const o=s[s.length-1];n=$e.Status.resetChangeGroups(o.newNode)}return $e.Status.nodeChanged(kc.COLLECT_AND_COMBINE_LIKE_TERMS,e,n,!0,t)}function qc(e){const t=[];let r=e.cloneDeep();for(let n=0;n<e.args.length;n++){let s=e.args[n];if(!$e.Type.isParenthesis(s))continue;s=s.content;const o=Zc[r.op](s);if(o.hasChanged()){const a=$e.Status.childChanged(r,o,n);t.push(a),r=$e.Status.resetChangeGroups(a.newNode)}}return t}var ys=jc;const Wc=Tt,Kc=ys,zc=yr,ce=y,nn=X,g=T,Jc=ge,eu=Jc.postOrder(tu);function tu(e){return g.Type.isUnaryMinus(e)?ru(e):g.Type.isOperator(e,"*")?Es(e):g.Type.isOperator(e,"^")?Ss(e):g.Status.noChange(e)}function Ss(e){if(!g.Type.isOperator(e,"^"))return g.Status.noChange(e);const t=g.Type.isParenthesis(e.args[0])?e.args[0].content:e.args[0],r=g.Type.isParenthesis(e.args[1])?e.args[1].content:e.args[1],n=parseFloat(r.value);if(!(Number.isInteger(n)&&n>1)||!g.Type.isFunction(t,"nthRoot")&&!(g.Type.isOperator(t,"+")||g.Type.isOperator(t,"*")||g.Type.isOperator(t,"/")))return g.Status.noChange(e);const s=g.Type.isFunction(t,"nthRoot")?t:e.args[0];let o;const a=[];let i;if(g.Type.isFunction(t,"nthRoot"))return o=g.Creator.operator("*",Array(parseFloat(r.value)).fill(s)),g.Status.nodeChanged(ce.EXPAND_EXPONENT,e,o,!1);if(g.Type.isOperator(t,"+")){acarre=g.Creator.operator("^",[t.args[0],r]),bcarre=g.Creator.operator("^",[t.args[1],r]),doubleproduit=g.Creator.operator("*",[g.Creator.constant(2),g.Creator.operator("*",t.args)]),o=g.Creator.operator("+",[acarre,doubleproduit,bcarre]),i=g.Status.nodeChanged(ce.EXPAND_EXPONENT,e,o,!1),a.push(i),newNode=g.Status.resetChangeGroups(i.newNode);const c=_s(newNode);return c.hasChanged()&&(i=g.Status.childChanged(newNode,c),a.push(i),newNode=g.Status.resetChangeGroups(i.newNode)),a.length===1?a[0]:g.Status.nodeChanged(ce.DISTRIBUTE,e,newNode,!1,a)}else if(g.Type.isOperator(t,"*")){for(let c=0;c<t.args.length;c++)t.args[c]=g.Creator.operator("^",[t.args[c],r]);return g.Status.nodeChanged(ce.EXPAND_EXPONENT,e,t,!1)}else if(g.Type.isOperator(t,"/")){for(let c=0;c<2;c++)t.args[c]=g.Creator.operator("^",[t.args[c],r]);return g.Status.nodeChanged(ce.EXPAND_EXPONENT,e,t,!1)}}function ru(e){if(!g.Type.isUnaryMinus(e))return g.Status.noChange(e);const t=e.args[0];if(!g.Type.isParenthesis(t))return g.Status.noChange(e);const r=t.content;if(!g.Type.isOperator(r))return g.Status.noChange(e);const n=r.cloneDeep();if(e.changeGroup=1,r.op==="*"||r.op==="/"){n.args[0]=nn.negate(n.args[0]),n.args[0].changeGroup=1;const s=g.Creator.parenthesis(n);return g.Status.nodeChanged(ce.DISTRIBUTE_NEGATIVE_ONE,e,s,!1)}else if(r.op==="+"){const s=n.args.map(a=>{const i=nn.negate(a);return i.changeGroup=1,i});n.args=s;const o=g.Creator.parenthesis(n);return g.Status.nodeChanged(ce.DISTRIBUTE_NEGATIVE_ONE,e,o,!1)}else return g.Status.noChange(e)}function Es(e){if(!g.Type.isOperator(e)||e.op!=="*")return g.Status.noChange(e);for(let t=0;t+1<e.args.length;t++){if(!Ut(e.args[t])&&!Ut(e.args[t+1]))continue;let r=e.cloneDeep();const n=[];let s;const o=nu(r.args[t],r.args[t+1]);if(e.args[t].changeGroup=1,e.args[t+1].changeGroup=1,o.changeGroup=1,r.args.length>2?(r.args.splice(t,2,o),r.args[t].changeGroup=1):(r=o,r.changeGroup=1),s=g.Status.nodeChanged(ce.DISTRIBUTE,e,r,!1),n.push(s),r=g.Status.resetChangeGroups(s.newNode),g.Type.isOperator(r,"*")){const a=on(r.args[t]);a.hasChanged()&&(s=g.Status.childChanged(r,a,t),n.push(s),r=g.Status.resetChangeGroups(s.newNode))}else if(g.Type.isParenthesis(r))s=on(r),s.hasChanged()&&(n.push(s),r=g.Status.resetChangeGroups(s.newNode));else throw Error("Unsupported node type for distribution: "+e);return n.length===1?n[0]:g.Status.nodeChanged(ce.DISTRIBUTE,e,r,!1,n)}return g.Status.noChange(e)}function nu(e,t){let r,n;Ut(e)?r=e.content.args:r=[e],Ut(t)?n=t.content.args:n=[t];const s=[];if([r,n].filter(sn).length===1){const o=sn(r),a=o?r:n,i=o?t:e;a.forEach(c=>{let u;if(Os(c)){let C=g.Creator.operator("*",[c.args[0],i]);C=g.Creator.parenthesis(C),u=g.Creator.operator("/",[C,c.args[1]])}else u=g.Creator.operator("*",[c,i]);u.changeGroup=1,s.push(u)})}else r.length>1&&n.length>1?r.forEach(o=>{const a=g.Creator.operator("*",[o,t]);a.changeGroup=1,s.push(a)}):r.forEach(o=>{n.forEach(a=>{const i=g.Creator.operator("*",[o,a]);i.changeGroup=1,s.push(i)})});return g.Creator.parenthesis(g.Creator.operator("+",s))}function sn(e){return e.filter(Os).length>0}function Os(e){return g.Type.isOperator(e,"/")}function on(e){if(!g.Type.isParenthesis(e))throw Error("expected "+e+" to be a parenthesis node");const t=_s(e.content);return t.hasChanged()?g.Status.childChanged(e,t):g.Status.noChange(e)}function _s(e){const t=[],r=[Wc,zc,Kc,Es,Ss];let n=e.cloneDeep();for(let s=0;s<n.args.length;s++)for(let o=0;o<r.length;o++){const a=r[o](n.args[s]);if(a.hasChanged()){const i=g.Status.childChanged(n,a,s);t.push(i),n=g.Status.resetChangeGroups(i.newNode)}}return t.length===0?g.Status.noChange(e):g.Status.nodeChanged(ce.SIMPLIFY_TERMS,e,n,!1,t)}function Ut(e){if(!g.Type.isParenthesis(e))return!1;const t=e.content;return g.Type.isOperator(t,"+")}var su=eu;const Is=y,V=T,ou=ge,au=ou.preOrder(iu);function iu(e){if(!V.Type.isOperator(e)||e.op!=="/")return V.Status.noChange(e);let t=cu(e);return t.hasChanged()||(t=uu(e),t.hasChanged())?t:V.Status.noChange(e)}function cu(e){let t=e.args[1];if(V.Type.isParenthesis(t)&&(t=t.content),!V.Type.isOperator(t)||t.op!=="/")return V.Status.noChange(e);const r=t.args[1],n=t.args[0],s=V.Creator.operator("/",[r,n]),o=V.Creator.operator("*",[e.args[0],s]);return V.Status.nodeChanged(Is.MULTIPLY_BY_INVERSE,e,o)}function uu(e){const t=lu(e);if(t.length>2){const r=t.shift(),n=V.Creator.parenthesis(V.Creator.operator("*",t)),s=V.Creator.operator("/",[r,n]);return V.Status.nodeChanged(Is.SIMPLIFY_DIVISION,e,s)}return V.Status.noChange(e)}function lu(e){let t=e;const r=[];for(;t.op==="/";)r.unshift(t.args[1]),t=t.args[0];return r.unshift(t),r}var pu=au;const gr=Xt,Ye=We,_t=y,rr=X,f=T;class b{constructor(t,r,n=!1){this.numerator=t,this.denominator=r,this.hasChanged=n}}function gu(e){if(!f.Type.isOperator(e)||e.op!=="/")return f.Status.noChange(e);let t=e.cloneDeep();const r=t.args[0],n=t.args[1];if(!ve(r)&&!ve(n)){const s=Ne(r,n);return s.hasChanged?(t.args[0]=s.numerator||f.Creator.constant(1),s.denominator?t.args[1]=s.denominator:t=t.args[0],f.Status.nodeChanged(_t.CANCEL_TERMS,e,t)):f.Status.noChange(e)}else if(ve(r)&&!ve(n)){const s=f.Type.isParenthesis(r)?r.content.args:r.args;for(let o=0;o<s.length;o++){const a=Ne(s[o],n);if(a.hasChanged)return a.numerator?s[o]=a.numerator:(s.splice(o,1),s.length===1&&(t.args[0]=s[0])),a.denominator?t.args[1]=a.denominator:t=t.args[0],f.Status.nodeChanged(_t.CANCEL_TERMS,e,t)}return f.Status.noChange(e)}else if(ve(n)&&!ve(r)){const s=f.Type.isParenthesis(n)?n.content.args:n.args;for(let o=0;o<s.length;o++){const a=Ne(r,s[o]);if(a.hasChanged)return t.args[0]=a.numerator||f.Creator.constant(1),a.denominator?s[o]=a.denominator:(s.splice(o,1),s.length===1&&(t.args[1]=s[0])),f.Status.nodeChanged(_t.CANCEL_TERMS,e,t)}return f.Status.noChange(e)}else{const s=f.Type.isParenthesis(r)?r.content.args:r.args,o=f.Type.isParenthesis(n)?n.content.args:n.args;for(let a=0;a<s.length;a++)for(let i=0;i<o.length;i++){const c=Ne(s[a],o[i]);if(c.hasChanged)return c.numerator?s[a]=c.numerator:(s.splice(a,1),s.length===1&&(t.args[0]=s[0])),c.denominator?o[i]=c.denominator:(o.splice(i,1),o.length===1&&(t.args[1]=o[0])),f.Status.nodeChanged(_t.CANCEL_TERMS,e,t)}return f.Status.noChange(e)}}function Ne(e,t){if(f.Type.isUnaryMinus(e)){const r=Ne(e.args[0],t);return r.numerator?rr.isNegative(r.numerator)?e=rr.negate(r.numerator):e.args[0]=r.numerator:e=f.Creator.constant(-1),t=Ne.denominator,new b(e,t,r.hasChanged)}if(f.Type.isUnaryMinus(t)){const r=Ne(e,t.args[0]);return e=r.numerator,r.denominator?t.args[0]=r.denominator:(t=r.denominator,e?e=rr.negate(e):e=f.Creator.constant(-1)),new b(e,t,r.hasChanged)}if(f.Type.isParenthesis(e)){const r=Ne(e.content,t);return r.numerator?e.content=r.numerator:e=r.numerator,t=r.denominator,new b(e,t,r.hasChanged)}if(f.Type.isParenthesis(t)){const r=Ne(e,t.content);return r.denominator?t.content=r.denominator:t=r.denominator,e=r.numerator,new b(e,t,r.hasChanged)}if(Ye.ascii(e)===Ye.ascii(t))return new b(null,null,!0);if(f.Type.isOperator(e,"^")&&f.Type.isOperator(t,"^")&&Ye.ascii(e.args[0])===Ye.ascii(t.args[0])){const r=e.args[1];let n=t.args[1];n=f.Creator.parenthesis(n);const s=f.Creator.parenthesis(f.Creator.operator("-",[r,n]));return e.args[1]=s,new b(e,null,!0)}if(f.PolynomialTerm.isPolynomialTerm(e)&&f.PolynomialTerm.isPolynomialTerm(t)){const r=new f.PolynomialTerm(e),n=new f.PolynomialTerm(t);if(r.getSymbolName()!==n.getSymbolName())return f.Type.isOperator(e,"*")&&f.Type.isOperator(t,"*")?fu(e,t):new b(e,t);const s=r.getExponentNode(!0);let o=n.getExponentNode(!0);if(Ye.ascii(s)===Ye.ascii(o))e=r.getCoeffNode();else{o=f.Creator.parenthesis(o);const a=f.Creator.parenthesis(f.Creator.operator("-",[s,o]));e=f.Creator.polynomialTerm(r.getSymbolNode(),a,r.getCoeffNode())}return t=n.getCoeffNode(),new b(e,t,!0)}if(f.Type.isConstant(e)&&f.Type.isOperator(t,"*")&&f.PolynomialTerm.isPolynomialTerm(t)){const r=new f.PolynomialTerm(t),n=r.getCoeffNode(),s=r.getSymbolNode(),o=r.getExponentNode(),a=f.Creator.operator("/",[e,n]);let i=n.cloneDeep();const c=gr(a);return c.hasChanged()?(f.Type.isConstant(c.newNode)?(e=c.newNode,i=null):[e,i]=c.newNode.args,t=f.Creator.polynomialTerm(s,o,i),new b(e,t,!0)):new b(e,t,!1)}if(f.Type.isConstant(e)&&f.Type.isConstant(t)){const r=f.Creator.operator("/",[e,t]),n=gr(r);return n.hasChanged()?f.Type.isConstant(n.newNode)?new b(n.newNode,null,!0):(f.Type.isConstant(n.newNode)?(e=n.newNode,t=null):[e,t]=n.newNode.args,new b(e,t,!0)):new b(e,t,!1)}return new b(e,t)}function ve(e){return f.Type.isParenthesis(e)?ve(e.content):f.Type.isOperator(e,"*")&&!f.PolynomialTerm.isPolynomialTerm(e)}function fu(e,t){const r=new f.PolynomialTerm(t),n=new f.PolynomialTerm(e),s=r.getCoeffNode(),o=r.getSymbolNode(),a=r.getExponentNode(),i=n.getCoeffNode(),c=n.getSymbolNode(),u=n.getExponentNode(),C=f.Creator.operator("/",[i,s]),h=gr(C);if(!h.hasChanged())return new b(e,t,!1);let N=null,m=null;f.Type.isConstant(h.newNode)?(m=f.Creator.polynomialTerm(c,u,h.newNode),N=null):(m=f.Creator.polynomialTerm(c,u,h.newNode.args[0]),N=h.newNode.args[1]);const $=f.Creator.polynomialTerm(o,a,N);return new b(m,$,!0)}var hu=gu;const an=y,It=X,nt=T;function Tu(e){if(!nt.Type.isOperator(e)||e.op!=="/")return nt.Status.noChange(e);const t=e.cloneDeep();let r=e.args[0],n=e.args[1];if(It.isNegative(n)){n=It.negate(n);const s=It.isNegative(r)?an.CANCEL_MINUSES:an.SIMPLIFY_SIGNS;r=It.negate(r);const o=nt.Creator.operator("/",[r,n]);return nt.Status.nodeChanged(s,t,o)}else return nt.Status.noChange(e)}var ds=Tu;const Cu=Tt,Nu=Xt,Oe=T;function mu(e){if(!Oe.PolynomialTerm.isPolynomialTerm(e))return Oe.Status.noChange(e);const t=new Oe.PolynomialTerm(e.cloneDeep());if(!t.hasFractionCoeff())return Oe.Status.noChange(e);const r=[Nu,Cu];for(let n=0;n<r.length;n++){const s=t.getCoeffNode(),o=r[n](s);if(o.hasChanged()){let a=Oe.Status.resetChangeGroups(o.newNode);a.value==="1"&&(a=null);const i=t.getExponentNode(),c=Oe.Creator.polynomialTerm(t.getSymbolNode(),i,a);return Oe.Status.nodeChanged(o.changeType,e,c)}}return Oe.Status.noChange(e)}var yu=mu;const Su=ls,Eu=Er,Ou=hu,_u=Xt,Iu=ds,du=yu,Ru=T,Pu=ge,cn=[Eu,Su,Iu,_u,du,Ou],wu=Pu.preOrder(Fu);function Fu(e){for(let t=0;t<cn.length;t++){const r=cn[t](e);if(r.hasChanged())return r;e=r.newNode}return Ru.Status.noChange(e)}var Mu=wu;const nr=se,un=y,sr=ye,j=T;function Lu(e){if(!j.Type.isFunction(e,"abs")||e.args.length>1)return j.Status.noChange(e);let t=e.cloneDeep();const r=t.args[0];if(j.Type.isConstant(r,!0))return t=j.Creator.constant(nr.abs(sr(r))),j.Status.nodeChanged(un.ABSOLUTE_VALUE,e,t);if(j.Type.isConstantFraction(r,!0)){const n=j.Creator.constant(nr.abs(sr(r.args[0]))),s=j.Creator.constant(nr.abs(sr(r.args[1])));return t=j.Creator.operator("/",[n,s]),j.Status.nodeChanged(un.ABSOLUTE_VALUE,e,t)}else return j.Status.noChange(e)}var vu=Lu;const Au=vu,or=T,Du=Yt,$u=ge,ln=[Du.nthRoot,Au],Uu=$u.postOrder(bu);function bu(e){if(!or.Type.isFunction(e))return or.Status.noChange(e);for(let t=0;t<ln.length;t++){const r=ln[t](e);if(r.hasChanged())return r}return or.Status.noChange(e)}var Bu=Uu;const Gu=pe,xu=T,Yu=Fn,Vu=Tt,ku=Ki,Hu=rc,Xu=ys,Zu=su,ju=pu,Qu=Mu,qu=Bu,Wu=Cs,ar=ht,fr=We,bt=kt;function Ku(e,t=!1){if(t&&console.log(`

Simplifying: `+fr.ascii(e,!1,!0)),Gu.hasUnsupportedNodes(e))return[];let r;const n=[],s=fr.ascii(e),o=20;let a=0;for(r=pn(e);r.hasChanged();)if(t&&zu(r),n.push(Rs(r)),e=Yu.resetChangeGroups(r.newNode),r=pn(e),a++===o)return console.error("Math error: Potential infinite loop for expression: "+s+", returning no steps"),[];return n}function pn(e){let t;e=ar(e),e=bt(e,!0);const r=[ku,ju,Qu,Xu,Vu,Hu,Wu,Zu,qu];for(let n=0;n<r.length;n++){if(t=r[n](e),e=bt(t.newNode,!0),t.hasChanged())return e=ar(e),t.newNode=e.cloneDeep(),t;e=ar(e)}return xu.Status.noChange(e)}function Rs(e){return e.substeps.length>0&&e.substeps.map(Rs),e.oldNode=bt(e.oldNode,!0),e.newNode=bt(e.newNode,!0),e}function zu(e){console.log(e.changeType),console.log(fr.ascii(e.newNode)+`
`),e.substeps.length>0&&(console.log(`
substeps: `),e.substeps.forEach(t=>t))}var Ps=Ku;const Ju=se,el=Ps;function tl(e,t=!1){let r;try{r=Ju.parse(e)}catch{return[]}return r?el(r,t):[]}var rl=tl;const ws=y,nl=Vt,gn=T;class le{constructor(t,r,n,s=[]){if(!n)throw Error("new equation isn't defined");if(t===void 0||typeof t!="string")throw Error("changetype isn't valid");this.changeType=t,this.oldEquation=r,this.newEquation=n,this.substeps=s}hasChanged(){return this.changeType!==ws.NO_CHANGE}}le.noChange=function(e){return new le(ws.NO_CHANGE,null,e)};le.addLeftStep=function(e,t){const r=[];t.substeps.forEach(o=>{r.push(le.addLeftStep(e,o))});let n=null;t.oldNode&&(n=e.clone(),n.leftNode=t.oldNode);const s=e.clone();return s.leftNode=t.newNode,new le(t.changeType,n,s,r)};le.addRightStep=function(e,t){const r=[];t.substeps.forEach(o=>{r.push(le.addRightStep(e,o))});let n=null;t.oldNode&&(n=e.clone(),n.rightNode=t.oldNode);const s=e.clone();return s.rightNode=t.newNode,new le(t.changeType,n,s,r)};le.resetChangeGroups=function(e){const t=gn.Status.resetChangeGroups(e.leftNode),r=gn.Status.resetChangeGroups(e.rightNode);return new nl(t,r,e.comparator)};var Fs=le;const G=y,{canCrossMultiplication:sl}=pe,Bt=Vt,ne=Fs,Ae=X,d=T,lt=Nr,Ms={">":"<",">=":"<=","<":">","<=":">=","=":"="},Ke={};Ke.ensureSymbolInLeftNode=function(e,t){const r=lt.getLastSymbolTerm(e.leftNode,t),n=lt.getLastSymbolTerm(e.rightNode,t);if(!r)if(n){const s=Ms[e.comparator],o=e,a=new Bt(e.rightNode,e.leftNode,s);return new ne(G.SWAP_SIDES,o,a)}else throw Error("No term with symbol: "+t);return ne.noChange(e)};Ke.crossMultiply=function(e,t){if(!sl(e))return ne.noChange(e);const n=e.leftNode.cloneDeep(),s=e.rightNode.cloneDeep(),o=e;if(d.Type.isConstantOrConstantFraction(n.args[0])&&d.PolynomialTerm.isPolynomialTerm(n.args[1])&&d.Type.isConstantOrConstantFraction(s.args[0])&&d.Type.isConstantOrConstantFraction(s.args[1])){const a=d.Creator.operator("*",[s.args[0],n.args[1]]);n.args[1].changeGroup=1;const i=d.Creator.operator("*",[s.args[1],n.args[0]]),c=new Bt(a,i,e.comparator);return new ne(G.CROSS_PRODUCT_EQUALITY,o,c)}else if(d.Type.isConstantOrConstantFraction(n.args[0])&&d.Type.isConstantOrConstantFraction(n.args[1])&&d.Type.isConstantOrConstantFraction(s.args[0])&&d.PolynomialTerm.isPolynomialTerm(s.args[1])){const a=d.Creator.operator("*",[n.args[1],s.args[0]]);s.args[0].changeGroup=1;const i=d.Creator.operator("*",[n.args[0],s.args[1]]),c=new Bt(a,i,e.comparator);return new ne(G.CROSS_PRODUCT_EQUALITY,o,c)}else throw Error("No CROSS_PRODUCT_EQUALITY: "+o.ascii())};Ke.removeSymbolFromDenominator=function(e,t){if(e.comparator!=="=")return ne.noChange(e);const r=e.leftNode,n=lt.getLastDenominatorWithSymbolTerm(r,t);return n?Or(e,"*",n,G.MULTIPLY_TO_BOTH_SIDES):ne.noChange(e)};Ke.removeSymbolFromRightSide=function(e,t){const r=e.rightNode;let n=lt.getLastSymbolTerm(r,t),s,o,a;if(!n)return ne.noChange(e);if(n=n.cloneDeep(),d.PolynomialTerm.isPolynomialTerm(r))Ae.isNegative(n)?(s="+",a=G.ADD_TO_BOTH_SIDES,o=Ae.negate(n)):(s="-",a=G.SUBTRACT_FROM_BOTH_SIDES,o=n);else if(d.Type.isOperator(r))if(r.op==="+")Ae.isNegative(n)?(s="+",a=G.ADD_TO_BOTH_SIDES,o=Ae.negate(n)):(s="-",a=G.SUBTRACT_FROM_BOTH_SIDES,o=n);else throw Error("Unsupported operation: "+n.op);else if(d.Type.isUnaryMinus(r))s="+",a=G.ADD_TO_BOTH_SIDES,o=n.args[0];else throw Error("Unsupported node type: "+r.type);return Or(e,s,o,a)};Ke.isolateSymbolOnLeftSide=function(e,t){let r=e.leftNode;d.Type.isParenthesis(r)&&(r=r.content);let n=lt.getLastNonSymbolTerm(r,t),s,o,a;if(!n)return ne.noChange(e);if(n=n.cloneDeep(),d.Type.isOperator(r))if(r.op==="+")Ae.isNegative(n)?(s="+",a=G.ADD_TO_BOTH_SIDES,o=Ae.negate(n)):(s="-",a=G.SUBTRACT_FROM_BOTH_SIDES,o=n);else if(r.op==="*")d.Type.isConstantFraction(n)?(s="*",a=G.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION,o=d.Creator.operator("/",[n.args[1],n.args[0]])):(s="/",a=G.DIVIDE_FROM_BOTH_SIDES,o=n);else if(r.op==="/")["1","-1"].indexOf(n.args[0].value)!==-1?(s="*",a=G.MULTIPLY_TO_BOTH_SIDES,o=n.args[1]):(s="*",a=G.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION,o=d.Creator.operator("/",[n.args[1],n.args[0]]));else{if(r.op==="^")return ne.noChange(e);throw Error("Unsupported operation: "+r.op)}else if(d.Type.isUnaryMinus(r))s="*",a=G.MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE,o=d.Creator.constant(-1);else throw Error("Unsupported node type: "+r.type);return Or(e,s,o,a)};function Or(e,t,r,n){const s=e.clone(),o=r.cloneDeep(),a=r.cloneDeep(),i=fn(e.leftNode,t,o),c=fn(e.rightNode,t,a);let u=e.comparator;Ae.isNegative(r)&&(t==="*"||t==="/")&&(u=Ms[u]);const C=new Bt(i,c,u);return new ne(n,s,C)}function fn(e,t,r){let n=d.Type.isOperator(e)?d.Creator.parenthesis(e):e;return d.Type.isOperator(e)&&e.op==="*"&&t==="/"&&(n=e),r.changeGroup=1,r=d.Type.isOperator(r)?d.Creator.parenthesis(r):r,d.Creator.operator(t,[n,r])}var ol=Ke;const pt=y,ke=pe,Gt=Vt,st=ol,q=Fs,hn=ye,al=Kn,Tn=ht,me=T,xt=kt,Cn=Ps,Nn=Nr,il={"=":function(e,t){return e===t},">":function(e,t){return e>t},">=":function(e,t){return e>=t},"<":function(e,t){return e<t},"<=":function(e,t){return e<=t}};function Ls(e,t,r,n=!1){let s=new Gt(e,t,r);if(n&&console.log(`

Solving: `+s.ascii(!1,!0)),ke.hasUnsupportedNodes(s.leftNode)||ke.hasUnsupportedNodes(s.rightNode))return[];const o=Nn.getSymbolsInEquation(s);if(o.size===0)return yn(s,n);const a=o.values().next().value;let i,c=[];const u=s.ascii(),C=20;let h=0;if(s.leftNode=xt(s.leftNode),s.rightNode=xt(s.rightNode),ke.canFindRoots(s))return c.push(mn(s)),c;do{if(c=vs(c,s,n),c.length>0){const N=c[c.length-1];s=Gt.createEquationFromString(N.newEquation.ascii(!1,!0),s.comparator)}if(s.leftNode=Tn(s.leftNode),s.rightNode=Tn(s.rightNode),Nn.getSymbolsInEquation(s).size===0)return yn(s,n,c);if(ke.canFindRoots(s))return c.push(mn(s)),c;try{i=ul(s,a)}catch(N){if(N.message.startsWith("No term with symbol: "))return console.error("Math error: "+N.message+", returning no steps"),[];throw N}if(i.hasChanged()){if(i.newEquation.ascii().length>300)throw Error("Math error: Potential infinite loop for equation "+u+". It reached over 300 characters  long, so returning no steps");n&&De(i),c.push(i)}if(s=q.resetChangeGroups(i.newEquation),h++===C)return console.error("Math error: Potential infinite loop for equation: "+u+", returning no steps"),[]}while(i.hasChanged());return c}function mn(e){const[t,r]=cl(e);let n;if(t.length>1){const o=[];t.forEach(a=>a.items?o.push(...a.items):o.push(a)),n=me.Creator.list(o)}else t.length===1?n=t[0]:n=me.Creator.list([]);const s=new Gt(r,n,"=");return new q(pt.FIND_ROOTS,e,s)}function cl(e){const t=e.leftNode,r=[];let n,s,o;me.Type.isOperator(t,"^")&&!ke.resolvesToConstant(t)?o=[t]:o=e.leftNode.args.filter(i=>!ke.resolvesToConstant(i));for(var a in o){let i=o[a],c=1;me.Type.isOperator(i,"^")&&(c=parseFloat(i.args[1].value),i=i.args[0]);const u=me.Type.isParenthesis(i)?i.content:i;if(s=Ls(u,e.rightNode,"="),s.length===0&&me.Type.isSymbol(u))n=u,r.push(...Array(c).fill(e.rightNode));else if(s.length!==0){const C=s.slice(-1)[0];me.Type.isSymbol(C.newEquation.leftNode)&&(n=C.newEquation.leftNode,r.push(...Array(c).fill(C.newEquation.rightNode)))}}return[r,n]}function yn(e,t,r=[]){const n=il[e.comparator];if(!n)throw Error("Unexpected comparator");if(r=vs(r,e,!0),r.length>0){const c=r[r.length-1];e=Gt.createEquationFromString(c.newEquation.ascii(),e.comparator)}if(e.leftNode=xt(e.leftNode),e.rightNode=xt(e.rightNode),!me.Type.isConstantOrConstantFraction(e.leftNode,!0)||!me.Type.isConstantOrConstantFraction(e.rightNode,!0))throw Error("Expected both nodes to be constants, instead got: "+e.ascii());const s=hn(e.leftNode),o=hn(e.rightNode);let a;n(s,o)?a=pt.STATEMENT_IS_TRUE:a=pt.STATEMENT_IS_FALSE;const i=new q(a,null,e);return t&&De(i),r.push(i),r}function ul(e,t){const r=[st.ensureSymbolInLeftNode,st.crossMultiply,st.removeSymbolFromDenominator,st.removeSymbolFromRightSide,st.isolateSymbolOnLeftSide];for(let n=0;n<r.length;n++){const s=r[n](e,t);if(s.hasChanged())return s}return q.noChange(e)}function vs(e,t,r=!1){let n=t.clone();const s=Cn(t.leftNode,!1),o=s.length!==0?s.slice(-1)[0].newNode:t.leftNode,a=al(o,!1),i=[];for(let C=0;C<s.length;C++){const h=s[C];i.push(q.addLeftStep(t,h))}for(let C=0;C<a.length;C++){const h=a[C];i.push(q.addLeftStep(t,h))}if(i.length===1){const C=i[0];r&&De(C),e.push(C)}else if(i.length>1){const C=i[i.length-1],h=q.resetChangeGroups(C.newEquation),N=new q(pt.SIMPLIFY_LEFT_SIDE,n,h,i);r&&De(N),e.push(N)}e.length>0&&(t=q.resetChangeGroups(e[e.length-1].newEquation)),n=t.clone();const c=Cn(t.rightNode,!1),u=[];for(let C=0;C<c.length;C++){const h=c[C];u.push(q.addRightStep(t,h))}if(u.length===1){const C=u[0];r&&De(C),e.push(C)}else if(u.length>1){const C=u[u.length-1],h=q.resetChangeGroups(C.newEquation),N=new q(pt.SIMPLIFY_RIGHT_SIDE,n,h,u);r&&De(N),e.push(N)}return e}function De(e){console.log(`
`+e.changeType),console.log(e.newEquation.ascii()),e.substeps.length>0&&(console.log(`
 substeps: `),e.substeps.forEach(De))}var ll=Ls;const Sn=se,pl=ll;function gl(e,t=!1){const r=["<=",">=","=","<",">"];for(let n=0;n<r.length;n++){const s=r[n],o=e.split(s);if(o.length!==2)continue;let a,i;const c=o[0].trim(),u=o[1].trim();if(!c||!u)return[];try{a=Sn.parse(c),i=Sn.parse(u)}catch{return[]}if(a&&i)return pl(a,i,s,t)}return[]}var fl=gl;const ot=y,O=X,A=T;function hl(e){if(!A.Type.isOperator(e))return A.Status.noChange(e);if(e.op==="/"){const t=e.cloneDeep();let r=e.args[0],n=e.args[1];if(O.isNegative(n)&&O.isNegative(r)){n=O.negate(n),r=O.negate(r);const s=ot.CANCEL_MINUSES,o=A.Creator.operator("/",[r,n]);return A.Status.nodeChanged(s,t,o)}else if(O.isNegative(n)&&!O.isNegative(r)){n=O.negate(n);const s=ot.SIMPLIFY_SIGNS_BEFORE,o=A.Creator.operator("/",[r,n]),a=A.Creator.unaryMinus(o);return A.Status.nodeChanged(s,t,a)}else if(!O.isNegative(n)&&O.isNegative(r)){r=O.negate(r);const s=ot.SIMPLIFY_SIGNS_BEFORE,o=A.Creator.operator("/",[r,n]),a=A.Creator.unaryMinus(o);return A.Status.nodeChanged(s,t,a)}else return A.Status.noChange(e)}else if(e.op==="-"&&e.args.length===2&&A.Type.isOperator(e.args[1])&&e.args[1].op==="/"){const t=e.args[1];let r=t.args[0],n=t.args[1],s="-";O.isNegative(r)&&O.isNegative(n)?(r=O.negate(r),n=O.negate(n),s="-"):O.isNegative(n)&&!O.isNegative(r)?(n=O.negate(n),s="+"):!O.isNegative(n)&&O.isNegative(r)&&(r=O.negate(r),s="+");const o=ot.SIMPLIFY_SIGNS_BEFORE,a=A.Creator.operator(s,[e.args[0],A.Creator.operator("/",[r,n])]);return A.Status.nodeChanged(o,e,a)}else if(e.op==="+"&&e.args.length===2&&A.Type.isOperator(e.args[1])&&e.args[1].op==="/"){const t=e.args[1];let r=t.args[0],n=t.args[1],s="+";O.isNegative(r)&&O.isNegative(n)?(r=O.negate(r),n=O.negate(n),s="+"):O.isNegative(n)&&!O.isNegative(r)?(n=O.negate(n),s="-"):!O.isNegative(n)&&O.isNegative(r)&&(r=O.negate(r),s="-");const o=ot.SIMPLIFY_SIGNS_BEFORE,a=A.Creator.operator(s,[e.args[0],A.Creator.operator("/",[r,n])]);return A.Status.nodeChanged(o,e,a)}else return A.Status.noChange(e)}var Tl=hl;const Cl=ge,Nl=kt,ml=ds,yl=Tl,Sl=Jn,El=yr,Ol=es,_l=ts,Il=rs,dl=ns,Rl=ss,Pl=os,wl=as,Fl=is,Ml=cs,Ll=us,vl={convertMixedNumberToImproperFraction:Sl,reduceMultiplicationByZero:_l,reduceZeroDividedByAnything:Il,reduceExponentByZero:Ol,removeExponentByOne:wl,removeExponentBaseOne:Pl,simplifyDoubleUnaryMinus:Ll,removeAdditionOfZero:dl,removeMultiplicationByOne:Ml,removeMultiplicationByNegativeOne:Fl,removeDivisionByOne:Rl,rearrangeCoefficient:El,removeUnnecessaryParens:Nl,simplifyFractionSigns:ml,simplifyFractionSignsBefore:yl};var Al={SIMPLIFICATION_FUNCTIONS:vl,TreeSearch:Cl};const Dl=y,$l=ni,Ul=rl,bl=fl,Bl=We,Gl=T,xl=X,Yl=ht,{SIMPLIFICATION_FUNCTIONS:Vl,TreeSearch:kl}=Al,Hl=Vt;var jl={factor:$l,simplifyExpression:Ul,solveEquation:bl,Node:Gl,Negative:xl,printMS:Bl,flatten:Yl,ChangeTypes:Dl,SIMPLIFICATION_FUNCTIONS:Vl,TreeSearch:kl,Equation:Hl};export{jl as m};
//# sourceMappingURL=mathsteps-C-ubxiiN.js.map

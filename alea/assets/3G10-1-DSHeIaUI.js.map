{"version":3,"file":"3G10-1-DSHeIaUI.js","sources":["../../src/exercices/3e/3G10-1.ts"],"sourcesContent":["import { codageAngleDroit } from '../../lib/2d/angles'\nimport { afficheMesureAngle, codageSegments } from '../../lib/2d/codages'\nimport {\n  Droite,\n  droiteAvecNomLatex,\n  droiteHorizontaleParPoint,\n  droiteParPointEtPente,\n  droiteVerticaleParPoint,\n} from '../../lib/2d/droites'\nimport {\n  milieu,\n  Point,\n  point,\n  pointSurDroite,\n  tracePoint,\n} from '../../lib/2d/points'\nimport { repere } from '../../lib/2d/reperes'\nimport { segment, vecteur } from '../../lib/2d/segmentsVecteurs'\nimport { labelPoint } from '../../lib/2d/textes'\nimport {\n  handleAnswers,\n  setReponse,\n} from '../../lib/interactif/gestionInteractif'\nimport { ajouteChampTexteMathLive } from '../../lib/interactif/questionMathLive'\nimport { choice } from '../../lib/outils/arrayOutils'\nimport { texFractionReduite } from '../../lib/outils/deprecatedFractions'\nimport { miseEnCouleur, miseEnEvidence } from '../../lib/outils/embellissements'\nimport { numAlpha } from '../../lib/outils/outilString'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { colorToLatexOrHTML, mathalea2d } from '../../modules/2dGeneralites'\nimport { context } from '../../modules/context'\nimport {\n  imagePointParTransformation,\n  type TransformationsIndex,\n} from '../../modules/imagePointParTransformation'\nimport {\n  gestionnaireFormulaireTexte,\n  listeQuestionsToContenu,\n  randint,\n} from '../../modules/outils'\nimport Exercice from '../Exercice'\n\nexport const titre =\n  \"Trouver les coordonnées de l'image d'un point par une rotation et une homothétie\"\nexport const interactifReady = true\nexport const interactifType = 'mathLive'\nexport const amcReady = true\nexport const amcType = 'AMCHybride'\nexport const dateDeModifImportante = '06/02/2024'\n\n/**\n * Trouver les coordonnées d'un punto transformé d'un autre par une des transformations du plan\n * @author Jean-Claude Lhote (Modif des paramètres, nbQuestions modifiables par Eric Elter)\n */\nexport const uuid = 'd4088'\n\nexport const refs = {\n  'fr-fr': ['3G10-1'],\n  'fr-ch': ['11ES3-1'],\n}\nexport default class TransformationsDuPlanEtCoordonnees extends Exercice {\n  constructor() {\n    super()\n    this.besoinFormulaireTexte = [\n      'Choix des transformations ',\n      'Nombres séparés par des tirets (3 maximum) \\n1 : Symétrie axiale\\n2 : Symétrie centrale\\n3 : Translation\\n4 : Rotation\\n5 : Homothétie de rapport décimal (agrandissement)\\n6 : Homothétie de rapport fractionnaire (réduction)\\n7: Mélange',\n    ]\n\n    this.nbQuestions = 1\n\n    context.fenetreMathalea2d = [-9, -9, 9, 9]\n    this.sup = '4-5-6'\n  }\n\n  nouvelleVersion() {\n    const k: number[] = []\n    // On initialise les Point pour éviter les erreurs typescript type undefined.\n    let A: Point = point(0, 0)\n    let B: Point = point(0, 0)\n    let C: Point = point(0, 0)\n    let Aprime: Point = point(0, 0)\n    let Bprime: Point = point(0, 0)\n    let Cprime: Point = point(0, 0)\n    const xP = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] // ces nombres sont juste là pour compter combien il y en a... ils seront remplacés plus tard par les coordonnées utiles ou pas.\n    const yP = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] // comme pour t, je n'utiliserai pas le premier élément pour coller aux index.\n    const t = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] // il y a 14 transformations mais je n'utilise pas t[0] pour coller avec les index.\n    const lettre1 = ['A', 'B', 'C']\n    const lettre2 = [\"O'\", 'A', 'B'] // si t[i]=0 alors la transformation concernée n'existe pas, si t[i]=1, on la dessine.\n    const punto: number[][] = [[]]\n    const couleurs = ['brown', 'green', 'blue']\n    const listeTypeDeQuestions = [[1, 2, 3, 4], [7], [8], [5, 6], [9], [10]]\n    for (\n      let ee = 0,\n        texte,\n        texteCorr,\n        xA = 0,\n        yA = 0,\n        xB = 0,\n        yB = 0,\n        xC = 0,\n        yC = 0,\n        objetsEnonce,\n        objetsCorrection,\n        cpt = 0;\n      ee < this.nbQuestions && cpt < 50;\n\n    ) {\n      const typesDeQuestionsDisponibles = gestionnaireFormulaireTexte({\n        saisie: this.sup,\n        min: 1,\n        max: 6,\n        melange: 7,\n        defaut: 7,\n        nbQuestions: 3,\n      })\n        .map(Number)\n        .map((nb) => nb - 1)\n      let enonceAmc = ''\n      texte = ''\n      texteCorr = ''\n      objetsEnonce = []\n      objetsCorrection = []\n      const choixTransformation = []\n      for (let j = 0; j < 3; j++)\n        choixTransformation.push(\n          choice(listeTypeDeQuestions[typesDeQuestionsDisponibles[j]]),\n        )\n      for (let j = 0; j < 3; j++) {\n        if (choixTransformation[j] === 10) {\n          k[j] = choice([2, 4, 5, -2, -4, -5], k) // rapport d'homothétie entre -1 et 1\n        } else {\n          k[j] = choice([1.5, 2, 3, 2.5, -1, -2, -3, -2.5, -1.5], k) // rapport d'homothétie > 1 ou <=-1\n        }\n      }\n\n      const xO = randint(-3, 3, [0, -1]) // Point O' (origine du repère dans lequel les transformations sont simples (centre des rotations et punto d'intersection des axes))\n      const yO = randint(-3, 3, [0, -1])\n      const pointO = point(0, 0, 'O', 'above right')\n\n      const O = point(xO, yO, \"O'\", 'above left') // on crée le point O'\n      let droited1,\n        droited2,\n        droited,\n        droitedprime,\n        droitedLatex,\n        droited1Latex,\n        droited2Latex,\n        droitedprimeLatex\n      let trouve = false\n      let compteur = 0\n      while (!trouve) {\n        xA = randint(-7, 7, 0) // Point A\n        yA = randint(-7, 7, -1)\n        if (xA === xO && yA === yO) xA = randint(-7, 7, [0, xO])\n        punto[0] = imagePointParTransformation(\n          choixTransformation[0] as TransformationsIndex,\n          [xA, yA],\n          [xO, yO],\n          [xO, yO],\n          k[0],\n        )\n        punto[0] = punto[0].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n        compteur = 0\n        while (\n          (punto[0][0] < -9 ||\n            punto[0][0] > 9 ||\n            punto[0][1] < -9 ||\n            punto[0][1] > 9) &&\n          compteur < 20\n        ) {\n          // on teste si A est dans la fenêtre sinon on en choisit un autre\n          xA = randint(-7, 7, [0]) // Point A\n          yA = randint(-7, 7, -1)\n          if (xA === xO && yA === yO) xA = randint(-7, 7, [0, xO])\n          punto[0] = imagePointParTransformation(\n            choixTransformation[0] as TransformationsIndex,\n            [xA, yA],\n            [xO, yO],\n            [xO, yO],\n            k[0],\n          )\n          punto[0] = punto[0].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n          compteur++\n        }\n        A = point(xA, yA, 'A')\n        Aprime = point(punto[0][0], punto[0][1], \"A'\")\n\n        // xB = randint(-7, 7, [xA, 0]) // Point B\n        xB = randint(-7, 7, [xA, 0, punto[0][0]]) // Point B\n        // yB = randint(-7, 7, -1)\n        yB = randint(-7, 7, [yA, -1])\n        if (xB === xO && yB === yO) xB = randint(-7, 7, [0, xO, xA])\n        if (choixTransformation[1] > 4) {\n          punto[1] = imagePointParTransformation(\n            choixTransformation[1] as TransformationsIndex,\n            [xB, yB],\n            [xA, yA],\n            [xA, yA],\n            k[1],\n          )\n          punto[1] = punto[1].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n        } else {\n          punto[1] = imagePointParTransformation(\n            choixTransformation[1] as TransformationsIndex,\n            [xB, yB],\n            [xO, yO],\n          )\n          punto[1] = punto[1].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n        } // si c'est une symétrie, l'axe passe par O'\n        compteur = 0\n        while (\n          (punto[1][0] < -9 ||\n            punto[1][0] > 9 ||\n            punto[1][1] < -9 ||\n            punto[1][1] > 9) &&\n          compteur < 20\n        ) {\n          // on teste si on est dans les clous, sinon on choisit un autre punto B\n          xB = randint(-7, 7, [0, xA]) // Point B\n          yB = randint(-7, 7, -1)\n          if (xB === xO && yB === yO) xB = randint(-7, 7, [0, xO, xA])\n          if (choixTransformation[1] > 4) {\n            punto[1] = imagePointParTransformation(\n              choixTransformation[1] as TransformationsIndex,\n              [xB, yB],\n              [xA, yA],\n              [xA, yA],\n              k[1],\n            )\n            punto[1] = punto[1].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n          } else {\n            punto[1] = imagePointParTransformation(\n              choixTransformation[1] as TransformationsIndex,\n              [xB, yB],\n              [xO, yO],\n            )\n            punto[1] = punto[1].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n          } // si c'est une symétrie, l'axe passe par O'\n          compteur++\n        }\n\n        B = point(xB, yB, 'B')\n        Bprime = point(punto[1][0], punto[1][1], \"B'\")\n\n        // xC = randint(-7, 7, 0) // Point C\n        xC = randint(-7, 7, [0, punto[0][0], punto[1][0]]) // Point C\n        yC = randint(-7, 7, [yA, yB, -1])\n        if (xC === xO && yC === yO) xC = randint(-7, 7, [0, xO, xA, xB])\n        if (choixTransformation[2] > 4) {\n          punto[2] = imagePointParTransformation(\n            choixTransformation[2] as TransformationsIndex,\n            [xC, yC],\n            [xB, yB],\n            [xB, yB],\n            k[2],\n          )\n          punto[2] = punto[2].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n        } else {\n          punto[2] = imagePointParTransformation(\n            choixTransformation[2] as TransformationsIndex,\n            [xC, yC],\n            [xO, yO],\n          )\n          punto[2] = punto[2].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n        } // si c'est une symétrie, l'axe passe par O'\n        compteur = 0\n        while (\n          (punto[2][0] < -9 ||\n            punto[2][0] > 9 ||\n            punto[2][1] < -9 ||\n            punto[2][1] > 9) &&\n          compteur < 20\n        ) {\n          // on vérifie que C est dans le repère sinon on change le punto C.\n          xC = randint(-7, 7, [0, xA, xB]) // Point C\n          yC = randint(-7, 7, [yA, yB, -1])\n          if (xC === xO && yC === yO) xC = randint(-7, 7, [0, xO, xA, xB])\n          if (choixTransformation[2] > 4) {\n            punto[2] = imagePointParTransformation(\n              choixTransformation[2] as TransformationsIndex,\n              [xC, yC],\n              [xB, yB],\n              [xB, yB],\n              k[2],\n            )\n            punto[2] = punto[2].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n          } else {\n            punto[2] = imagePointParTransformation(\n              choixTransformation[2] as TransformationsIndex,\n              [xC, yC],\n              [xO, yO],\n            )\n            punto[2] = punto[2].map((e) => Number(e)) // supprime les fractions étendues, on revient à la notation décimale\n          } // si c'est une symétrie, l'axe passe par O'\n          compteur++\n        }\n        if (compteur < 20) {\n          trouve = true\n        } else {\n          continue\n        }\n        C = point(xC, yC, 'C')\n        Cprime = point(punto[2][0], punto[2][1], \"C'\")\n      }\n      let couleurDroite: string = 'black'\n      // les puntos sont choisis, on écrit l'énoncé\n      for (let i = 0; i < 3; i++) {\n        couleurDroite = context.isHtml ? couleurs[i] : 'black'\n        switch (choixTransformation[i]) {\n          case 1: // symétrie axiale\n            droited1Latex = droiteAvecNomLatex(\n              droiteParPointEtPente(O, 1, '', couleurDroite),\n              '(d_1)',\n              couleurDroite,\n            )\n            droited1 = droited1Latex[0] as Droite\n            droited1.isVisible = true\n            droited1.epaisseur = 2\n            droited1.opacite = 0.5\n            t[1] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A), labelPoint(A))\n              objetsCorrection.push(\n                tracePoint(A),\n                labelPoint(A),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                segment(A, Aprime, couleurs[i]),\n                codageAngleDroit(\n                  A,\n                  milieu(A, Aprime),\n                  pointSurDroite(droited1, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '//',\n                  couleurs[i],\n                  A,\n                  milieu(A, Aprime),\n                  milieu(A, Aprime),\n                  Aprime,\n                ),\n              )\n              xP[1] = xA\n              yP[1] = yA\n            } else if (i === 1) {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[1]\n                  ? couleurs[0]\n                  : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(B), labelPoint(B))\n              objetsCorrection.push(\n                tracePoint(B),\n                labelPoint(B),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                segment(B, Bprime, couleurs[i]),\n                codageAngleDroit(\n                  B,\n                  milieu(B, Bprime),\n                  pointSurDroite(droited1, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  'O',\n                  couleurs[i],\n                  B,\n                  milieu(B, Bprime),\n                  milieu(B, Bprime),\n                  Bprime,\n                ),\n              )\n              xP[1] = xB\n              yP[1] = yB\n            } else {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[2]\n                  ? couleurs[0]\n                  : choixTransformation[1] === choixTransformation[2]\n                    ? couleurs[1]\n                    : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(C), labelPoint(C))\n              objetsCorrection.push(\n                tracePoint(C),\n                labelPoint(C),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                segment(C, Cprime, couleurs[i]),\n                codageAngleDroit(\n                  C,\n                  milieu(C, Cprime),\n                  pointSurDroite(droited1, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '|||',\n                  couleurs[i],\n                  C,\n                  milieu(C, Cprime),\n                  milieu(C, Cprime),\n                  Cprime,\n                ),\n              )\n              xP[1] = xC\n              yP[1] = yC\n            }\n            droited1.color = colorToLatexOrHTML(couleurDroite)\n            droited1Latex[1].color = colorToLatexOrHTML(couleurDroite)\n            objetsEnonce.push(droited1Latex)\n            objetsCorrection.push(droited1Latex)\n\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur('(d_1)', droited1.color[0])}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur('(d_1)', droited1.color[0])}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, le symétrique de $${lettre1[i]}$ par rapport à $(d_1)$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 2: // symétrie axiale\n            droited2Latex = droiteAvecNomLatex(\n              droiteParPointEtPente(O, -1, '', couleurDroite),\n              '(d_2)',\n              couleurDroite,\n            )\n            droited2 = droited2Latex[0] as Droite\n            droited2.isVisible = true\n            droited2.epaisseur = 2\n            droited2.opacite = 0.5\n            t[2] = 1\n            if (i === 0) {\n              droited2.color = colorToLatexOrHTML(couleurDroite)\n              objetsEnonce.push(tracePoint(A), labelPoint(A))\n              objetsCorrection.push(\n                tracePoint(A),\n                labelPoint(A),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                segment(A, Aprime, couleurs[i]),\n                codageAngleDroit(\n                  A,\n                  milieu(A, Aprime),\n                  pointSurDroite(droited2, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '//',\n                  couleurs[i],\n                  A,\n                  milieu(A, Aprime),\n                  milieu(A, Aprime),\n                  Aprime,\n                ),\n              )\n              xP[2] = xA\n              yP[2] = yA\n            } else if (i === 1) {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[1]\n                  ? couleurs[0]\n                  : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(B), labelPoint(B))\n              objetsCorrection.push(\n                tracePoint(B),\n                labelPoint(B),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                segment(B, Bprime, couleurs[i]),\n                codageAngleDroit(\n                  B,\n                  milieu(B, Bprime),\n                  pointSurDroite(droited2, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  'O',\n                  couleurs[i],\n                  B,\n                  milieu(B, Bprime),\n                  milieu(B, Bprime),\n                  Bprime,\n                ),\n              )\n              xP[2] = xB\n              yP[2] = yB\n            } else {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[2]\n                  ? couleurs[0]\n                  : choixTransformation[1] === choixTransformation[2]\n                    ? couleurs[1]\n                    : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(C), labelPoint(C))\n              objetsCorrection.push(\n                tracePoint(C),\n                labelPoint(C),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                segment(C, Cprime, couleurs[i]),\n                codageAngleDroit(\n                  C,\n                  milieu(C, Cprime),\n                  pointSurDroite(droited2, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '|||',\n                  couleurs[i],\n                  C,\n                  milieu(C, Cprime),\n                  milieu(C, Cprime),\n                  Cprime,\n                ),\n              )\n              xP[2] = xC\n              yP[2] = yC\n            }\n            droited2.color = colorToLatexOrHTML(couleurDroite)\n            droited2Latex[1].color = colorToLatexOrHTML(couleurDroite)\n            objetsEnonce.push(droited2Latex)\n            objetsCorrection.push(droited2Latex)\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur('(d_2)', droited2.color[0])}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur('(d_2)', droited2.color[0])}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, le symétrique de $${lettre1[i]}$ par rapport à $(d_2)$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 3: // symétrie axiale\n            droitedLatex = droiteAvecNomLatex(\n              droiteHorizontaleParPoint(O, ''),\n              '(d)',\n              couleurDroite,\n            )\n            droited = droitedLatex[0] as Droite\n            droited.isVisible = true\n            droited.epaisseur = 2\n            droited.opacite = 0.5\n            t[3] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A), labelPoint(A))\n              objetsCorrection.push(\n                tracePoint(A),\n                labelPoint(A),\n                tracePoint(Aprime, couleurs[i]),\n                labelPoint(Aprime, '#f15929'),\n                segment(A, Aprime, '#f15929'),\n                codageAngleDroit(\n                  A,\n                  milieu(A, Aprime),\n                  pointSurDroite(droited, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '//',\n                  couleurs[i],\n                  A,\n                  milieu(A, Aprime),\n                  milieu(A, Aprime),\n                  Aprime,\n                ),\n              )\n              xP[3] = xA\n              yP[3] = yA\n            } else if (i === 1) {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[1]\n                  ? couleurs[0]\n                  : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(B), labelPoint(B))\n              objetsCorrection.push(\n                tracePoint(B),\n                labelPoint(B),\n                tracePoint(Bprime, couleurs[i]),\n                labelPoint(Bprime, '#f15929'),\n                segment(B, Bprime, '#f15929'),\n                codageAngleDroit(\n                  B,\n                  milieu(B, Bprime),\n                  pointSurDroite(droited, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  'O',\n                  couleurs[i],\n                  B,\n                  milieu(B, Bprime),\n                  milieu(B, Bprime),\n                  Bprime,\n                ),\n              )\n              xP[3] = xB\n              yP[3] = yB\n            } else {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[2]\n                  ? couleurs[0]\n                  : choixTransformation[1] === choixTransformation[2]\n                    ? couleurs[1]\n                    : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(C), labelPoint(C))\n              objetsCorrection.push(\n                tracePoint(C),\n                labelPoint(C),\n                tracePoint(Cprime, couleurs[i]),\n                labelPoint(Cprime, '#f15929'),\n                segment(C, Cprime, '#f15929'),\n                codageAngleDroit(\n                  C,\n                  milieu(C, Cprime),\n                  pointSurDroite(droited, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '|||',\n                  couleurs[i],\n                  C,\n                  milieu(C, Cprime),\n                  milieu(C, Cprime),\n                  Cprime,\n                ),\n              )\n              xP[3] = xC\n              yP[3] = yC\n            }\n            droited.color = colorToLatexOrHTML(couleurDroite)\n            droitedLatex[1].color = colorToLatexOrHTML(couleurDroite)\n            objetsEnonce.push(droitedLatex)\n            objetsCorrection.push(droitedLatex)\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur('(d)', droited.color[0])}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur('(d)', droited.color[0])}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, le symétrique de $${lettre1[i]}$ par rapport à $(d)$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 4: // symétrie axiale\n            droitedprimeLatex = droiteAvecNomLatex(\n              droiteVerticaleParPoint(O, '', couleurDroite),\n              \"(d')\",\n              couleurDroite,\n            )\n            droitedprime = droitedprimeLatex[0] as Droite\n            droitedprime.isVisible = true\n            droitedprime.epaisseur = 2\n            droitedprime.opacite = 0.5\n            t[4] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A), labelPoint(A))\n              objetsCorrection.push(\n                tracePoint(A),\n                labelPoint(A),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                segment(A, Aprime, couleurs[i]),\n                codageAngleDroit(\n                  A,\n                  milieu(A, Aprime),\n                  pointSurDroite(droitedprime, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '//',\n                  couleurs[i],\n                  A,\n                  milieu(A, Aprime),\n                  milieu(A, Aprime),\n                  Aprime,\n                ),\n              )\n              xP[4] = xA\n              yP[4] = yA\n            } else if (i === 1) {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[1]\n                  ? couleurs[0]\n                  : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(B), labelPoint(B))\n              objetsCorrection.push(\n                tracePoint(B),\n                labelPoint(B),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                segment(B, Bprime, couleurs[i]),\n                codageAngleDroit(\n                  B,\n                  milieu(B, Bprime),\n                  pointSurDroite(droitedprime, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  'O',\n                  couleurs[i],\n                  B,\n                  milieu(B, Bprime),\n                  milieu(B, Bprime),\n                  Bprime,\n                ),\n              )\n              xP[4] = xB\n              yP[4] = yB\n            } else {\n              couleurDroite = context.isHtml\n                ? choixTransformation[0] === choixTransformation[2]\n                  ? couleurs[0]\n                  : choixTransformation[1] === choixTransformation[2]\n                    ? couleurs[1]\n                    : couleurs[i]\n                : 'black'\n              objetsEnonce.push(tracePoint(C), labelPoint(C))\n              objetsCorrection.push(\n                tracePoint(C),\n                labelPoint(C),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                segment(C, Cprime, couleurs[i]),\n                codageAngleDroit(\n                  C,\n                  milieu(C, Cprime),\n                  pointSurDroite(droitedprime, -15),\n                  couleurs[i],\n                ),\n                codageSegments(\n                  '|||',\n                  couleurs[i],\n                  C,\n                  milieu(C, Cprime),\n                  milieu(C, Cprime),\n                  Cprime,\n                ),\n              )\n              xP[4] = xC\n              yP[4] = yC\n            }\n            droitedprime.color = colorToLatexOrHTML(couleurDroite)\n            droitedprimeLatex[1].color = colorToLatexOrHTML(couleurDroite)\n            objetsEnonce.push(droitedprimeLatex)\n            objetsCorrection.push(droitedprimeLatex)\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur(\"(d')\", droitedprime.color[0])}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées du symétrique de $${lettre1[i]}$ par rapport à la droite $${miseEnCouleur(\"(d')\", droitedprime.color[0])}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, le symétrique de $${lettre1[i]}$ par rapport à $(d')$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 5: // rotation de 90°\n            t[5] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, O),\n                labelPoint(A, O),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                codageAngleDroit(A, O, Aprime, couleurs[i]),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[5] = xA\n              yP[5] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, A),\n                labelPoint(B, A),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                codageAngleDroit(B, A, Bprime, couleurs[i]),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[5] = xB\n              yP[5] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, B),\n                labelPoint(C, B),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                codageAngleDroit(C, O, Cprime, couleurs[i]),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[5] = xC\n              yP[5] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 90$^\\\\circ$ dans le sens anti-horaire.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 90$^\\\\circ$ dans le sens anti-horaire.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 90$^\\\\circ$ dans le sens anti-horaire a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 6: // rotation de 90°\n            t[6] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, O),\n                labelPoint(A, O),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                codageAngleDroit(A, O, Aprime, couleurs[i]),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                afficheMesureAngle(A, O, Aprime),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[6] = xA\n              yP[6] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, A),\n                labelPoint(B, A),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                codageAngleDroit(B, A, Bprime, couleurs[i]),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[6] = xB\n              yP[6] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, B),\n                labelPoint(C, B),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                codageAngleDroit(C, B, Cprime, couleurs[i]),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                afficheMesureAngle(C, B, Cprime),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[6] = xC\n              yP[6] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 90$^\\\\circ$ dans le sens horaire.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 90$^\\\\circ$ dans le sens horaire.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 90$^\\\\circ$ dans le sens horaire a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 7: // symétrie centrale\n            t[7] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, O),\n                labelPoint(A, O),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[7] = xA\n              yP[7] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, A),\n                labelPoint(B, A),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[7] = xB\n              yP[7] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, B),\n                labelPoint(C, B),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[7] = xC\n              yP[7] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la symétrie de centre $${lettre2[i]}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la symétrie de centre $${lettre2[i]}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la symétrie de centre $${lettre2[i]}$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n          case 8: // translation\n            t[8] = 1\n            O.positionLabel = 'right'\n            if (i === 0) {\n              objetsEnonce.push(\n                tracePoint(A, O, pointO),\n                labelPoint(A, O, pointO),\n                vecteur(pointO, O).representant(pointO),\n              )\n              objetsCorrection.push(\n                tracePoint(A, O, pointO),\n                labelPoint(A, O, pointO),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                vecteur(pointO, O).representant(A, couleurs[i]),\n                vecteur(pointO, O).representant(pointO, couleurs[i]),\n              )\n              xP[8] = xA\n              yP[8] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(\n                tracePoint(B, A, pointO),\n                labelPoint(B, A, pointO),\n                vecteur(pointO, A).representant(pointO),\n              )\n              objetsCorrection.push(\n                tracePoint(B, A, pointO),\n                labelPoint(B, A, pointO),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                vecteur(pointO, A).representant(B, couleurs[i]),\n                vecteur(pointO, A).representant(pointO, couleurs[i]),\n              )\n              xP[8] = xB\n              yP[8] = yB\n            } else {\n              objetsEnonce.push(\n                tracePoint(C, B, pointO),\n                labelPoint(C, B, pointO),\n                vecteur(pointO, B).representant(pointO),\n              )\n              objetsCorrection.push(\n                tracePoint(C, B, pointO),\n                labelPoint(C, B, pointO),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                vecteur(pointO, B).representant(C, couleurs[i]),\n                vecteur(pointO, B).representant(pointO, couleurs[i]),\n              )\n              xP[8] = xC\n              yP[8] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la translation qui transforme $O$ en $${lettre2[i]}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la translation qui transforme $O$ en $${lettre2[i]}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la translation qui transforme $O$ en $${lettre2[i]}$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 9: // homothétie de rapport décimal (agrandissement)\n            t[9] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, O),\n                labelPoint(A, O),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n              )\n              xP[9] = xA\n              yP[9] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, A),\n                labelPoint(B, A),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n              )\n\n              xP[9] = xB\n              yP[9] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, B),\n                labelPoint(C, B),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n              )\n\n              xP[9] = xC\n              yP[9] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par l'homothétie de centre $${lettre2[i]}$ et de rapport $${texNombre(k[i])}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par l'homothétie de centre $${lettre2[i]}$ et de rapport $${texNombre(k[i])}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par l'homothétie de centre $${lettre2[i]}$ et de rapport $${texNombre(k[i])}$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 10: // homothétie de rapport fractionnaire (réduction)\n            t[10] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, O),\n                labelPoint(A, O),\n                tracePoint(Aprime, '#f15929'),\n                labelPoint(Aprime, '#f15929'),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n              )\n              xP[10] = xA\n              yP[10] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, A),\n                labelPoint(B, A),\n                tracePoint(Bprime, '#f15929'),\n                labelPoint(Bprime, '#f15929'),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n              )\n              xP[10] = xB\n              yP[10] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, B),\n                labelPoint(C, B),\n                tracePoint(Cprime, '#f15929'),\n                labelPoint(Cprime, '#f15929'),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n              )\n              xP[10] = xC\n              yP[10] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par l'homothétie de centre $${lettre2[i]}$ et de rapport $${texFractionReduite(1, k[i])}$.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par l'homothétie de centre $${lettre2[i]}$ et de rapport $${texFractionReduite(1, k[i])}$.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par l'homothétie de centre $${lettre2[i]}$ et de rapport $${texFractionReduite(1, k[i])}$ a pour coordonnées $${miseEnEvidence(`(${texNombre(punto[i][0])};${texNombre(punto[i][1])})`)}$.<br>`\n            break\n\n          case 11: // rotation de 60$^\\\\circ$\n            t[11] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, Aprime, O),\n                labelPoint(A, Aprime, O),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                afficheMesureAngle(A, O, Aprime),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[11] = xA\n              yP[11] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, Bprime, A),\n                labelPoint(B, Bprime, A),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                afficheMesureAngle(B, A, Bprime),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[11] = xB\n              yP[11] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, Cprime, B),\n                labelPoint(C, Cprime, B),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                afficheMesureAngle(C, B, Cprime),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[11] = xC\n              yP[11] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 60$^\\\\circ$ dans le sens anti-horaire.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 60$^\\\\circ$ dans le sens anti-horaire.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 60$^\\\\circ$ dans le sens anti-horaire a pour coordonnées ($${texNombre(punto[i][0], 2)};${texNombre(punto[i][1], 2)}$).<br>`\n            break\n          case 12: // rotation de 60$^\\\\circ$\n            t[12] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, Aprime, O),\n                labelPoint(A, Aprime, O),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                afficheMesureAngle(A, O, Aprime),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[12] = xA\n              yP[12] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, Bprime, A),\n                labelPoint(B, Bprime, A),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                afficheMesureAngle(B, A, Bprime),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[12] = xB\n              yP[12] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, Cprime, B),\n                labelPoint(C, Cprime, B),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                afficheMesureAngle(C, B, Cprime),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[12] = xC\n              yP[12] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 60$^\\\\circ$ dans le sens horaire.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 60$^\\\\circ$ dans le sens horaire.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 60$^\\\\circ$ dans le sens horaire a pour coordonnées ($${texNombre(punto[i][0], 2)};${texNombre((punto[i][1], 2))}$).<br>`\n            break\n\n          case 13: // rotation de 120°\n            t[13] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, Aprime, O),\n                labelPoint(A, Aprime, O),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                afficheMesureAngle(A, O, Aprime),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[13] = xA\n              yP[13] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, Bprime, A),\n                labelPoint(B, Bprime, A),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                afficheMesureAngle(B, A, Bprime),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[13] = xB\n              yP[13] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, Cprime, B),\n                labelPoint(C, Cprime, B),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                afficheMesureAngle(C, B, Cprime),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[13] = xC\n              yP[13] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 120° dans le sens anti-horaire.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 120° dans le sens anti-horaire.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 120° dans le sens anti-horaire a pour coordonnées ($${texNombre(punto[i][0], 2)};${texNombre(punto[i][1], 2)}$).<br>`\n            break\n\n          case 14: // rotation de 120°\n            t[14] = 1\n            if (i === 0) {\n              objetsEnonce.push(tracePoint(A, O), labelPoint(A, O))\n              objetsCorrection.push(\n                tracePoint(A, Aprime, O),\n                labelPoint(A, Aprime, O),\n                segment(O, A, couleurs[i]),\n                segment(O, Aprime, couleurs[i]),\n                afficheMesureAngle(A, O, Aprime),\n                codageSegments('//', couleurs[i], O, A, O, Aprime),\n              )\n              xP[14] = xA\n              yP[14] = yA\n            } else if (i === 1) {\n              objetsEnonce.push(tracePoint(B, A), labelPoint(B, A))\n              objetsCorrection.push(\n                tracePoint(B, Bprime, A),\n                labelPoint(B, Bprime, A),\n                segment(A, B, couleurs[i]),\n                segment(A, Bprime, couleurs[i]),\n                afficheMesureAngle(B, A, Bprime),\n                codageSegments('O', couleurs[i], A, B, A, Bprime),\n              )\n              xP[14] = xB\n              yP[14] = yB\n            } else {\n              objetsEnonce.push(tracePoint(C, B), labelPoint(C, B))\n              objetsCorrection.push(\n                tracePoint(C, Cprime, B),\n                labelPoint(C, Cprime, B),\n                segment(B, C, couleurs[i]),\n                segment(B, Cprime, couleurs[i]),\n                afficheMesureAngle(C, B, Cprime),\n                codageSegments('|||', couleurs[i], B, C, B, Cprime),\n              )\n              xP[14] = xC\n              yP[14] = yC\n            }\n            texte +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 120° dans le sens horaire.`\n            if (context.isAmc) {\n              enonceAmc +=\n                (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n                ` Donner les coordonnées de l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 120° dans le sens horaire.`\n            }\n            texteCorr +=\n              (i === 0 ? numAlpha(i) : '<br>' + numAlpha(i)) +\n              ` $${lettre1[i]}'$, l'image de $${lettre1[i]}$ par la rotation de centre $${lettre2[i]}$ et d'angle 120° dans le sens horaire a pour coordonnées ($${texNombre(punto[i][0], 2)};${texNombre(punto[i][1], 2)}$).<br>`\n            break\n        }\n        texte += ajouteChampTexteMathLive(this, i, '')\n        texte += '<br>'\n        if (context.isAmc)\n          setReponse(this, i, [\n            `${punto[i][0]};${punto[i][1]}`,\n            `(${punto[i][0]};${punto[i][1]})`,\n          ])\n        handleAnswers(this, i, {\n          reponse: {\n            value: [\n              `${punto[i][0]};${punto[i][1]}`,\n              `(${punto[i][0]};${punto[i][1]})`,\n            ],\n            options: { texteAvecCasse: true },\n          },\n        })\n\n        if (context.isAmc) {\n          enonceAmc += '<br>'\n        }\n      }\n      objetsEnonce.push(\n        repere({\n          xMin: -10,\n          yMin: -10,\n          xMax: 10,\n          yMax: 10,\n          grilleOpacite: 0.2,\n        }),\n      )\n      objetsCorrection.push(\n        repere({\n          xMin: -10,\n          yMin: -10,\n          xMax: 10,\n          yMax: 10,\n          grilleOpacite: 0.2,\n        }),\n      )\n      if (context.isAmc) {\n        this.autoCorrection.push({\n          enonce:\n            '\\\\begin{center}' +\n            mathalea2d(\n              {\n                xmin: -10,\n                ymin: -10,\n                xmax: 10,\n                ymax: 10,\n                pixelsParCm: 20,\n                scale: 0.45,\n                mainlevee: false,\n              },\n              objetsEnonce,\n            ) +\n            '\\\\\\\\' +\n            '\\\\end{center}' +\n            enonceAmc,\n          enonceAvant: false,\n          enonceApresNumQuestion: true,\n          options: { barreseparation: false },\n          propositions: [\n            {\n              type: 'AMCNum',\n              propositions: [\n                {\n                  texte: '',\n                  statut: '',\n                  multicolsBegin: true,\n                  reponse: {\n                    texte: numAlpha(0) + \" Abscisse de l'image de A\",\n                    valeur: punto[0][0],\n                    param: {\n                      digits: 1,\n                      decimals: 0,\n                      signe: true,\n                      approx: 0,\n                    },\n                  },\n                },\n              ],\n            },\n            {\n              type: 'AMCNum',\n              propositions: [\n                {\n                  texte: `A(${punto[0][0]};${punto[0][1]})`,\n                  statut: '',\n                  multicolsEnd: true,\n                  reponse: {\n                    texte: \"Ordonnée de l'image de A\",\n                    valeur: punto[0][1],\n                    param: {\n                      digits: 1,\n                      decimals: 0,\n                      signe: true,\n                      approx: 0,\n                    },\n                  },\n                },\n              ],\n            },\n            {\n              type: 'AMCNum',\n              propositions: [\n                {\n                  texte: '',\n                  statut: '',\n                  multicolsBegin: true,\n                  reponse: {\n                    texte: numAlpha(1) + \" Abscisse de l'image de B\",\n                    valeur: punto[1][0],\n                    param: {\n                      digits: 1,\n                      decimals: 0,\n                      signe: true,\n                      approx: 0,\n                    },\n                  },\n                },\n              ],\n            },\n            {\n              type: 'AMCNum',\n              propositions: [\n                {\n                  texte: `B(${punto[1][0]};${punto[1][1]})`,\n                  statut: '',\n                  multicolsEnd: true,\n                  reponse: {\n                    texte: \"Ordonnée de l'image de B\",\n                    valeur: punto[1][1],\n                    param: {\n                      digits: 1,\n                      decimals: 0,\n                      signe: true,\n                      approx: 0,\n                    },\n                  },\n                },\n              ],\n            },\n            {\n              type: 'AMCNum',\n              propositions: [\n                {\n                  texte: '',\n                  statut: '',\n                  multicolsBegin: true,\n                  reponse: {\n                    texte: numAlpha(2) + \" Abscisse de l'image de C\",\n                    valeur: punto[2][0],\n                    param: {\n                      digits: 1,\n                      decimals: 0,\n                      signe: true,\n                      approx: 0,\n                    },\n                  },\n                },\n              ],\n            },\n            {\n              type: 'AMCNum',\n              propositions: [\n                {\n                  texte: `C(${punto[2][0]};${punto[2][1]})`,\n                  statut: '',\n                  multicolsEnd: true,\n                  reponse: {\n                    texte: \"Ordonnée de l'image de C\",\n                    valeur: punto[2][1],\n                    param: {\n                      digits: 1,\n                      decimals: 0,\n                      signe: true,\n                      approx: 0,\n                    },\n                  },\n                },\n              ],\n            },\n          ],\n        })\n      }\n      if (this.questionJamaisPosee(ee, xA, yA, xB, yB, xC, yC)) {\n        this.listeQuestions[ee] =\n          texte +\n          '<br>' +\n          mathalea2d(\n            {\n              xmin: -10,\n              ymin: -10,\n              xmax: 10,\n              ymax: 10,\n              pixelsParCm: 20,\n              scale: 0.45,\n              mainlevee: false,\n            },\n            objetsEnonce,\n          )\n        this.listeCorrections[ee] =\n          texteCorr +\n          '<br>' +\n          mathalea2d(\n            {\n              xmin: -10,\n              ymin: -10,\n              xmax: 10,\n              ymax: 10,\n              pixelsParCm: 20,\n              scale: 0.45,\n              mainlevee: false,\n            },\n            objetsCorrection,\n          )\n        ee++\n      }\n      cpt++\n    }\n    listeQuestionsToContenu(this)\n  }\n}\n"],"names":["titre","interactifReady","interactifType","amcReady","amcType","dateDeModifImportante","uuid","refs","TransformationsDuPlanEtCoordonnees","Exercice","context","k","A","point","B","C","Aprime","Bprime","Cprime","lettre1","lettre2","punto","couleurs","listeTypeDeQuestions","ee","texte","texteCorr","xA","yA","xB","yB","xC","yC","objetsEnonce","objetsCorrection","cpt","typesDeQuestionsDisponibles","gestionnaireFormulaireTexte","nb","enonceAmc","choixTransformation","j","choice","xO","randint","yO","pointO","O","droited1","droited2","droited","droitedprime","droitedLatex","droited1Latex","droited2Latex","droitedprimeLatex","trouve","compteur","imagePointParTransformation","couleurDroite","i","droiteAvecNomLatex","droiteParPointEtPente","tracePoint","labelPoint","segment","codageAngleDroit","milieu","pointSurDroite","codageSegments","colorToLatexOrHTML","numAlpha","miseEnCouleur","miseEnEvidence","texNombre","droiteHorizontaleParPoint","droiteVerticaleParPoint","afficheMesureAngle","vecteur","texFractionReduite","ajouteChampTexteMathLive","setReponse","handleAnswers","repere","mathalea2d","listeQuestionsToContenu"],"mappings":"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"}
{"version":3,"file":"1A-S4-7-DJeydACb.js","sources":["../../src/exercices/1e/1A-S4-7.ts"],"sourcesContent":["import { shuffle } from '../../lib/outils/arrayOutils'\nimport { texteGras } from '../../lib/outils/embellissements'\nimport { texNombre } from '../../lib/outils/texNombre'\nimport { nombreElementsDifferents } from '../ExerciceQcm'\nimport ExerciceQcmA from '../ExerciceQcmA'\n\nexport const uuid = '0c97a'\nexport const refs = {\n  'fr-fr': ['1A-S4-7'],\n  'fr-ch': ['4mQCM-1'],\n}\nexport const interactifReady = true\nexport const interactifType = 'qcm'\nexport const amcReady = 'true'\nexport const amcType = 'qcmMono'\nexport const titre =\n  \"Comparer la moyenne et l'écart-type d'une série rangée en classes.\"\nexport const dateDePublication = '05/08/2025'\n// Ceci est un exemple de QCM avec version originale et version aléatoire\n/**\n * @author Stéphane Guyon\n */\n\nexport default class MoyenneEcartTypeClasseQCM extends ExerciceQcmA {\n  // Ceci est la fonction qui s'occupe d'écrire l'énoncé, la correction et les réponses\n  // Elle factorise le code qui serait dupliqué dans versionAleatoire et versionOriginale\n  private appliquerLesValeurs(): void {\n    const moyenne = (arr: number[]) =>\n      arr.reduce((sum, x) => sum + x, 0) / arr.length\n\n    const ecartType = (arr: number[]) => {\n      const m = moyenne(arr)\n      const variance =\n        arr.reduce((sum, x) => sum + Math.pow(x - m, 2), 0) / arr.length\n      return Math.sqrt(variance)\n    }\n\n    const genereSerie = (\n      moyenneCible: number,\n      dispersion: number,\n    ): number[] => {\n      const base = moyenneCible\n      const deltas = {\n        faible: [0, 0, 1, -1],\n        moyenne: [0, 2, -2, 0],\n        forte: [3, -3, 0, 0],\n      }\n\n      const ecarts =\n        deltas[\n          dispersion === 1 ? 'faible' : dispersion === 2 ? 'moyenne' : 'forte'\n        ]\n      const melange = shuffle(ecarts)\n      return melange.map((d) => base + d)\n    }\n\n    // Choix aléatoire de scénario\n    const scenario = Math.floor(Math.random() * 4)\n\n    let serieA: number[] = []\n    let serieB: number[] = []\n\n    switch (scenario) {\n      case 0:\n        // Même moyenne, mais série B plus dispersée\n        serieA = genereSerie(10, 1)\n        serieB = genereSerie(10, 3)\n        break\n      case 1:\n        // Moyenne A > B, écart-type similaire\n        serieA = genereSerie(12, 2)\n        serieB = genereSerie(9, 2)\n        break\n      case 2:\n        // Moyenne égale, A plus dispersée\n        serieA = genereSerie(10, 3)\n        serieB = genereSerie(10, 1)\n        break\n      case 3:\n        // Moyenne B > A, écart-type égal\n        serieA = genereSerie(9, 3)\n        serieB = genereSerie(12, 3)\n        break\n    }\n\n    const moyA = moyenne(serieA)\n    const moyB = moyenne(serieB)\n    const etA = ecartType(serieA)\n    const etB = ecartType(serieB)\n\n    // Liste standardisée des 4 réponses possibles\n    const toutesLesReponses = [\n      'La moyenne de la série B est strictement supérieure à la moyenne de la série A.',\n      'La moyenne de la série A est strictement supérieure à la moyenne de la série B.',\n      'L’écart-type de la série A est strictement supérieur à l’écart-type de la série B.',\n      'L’écart-type de la série B est strictement supérieur à l’écart-type de la série A.',\n    ]\n\n    // Détection automatique de la bonne réponse\n    let bonnePhrase = ''\n    let explication = ''\n\n    if (moyB > moyA) {\n      bonnePhrase = toutesLesReponses[0]\n      explication = `La moyenne de la série B est ${texNombre(moyB, 2)}, celle de la série A est ${texNombre(moyA, 2)}.<br>\n      On peut conclure que la seule réponse acceptable est que la moyenne de la série B est strictement supérieure à celle de la série A.<br>\n      Il n'est pas nécessaire de calculer l'écart-type pour répondre à cette question.`\n    } else if (moyA > moyB) {\n      bonnePhrase = toutesLesReponses[1]\n      explication = `La moyenne de la série A est ${texNombre(moyA, 2)}, celle de la série B est ${texNombre(moyB, 2)}.\n      <br>On peut conclure que la seule réponse acceptable est que la moyenne de la série A est strictement supérieure à celle de la série B.<br>\n      Il n'est pas nécessaire de calculer l'écart-type pour répondre à cette question.`\n    } else if (etA > etB) {\n      bonnePhrase = toutesLesReponses[2]\n      explication = `On calcule facilement les moyennes des deux séries qui sont toutes les deux égales à ${texNombre(moyA, 2)}.<br>\n      Il s'agit donc de comparer les écarts-types des deux séries et non pas de les calculer. L'écart-type est un paramètre qui quantifie la dispersion d'une série. \n      On constate visuellement que la série A est plus dispersée que celle de la série B. <br>\n      En conséquence, son écart-type est plus élevé. <br>\n      L'écart-type de la série A est strictement supérieur à celui de la série B.`\n    } else {\n      bonnePhrase = toutesLesReponses[3]\n      explication = `On calcule facilement les moyennes des deux séries qui sont toutes les deux égales à ${texNombre(moyA, 2)}.<br>\n      Il s'agit donc de comparer les écarts-types des deux séries et non pas de les calculer. L'écart-type est un paramètre qui quantifie la dispersion d'une série. \n      On constate visuellement que la série B est plus dispersée que celle de la série A. <br>\n      En conséquence, son écart-type est plus élevé. <br>\n      L'écart-type de la série B est strictement supérieur à celui de la série A.`\n    }\n\n    // Réorganiser les réponses pour mettre la bonne en premier\n    const autres = toutesLesReponses.filter((r) => r !== bonnePhrase)\n    this.reponses = [bonnePhrase, ...autres]\n\n    // Construire l'énoncé\n    this.enonce = `On considère les deux séries suivantes :  <br>\n${texteGras('Série A :')} $${serieA.join(' ; ')} $ <br>\n${texteGras('Série B :')} $${serieB.join(' ; ')} $ <br>\n\nLaquelle des quatre propositions suivantes est vraie ?`\n\n    // Définir la bonne réponse\n    this.reponse = bonnePhrase\n\n    // Correction : explication simple, claire\n    this.correction = explication\n  }\n\n  versionAleatoire: () => void = () => {\n    const n = 4 // nombre de réponses différentes voulues (on rappelle que la première réponse est la bonne)\n    do {\n      this.appliquerLesValeurs()\n    } while (nombreElementsDifferents(this.reponses) < n)\n  }\n\n  // Ici il n'y a rien à faire, on appelle juste la version aleatoire (pour un qcm aleatoirisé, c'est le fonctionnement par défaut)\n  constructor() {\n    super()\n    this.options = { vertical: true, ordered: false }\n    this.versionAleatoire()\n  }\n}\n"],"names":["uuid","refs","interactifReady","interactifType","amcReady","amcType","titre","dateDePublication","MoyenneEcartTypeClasseQCM","ExerciceQcmA","__publicField","nombreElementsDifferents","moyenne","arr","sum","x","ecartType","m","variance","genereSerie","moyenneCible","dispersion","base","ecarts","shuffle","d","scenario","serieA","serieB","moyA","moyB","etA","etB","toutesLesReponses","bonnePhrase","explication","texNombre","autres","r","texteGras"],"mappings":"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"}